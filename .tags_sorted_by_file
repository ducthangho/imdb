!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
handl	apps/httpd/main.cc	/^class handl : public httpd::handler_base {$/;"	c	file:
handle	apps/httpd/main.cc	/^    virtual future<std::unique_ptr<reply> > handle(const sstring& path,$/;"	f	class:handl
main	apps/httpd/main.cc	/^int main(int ac, char** av) {$/;"	f
set_routes	apps/httpd/main.cc	/^void set_routes(routes& r) {$/;"	f
add	apps/imdb/adder.capnp.cc	/^::kj::Promise<void> Adder::Server::add(AddContext) {$/;"	f	class:Adder::Server
addRequest	apps/imdb/adder.capnp.cc	/^Adder::Client::addRequest(::kj::Maybe< ::capnp::MessageSize> sizeHint) {$/;"	f	class:Adder::Client
b_b8be46ef26e86dff	apps/imdb/adder.capnp.cc	/^static const ::capnp::_::AlignedData<31> b_b8be46ef26e86dff = {$/;"	m	namespace:capnp::schemas	file:
b_ba94ad36c3f10265	apps/imdb/adder.capnp.cc	/^static const ::capnp::_::AlignedData<28> b_ba94ad36c3f10265 = {$/;"	m	namespace:capnp::schemas	file:
b_d4cbdcb482c79554	apps/imdb/adder.capnp.cc	/^static const ::capnp::_::AlignedData<45> b_d4cbdcb482c79554 = {$/;"	m	namespace:capnp::schemas	file:
bp_b8be46ef26e86dff	apps/imdb/adder.capnp.cc	/^::capnp::word const* const bp_b8be46ef26e86dff = b_b8be46ef26e86dff.words;$/;"	m	class:capnp::schemas::capnp	file:
bp_ba94ad36c3f10265	apps/imdb/adder.capnp.cc	/^::capnp::word const* const bp_ba94ad36c3f10265 = b_ba94ad36c3f10265.words;$/;"	m	class:capnp::schemas::capnp	file:
bp_d4cbdcb482c79554	apps/imdb/adder.capnp.cc	/^::capnp::word const* const bp_d4cbdcb482c79554 = b_d4cbdcb482c79554.words;$/;"	m	class:capnp::schemas::capnp	file:
brand	apps/imdb/adder.capnp.cc	/^constexpr ::capnp::_::RawBrandedSchema const* Adder::AddParams::_capnpPrivate::brand;$/;"	m	class:constexpr::capnp::_::Adder::AddParams::_capnpPrivate	file:
brand	apps/imdb/adder.capnp.cc	/^constexpr ::capnp::_::RawBrandedSchema const* Adder::AddResults::_capnpPrivate::brand;$/;"	m	class:constexpr::capnp::_::Adder::AddResults::_capnpPrivate	file:
brand	apps/imdb/adder.capnp.cc	/^constexpr ::capnp::_::RawBrandedSchema const* Adder::_capnpPrivate::brand;$/;"	m	class:constexpr::capnp::_::Adder::_capnpPrivate	file:
capnp	apps/imdb/adder.capnp.cc	/^namespace capnp {$/;"	n	file:
d_ba94ad36c3f10265	apps/imdb/adder.capnp.cc	/^static const ::capnp::_::RawSchema* const d_ba94ad36c3f10265[] = {$/;"	m	class:capnp::schemas::capnp::_	file:
dataWordSize	apps/imdb/adder.capnp.cc	/^constexpr uint16_t Adder::AddParams::_capnpPrivate::dataWordSize;$/;"	m	class:Adder::AddParams::_capnpPrivate	file:
dataWordSize	apps/imdb/adder.capnp.cc	/^constexpr uint16_t Adder::AddResults::_capnpPrivate::dataWordSize;$/;"	m	class:Adder::AddResults::_capnpPrivate	file:
dispatchCall	apps/imdb/adder.capnp.cc	/^::kj::Promise<void> Adder::Server::dispatchCall($/;"	f	class:Adder::Server
dispatchCallInternal	apps/imdb/adder.capnp.cc	/^::kj::Promise<void> Adder::Server::dispatchCallInternal($/;"	f	class:Adder::Server
i_b8be46ef26e86dff	apps/imdb/adder.capnp.cc	/^static const uint16_t i_b8be46ef26e86dff[] = {0};$/;"	m	namespace:capnp::schemas	file:
i_d4cbdcb482c79554	apps/imdb/adder.capnp.cc	/^static const uint16_t i_d4cbdcb482c79554[] = {0, 1};$/;"	m	namespace:capnp::schemas	file:
kind	apps/imdb/adder.capnp.cc	/^constexpr ::capnp::Kind Adder::AddParams::_capnpPrivate::kind;$/;"	m	class:Adder::AddParams::_capnpPrivate	file:
kind	apps/imdb/adder.capnp.cc	/^constexpr ::capnp::Kind Adder::AddResults::_capnpPrivate::kind;$/;"	m	class:Adder::AddResults::_capnpPrivate	file:
kind	apps/imdb/adder.capnp.cc	/^constexpr ::capnp::Kind Adder::_capnpPrivate::kind;$/;"	m	class:Adder::_capnpPrivate	file:
m_b8be46ef26e86dff	apps/imdb/adder.capnp.cc	/^static const uint16_t m_b8be46ef26e86dff[] = {0};$/;"	m	namespace:capnp::schemas	file:
m_ba94ad36c3f10265	apps/imdb/adder.capnp.cc	/^static const uint16_t m_ba94ad36c3f10265[] = {0};$/;"	m	namespace:capnp::schemas	file:
m_d4cbdcb482c79554	apps/imdb/adder.capnp.cc	/^static const uint16_t m_d4cbdcb482c79554[] = {0, 1};$/;"	m	namespace:capnp::schemas	file:
pointerCount	apps/imdb/adder.capnp.cc	/^constexpr uint16_t Adder::AddParams::_capnpPrivate::pointerCount;$/;"	m	class:Adder::AddParams::_capnpPrivate	file:
pointerCount	apps/imdb/adder.capnp.cc	/^constexpr uint16_t Adder::AddResults::_capnpPrivate::pointerCount;$/;"	m	class:Adder::AddResults::_capnpPrivate	file:
s_b8be46ef26e86dff	apps/imdb/adder.capnp.cc	/^const ::capnp::_::RawSchema s_b8be46ef26e86dff = {$/;"	m	namespace:capnp::schemas	file:
s_ba94ad36c3f10265	apps/imdb/adder.capnp.cc	/^const ::capnp::_::RawSchema s_ba94ad36c3f10265 = {$/;"	m	namespace:capnp::schemas	file:
s_d4cbdcb482c79554	apps/imdb/adder.capnp.cc	/^const ::capnp::_::RawSchema s_d4cbdcb482c79554 = {$/;"	m	namespace:capnp::schemas	file:
schema	apps/imdb/adder.capnp.cc	/^constexpr ::capnp::_::RawSchema const* Adder::AddParams::_capnpPrivate::schema;$/;"	m	class:constexpr::capnp::_::Adder::AddParams::_capnpPrivate	file:
schema	apps/imdb/adder.capnp.cc	/^constexpr ::capnp::_::RawSchema const* Adder::AddResults::_capnpPrivate::schema;$/;"	m	class:constexpr::capnp::_::Adder::AddResults::_capnpPrivate	file:
schema	apps/imdb/adder.capnp.cc	/^constexpr ::capnp::_::RawSchema const* Adder::_capnpPrivate::schema;$/;"	m	class:constexpr::capnp::_::Adder::_capnpPrivate	file:
schemas	apps/imdb/adder.capnp.cc	/^namespace schemas {$/;"	n	namespace:capnp	file:
AddContext	apps/imdb/adder.capnp.hh	/^  typedef ::capnp::CallContext<AddParams, AddResults> AddContext;$/;"	t	class:Adder::Server
AddParams	apps/imdb/adder.capnp.hh	/^  typedef  ::Adder::AddParams AddParams;$/;"	t	class:Adder::Server
AddParams	apps/imdb/adder.capnp.hh	/^struct Adder::AddParams {$/;"	s	class:Adder
AddResults	apps/imdb/adder.capnp.hh	/^  typedef  ::Adder::AddResults AddResults;$/;"	t	class:Adder::Server
AddResults	apps/imdb/adder.capnp.hh	/^struct Adder::AddResults {$/;"	s	class:Adder
Adder	apps/imdb/adder.capnp.hh	/^struct Adder {$/;"	s
Builder	apps/imdb/adder.capnp.hh	/^  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}$/;"	f	class:Adder::AddParams::Builder
Builder	apps/imdb/adder.capnp.hh	/^  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}$/;"	f	class:Adder::AddResults::Builder
Builder	apps/imdb/adder.capnp.hh	/^class Adder::AddParams::Builder {$/;"	c	class:Adder::AddParams
Builder	apps/imdb/adder.capnp.hh	/^class Adder::AddResults::Builder {$/;"	c	class:Adder::AddResults
Builds	apps/imdb/adder.capnp.hh	/^  typedef AddParams Builds;$/;"	t	class:Adder::AddParams::Builder
Builds	apps/imdb/adder.capnp.hh	/^  typedef AddResults Builds;$/;"	t	class:Adder::AddResults::Builder
CAPNP_INCLUDED_e309f28a2aa780e7_	apps/imdb/adder.capnp.hh	5;"	d
Calls	apps/imdb/adder.capnp.hh	/^  typedef Adder Calls;$/;"	t	class:Adder::Client
Client	apps/imdb/adder.capnp.hh	/^class Adder::Client$/;"	c	class:Adder
Client	apps/imdb/adder.capnp.hh	/^inline Adder::Client::Client($/;"	f	class:Adder::Client
Client	apps/imdb/adder.capnp.hh	/^inline Adder::Client::Client(::kj::Exception&& exception)$/;"	f	class:Adder::Client
Client	apps/imdb/adder.capnp.hh	/^inline Adder::Client::Client(::kj::Own<_t>&& server)$/;"	f	class:Adder::Client
Client	apps/imdb/adder.capnp.hh	/^inline Adder::Client::Client(::kj::Promise<_t>&& promise)$/;"	f	class:Adder::Client
Pipeline	apps/imdb/adder.capnp.hh	/^  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)$/;"	f	class:Adder::AddParams::Pipeline
Pipeline	apps/imdb/adder.capnp.hh	/^  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)$/;"	f	class:Adder::AddResults::Pipeline
Pipeline	apps/imdb/adder.capnp.hh	/^class Adder::AddParams::Pipeline {$/;"	c	class:Adder::AddParams
Pipeline	apps/imdb/adder.capnp.hh	/^class Adder::AddResults::Pipeline {$/;"	c	class:Adder::AddResults
Pipelines	apps/imdb/adder.capnp.hh	/^  typedef AddParams Pipelines;$/;"	t	class:Adder::AddParams::Pipeline
Pipelines	apps/imdb/adder.capnp.hh	/^  typedef AddResults Pipelines;$/;"	t	class:Adder::AddResults::Pipeline
Reader	apps/imdb/adder.capnp.hh	/^  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}$/;"	f	class:Adder::AddParams::Reader
Reader	apps/imdb/adder.capnp.hh	/^  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}$/;"	f	class:Adder::AddResults::Reader
Reader	apps/imdb/adder.capnp.hh	/^class Adder::AddParams::Reader {$/;"	c	class:Adder::AddParams
Reader	apps/imdb/adder.capnp.hh	/^class Adder::AddResults::Reader {$/;"	c	class:Adder::AddResults
Reads	apps/imdb/adder.capnp.hh	/^  typedef AddParams Reads;$/;"	t	class:Adder::AddParams::Reader
Reads	apps/imdb/adder.capnp.hh	/^  typedef AddResults Reads;$/;"	t	class:Adder::AddResults::Reader
Reads	apps/imdb/adder.capnp.hh	/^  typedef Adder Reads;$/;"	t	class:Adder::Client
Server	apps/imdb/adder.capnp.hh	/^class Adder::Server$/;"	c	class:Adder
Serves	apps/imdb/adder.capnp.hh	/^  typedef Adder Serves;$/;"	t	class:Adder::Server
_builder	apps/imdb/adder.capnp.hh	/^  ::capnp::_::StructBuilder _builder;$/;"	m	class:Adder::AddParams::Builder
_builder	apps/imdb/adder.capnp.hh	/^  ::capnp::_::StructBuilder _builder;$/;"	m	class:Adder::AddResults::Builder
_capnpPrivate	apps/imdb/adder.capnp.hh	/^  struct _capnpPrivate {$/;"	s	struct:Adder
_capnpPrivate	apps/imdb/adder.capnp.hh	/^  struct _capnpPrivate {$/;"	s	struct:Adder::AddParams
_capnpPrivate	apps/imdb/adder.capnp.hh	/^  struct _capnpPrivate {$/;"	s	struct:Adder::AddResults
_reader	apps/imdb/adder.capnp.hh	/^  ::capnp::_::StructReader _reader;$/;"	m	class:Adder::AddParams::Reader
_reader	apps/imdb/adder.capnp.hh	/^  ::capnp::_::StructReader _reader;$/;"	m	class:Adder::AddResults::Reader
_typeless	apps/imdb/adder.capnp.hh	/^  ::capnp::AnyPointer::Pipeline _typeless;$/;"	m	class:Adder::AddParams::Pipeline
_typeless	apps/imdb/adder.capnp.hh	/^  ::capnp::AnyPointer::Pipeline _typeless;$/;"	m	class:Adder::AddResults::Pipeline
asReader	apps/imdb/adder.capnp.hh	/^  inline Reader asReader() const { return *this; }$/;"	f	class:Adder::AddParams::Builder
asReader	apps/imdb/adder.capnp.hh	/^  inline Reader asReader() const { return *this; }$/;"	f	class:Adder::AddResults::Builder
brand	apps/imdb/adder.capnp.hh	/^    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;$/;"	m	class:Adder::AddParams::_capnpPrivate::constexpr::capnp::_
brand	apps/imdb/adder.capnp.hh	/^    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;$/;"	m	class:Adder::AddResults::_capnpPrivate::constexpr::capnp::_
brand	apps/imdb/adder.capnp.hh	/^    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;$/;"	m	class:Adder::_capnpPrivate::constexpr::capnp::_
capnp	apps/imdb/adder.capnp.hh	/^namespace capnp {$/;"	n
decltype	apps/imdb/adder.capnp.hh	/^  inline Builder(decltype(nullptr)) {}$/;"	f	class:Adder::AddParams::Builder
decltype	apps/imdb/adder.capnp.hh	/^  inline Builder(decltype(nullptr)) {}$/;"	f	class:Adder::AddResults::Builder
decltype	apps/imdb/adder.capnp.hh	/^  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}$/;"	f	class:Adder::AddParams::Pipeline
decltype	apps/imdb/adder.capnp.hh	/^  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}$/;"	f	class:Adder::AddResults::Pipeline
decltype	apps/imdb/adder.capnp.hh	/^inline Adder::Client::Client(decltype(nullptr))$/;"	f	class:Adder::Client
getLeft	apps/imdb/adder.capnp.hh	/^inline  ::int32_t Adder::AddParams::Builder::getLeft() {$/;"	f	class:Adder::AddParams::Builder
getLeft	apps/imdb/adder.capnp.hh	/^inline  ::int32_t Adder::AddParams::Reader::getLeft() const {$/;"	f	class:Adder::AddParams::Reader
getRight	apps/imdb/adder.capnp.hh	/^inline  ::int32_t Adder::AddParams::Builder::getRight() {$/;"	f	class:Adder::AddParams::Builder
getRight	apps/imdb/adder.capnp.hh	/^inline  ::int32_t Adder::AddParams::Reader::getRight() const {$/;"	f	class:Adder::AddParams::Reader
getValue	apps/imdb/adder.capnp.hh	/^inline  ::int32_t Adder::AddResults::Builder::getValue() {$/;"	f	class:Adder::AddResults::Builder
getValue	apps/imdb/adder.capnp.hh	/^inline  ::int32_t Adder::AddResults::Reader::getValue() const {$/;"	f	class:Adder::AddResults::Reader
operator =	apps/imdb/adder.capnp.hh	/^inline  ::Adder::Client& Adder::Client::operator=(Client& other) {$/;"	f	class:Adder::Client
operator =	apps/imdb/adder.capnp.hh	/^inline  ::Adder::Client& Adder::Client::operator=(Client&& other) {$/;"	f	class:Adder::Client
operator Reader	apps/imdb/adder.capnp.hh	/^  inline operator Reader() const { return Reader(_builder.asReader()); }$/;"	f	class:Adder::AddParams::Builder
operator Reader	apps/imdb/adder.capnp.hh	/^  inline operator Reader() const { return Reader(_builder.asReader()); }$/;"	f	class:Adder::AddResults::Builder
override	apps/imdb/adder.capnp.hh	/^      override;$/;"	m	class:Adder::Server
schemas	apps/imdb/adder.capnp.hh	/^namespace schemas {$/;"	n	namespace:capnp
setLeft	apps/imdb/adder.capnp.hh	/^inline void Adder::AddParams::Builder::setLeft( ::int32_t value) {$/;"	f	class:Adder::AddParams::Builder
setRight	apps/imdb/adder.capnp.hh	/^inline void Adder::AddParams::Builder::setRight( ::int32_t value) {$/;"	f	class:Adder::AddParams::Builder
setValue	apps/imdb/adder.capnp.hh	/^inline void Adder::AddResults::Builder::setValue( ::int32_t value) {$/;"	f	class:Adder::AddResults::Builder
toString	apps/imdb/adder.capnp.hh	/^  inline ::kj::StringTree toString() const { return asReader().toString(); }$/;"	f	class:Adder::AddParams::Builder
toString	apps/imdb/adder.capnp.hh	/^  inline ::kj::StringTree toString() const { return asReader().toString(); }$/;"	f	class:Adder::AddResults::Builder
toString	apps/imdb/adder.capnp.hh	/^  inline ::kj::StringTree toString() const {$/;"	f	class:Adder::AddParams::Reader
toString	apps/imdb/adder.capnp.hh	/^  inline ::kj::StringTree toString() const {$/;"	f	class:Adder::AddResults::Reader
totalSize	apps/imdb/adder.capnp.hh	/^  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }$/;"	f	class:Adder::AddParams::Builder
totalSize	apps/imdb/adder.capnp.hh	/^  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }$/;"	f	class:Adder::AddResults::Builder
totalSize	apps/imdb/adder.capnp.hh	/^  inline ::capnp::MessageSize totalSize() const {$/;"	f	class:Adder::AddParams::Reader
totalSize	apps/imdb/adder.capnp.hh	/^  inline ::capnp::MessageSize totalSize() const {$/;"	f	class:Adder::AddResults::Reader
ErrorHandlerImpl	apps/imdb/hash-client.c++	/^class ErrorHandlerImpl: public kj::TaskSet::ErrorHandler {$/;"	c	file:
exceptionCount	apps/imdb/hash-client.c++	/^  int exceptionCount = 0;$/;"	m	class:ErrorHandlerImpl	file:
main	apps/imdb/hash-client.c++	/^int main(int argc, const char* argv[]) {$/;"	f
final	apps/imdb/hash-server.c++	/^class HashProtocolImpl final: public HashProtocol::Server {$/;"	c	file:
main	apps/imdb/hash-server.c++	/^int main(int argc, const char* argv[]) {$/;"	f
mymap	apps/imdb/hash-server.c++	/^	std::map<int,int> mymap;$/;"	m	class:final	file:
b_98ff8d7ca69e3522	apps/imdb/hashprotocol.capnp.cc	/^static const ::capnp::_::AlignedData<33> b_98ff8d7ca69e3522 = {$/;"	m	namespace:capnp::schemas	file:
b_ba420be562e5bb4f	apps/imdb/hashprotocol.capnp.cc	/^static const ::capnp::_::AlignedData<39> b_ba420be562e5bb4f = {$/;"	m	namespace:capnp::schemas	file:
b_de47f7e9fb27c285	apps/imdb/hashprotocol.capnp.cc	/^static const ::capnp::_::AlignedData<33> b_de47f7e9fb27c285 = {$/;"	m	namespace:capnp::schemas	file:
b_fbf504be45a7de98	apps/imdb/hashprotocol.capnp.cc	/^static const ::capnp::_::AlignedData<47> b_fbf504be45a7de98 = {$/;"	m	namespace:capnp::schemas	file:
b_feaac643283b7cea	apps/imdb/hashprotocol.capnp.cc	/^static const ::capnp::_::AlignedData<33> b_feaac643283b7cea = {$/;"	m	namespace:capnp::schemas	file:
bp_98ff8d7ca69e3522	apps/imdb/hashprotocol.capnp.cc	/^::capnp::word const* const bp_98ff8d7ca69e3522 = b_98ff8d7ca69e3522.words;$/;"	m	class:capnp::schemas::capnp	file:
bp_ba420be562e5bb4f	apps/imdb/hashprotocol.capnp.cc	/^::capnp::word const* const bp_ba420be562e5bb4f = b_ba420be562e5bb4f.words;$/;"	m	class:capnp::schemas::capnp	file:
bp_de47f7e9fb27c285	apps/imdb/hashprotocol.capnp.cc	/^::capnp::word const* const bp_de47f7e9fb27c285 = b_de47f7e9fb27c285.words;$/;"	m	class:capnp::schemas::capnp	file:
bp_fbf504be45a7de98	apps/imdb/hashprotocol.capnp.cc	/^::capnp::word const* const bp_fbf504be45a7de98 = b_fbf504be45a7de98.words;$/;"	m	class:capnp::schemas::capnp	file:
bp_feaac643283b7cea	apps/imdb/hashprotocol.capnp.cc	/^::capnp::word const* const bp_feaac643283b7cea = b_feaac643283b7cea.words;$/;"	m	class:capnp::schemas::capnp	file:
brand	apps/imdb/hashprotocol.capnp.cc	/^constexpr ::capnp::_::RawBrandedSchema const* HashProtocol::GetParams::_capnpPrivate::brand;$/;"	m	class:constexpr::capnp::_::HashProtocol::GetParams::_capnpPrivate	file:
brand	apps/imdb/hashprotocol.capnp.cc	/^constexpr ::capnp::_::RawBrandedSchema const* HashProtocol::GetResults::_capnpPrivate::brand;$/;"	m	class:constexpr::capnp::_::HashProtocol::GetResults::_capnpPrivate	file:
brand	apps/imdb/hashprotocol.capnp.cc	/^constexpr ::capnp::_::RawBrandedSchema const* HashProtocol::SetParams::_capnpPrivate::brand;$/;"	m	class:constexpr::capnp::_::HashProtocol::SetParams::_capnpPrivate	file:
brand	apps/imdb/hashprotocol.capnp.cc	/^constexpr ::capnp::_::RawBrandedSchema const* HashProtocol::SetResults::_capnpPrivate::brand;$/;"	m	class:constexpr::capnp::_::HashProtocol::SetResults::_capnpPrivate	file:
brand	apps/imdb/hashprotocol.capnp.cc	/^constexpr ::capnp::_::RawBrandedSchema const* HashProtocol::_capnpPrivate::brand;$/;"	m	class:constexpr::capnp::_::HashProtocol::_capnpPrivate	file:
capnp	apps/imdb/hashprotocol.capnp.cc	/^namespace capnp {$/;"	n	file:
d_ba420be562e5bb4f	apps/imdb/hashprotocol.capnp.cc	/^static const ::capnp::_::RawSchema* const d_ba420be562e5bb4f[] = {$/;"	m	class:capnp::schemas::capnp::_	file:
dataWordSize	apps/imdb/hashprotocol.capnp.cc	/^constexpr uint16_t HashProtocol::GetParams::_capnpPrivate::dataWordSize;$/;"	m	class:HashProtocol::GetParams::_capnpPrivate	file:
dataWordSize	apps/imdb/hashprotocol.capnp.cc	/^constexpr uint16_t HashProtocol::GetResults::_capnpPrivate::dataWordSize;$/;"	m	class:HashProtocol::GetResults::_capnpPrivate	file:
dataWordSize	apps/imdb/hashprotocol.capnp.cc	/^constexpr uint16_t HashProtocol::SetParams::_capnpPrivate::dataWordSize;$/;"	m	class:HashProtocol::SetParams::_capnpPrivate	file:
dataWordSize	apps/imdb/hashprotocol.capnp.cc	/^constexpr uint16_t HashProtocol::SetResults::_capnpPrivate::dataWordSize;$/;"	m	class:HashProtocol::SetResults::_capnpPrivate	file:
dispatchCall	apps/imdb/hashprotocol.capnp.cc	/^::kj::Promise<void> HashProtocol::Server::dispatchCall($/;"	f	class:HashProtocol::Server
dispatchCallInternal	apps/imdb/hashprotocol.capnp.cc	/^::kj::Promise<void> HashProtocol::Server::dispatchCallInternal($/;"	f	class:HashProtocol::Server
get	apps/imdb/hashprotocol.capnp.cc	/^::kj::Promise<void> HashProtocol::Server::get(GetContext) {$/;"	f	class:HashProtocol::Server
getRequest	apps/imdb/hashprotocol.capnp.cc	/^HashProtocol::Client::getRequest(::kj::Maybe< ::capnp::MessageSize> sizeHint) {$/;"	f	class:HashProtocol::Client
i_98ff8d7ca69e3522	apps/imdb/hashprotocol.capnp.cc	/^static const uint16_t i_98ff8d7ca69e3522[] = {0};$/;"	m	namespace:capnp::schemas	file:
i_de47f7e9fb27c285	apps/imdb/hashprotocol.capnp.cc	/^static const uint16_t i_de47f7e9fb27c285[] = {0};$/;"	m	namespace:capnp::schemas	file:
i_fbf504be45a7de98	apps/imdb/hashprotocol.capnp.cc	/^static const uint16_t i_fbf504be45a7de98[] = {0, 1};$/;"	m	namespace:capnp::schemas	file:
i_feaac643283b7cea	apps/imdb/hashprotocol.capnp.cc	/^static const uint16_t i_feaac643283b7cea[] = {0};$/;"	m	namespace:capnp::schemas	file:
kind	apps/imdb/hashprotocol.capnp.cc	/^constexpr ::capnp::Kind HashProtocol::GetParams::_capnpPrivate::kind;$/;"	m	class:HashProtocol::GetParams::_capnpPrivate	file:
kind	apps/imdb/hashprotocol.capnp.cc	/^constexpr ::capnp::Kind HashProtocol::GetResults::_capnpPrivate::kind;$/;"	m	class:HashProtocol::GetResults::_capnpPrivate	file:
kind	apps/imdb/hashprotocol.capnp.cc	/^constexpr ::capnp::Kind HashProtocol::SetParams::_capnpPrivate::kind;$/;"	m	class:HashProtocol::SetParams::_capnpPrivate	file:
kind	apps/imdb/hashprotocol.capnp.cc	/^constexpr ::capnp::Kind HashProtocol::SetResults::_capnpPrivate::kind;$/;"	m	class:HashProtocol::SetResults::_capnpPrivate	file:
kind	apps/imdb/hashprotocol.capnp.cc	/^constexpr ::capnp::Kind HashProtocol::_capnpPrivate::kind;$/;"	m	class:HashProtocol::_capnpPrivate	file:
m_98ff8d7ca69e3522	apps/imdb/hashprotocol.capnp.cc	/^static const uint16_t m_98ff8d7ca69e3522[] = {0};$/;"	m	namespace:capnp::schemas	file:
m_ba420be562e5bb4f	apps/imdb/hashprotocol.capnp.cc	/^static const uint16_t m_ba420be562e5bb4f[] = {0, 1};$/;"	m	namespace:capnp::schemas	file:
m_de47f7e9fb27c285	apps/imdb/hashprotocol.capnp.cc	/^static const uint16_t m_de47f7e9fb27c285[] = {0};$/;"	m	namespace:capnp::schemas	file:
m_fbf504be45a7de98	apps/imdb/hashprotocol.capnp.cc	/^static const uint16_t m_fbf504be45a7de98[] = {0, 1};$/;"	m	namespace:capnp::schemas	file:
m_feaac643283b7cea	apps/imdb/hashprotocol.capnp.cc	/^static const uint16_t m_feaac643283b7cea[] = {0};$/;"	m	namespace:capnp::schemas	file:
pointerCount	apps/imdb/hashprotocol.capnp.cc	/^constexpr uint16_t HashProtocol::GetParams::_capnpPrivate::pointerCount;$/;"	m	class:HashProtocol::GetParams::_capnpPrivate	file:
pointerCount	apps/imdb/hashprotocol.capnp.cc	/^constexpr uint16_t HashProtocol::GetResults::_capnpPrivate::pointerCount;$/;"	m	class:HashProtocol::GetResults::_capnpPrivate	file:
pointerCount	apps/imdb/hashprotocol.capnp.cc	/^constexpr uint16_t HashProtocol::SetParams::_capnpPrivate::pointerCount;$/;"	m	class:HashProtocol::SetParams::_capnpPrivate	file:
pointerCount	apps/imdb/hashprotocol.capnp.cc	/^constexpr uint16_t HashProtocol::SetResults::_capnpPrivate::pointerCount;$/;"	m	class:HashProtocol::SetResults::_capnpPrivate	file:
s_98ff8d7ca69e3522	apps/imdb/hashprotocol.capnp.cc	/^const ::capnp::_::RawSchema s_98ff8d7ca69e3522 = {$/;"	m	namespace:capnp::schemas	file:
s_ba420be562e5bb4f	apps/imdb/hashprotocol.capnp.cc	/^const ::capnp::_::RawSchema s_ba420be562e5bb4f = {$/;"	m	namespace:capnp::schemas	file:
s_de47f7e9fb27c285	apps/imdb/hashprotocol.capnp.cc	/^const ::capnp::_::RawSchema s_de47f7e9fb27c285 = {$/;"	m	namespace:capnp::schemas	file:
s_fbf504be45a7de98	apps/imdb/hashprotocol.capnp.cc	/^const ::capnp::_::RawSchema s_fbf504be45a7de98 = {$/;"	m	namespace:capnp::schemas	file:
s_feaac643283b7cea	apps/imdb/hashprotocol.capnp.cc	/^const ::capnp::_::RawSchema s_feaac643283b7cea = {$/;"	m	namespace:capnp::schemas	file:
schema	apps/imdb/hashprotocol.capnp.cc	/^constexpr ::capnp::_::RawSchema const* HashProtocol::GetParams::_capnpPrivate::schema;$/;"	m	class:constexpr::capnp::_::HashProtocol::GetParams::_capnpPrivate	file:
schema	apps/imdb/hashprotocol.capnp.cc	/^constexpr ::capnp::_::RawSchema const* HashProtocol::GetResults::_capnpPrivate::schema;$/;"	m	class:constexpr::capnp::_::HashProtocol::GetResults::_capnpPrivate	file:
schema	apps/imdb/hashprotocol.capnp.cc	/^constexpr ::capnp::_::RawSchema const* HashProtocol::SetParams::_capnpPrivate::schema;$/;"	m	class:constexpr::capnp::_::HashProtocol::SetParams::_capnpPrivate	file:
schema	apps/imdb/hashprotocol.capnp.cc	/^constexpr ::capnp::_::RawSchema const* HashProtocol::SetResults::_capnpPrivate::schema;$/;"	m	class:constexpr::capnp::_::HashProtocol::SetResults::_capnpPrivate	file:
schema	apps/imdb/hashprotocol.capnp.cc	/^constexpr ::capnp::_::RawSchema const* HashProtocol::_capnpPrivate::schema;$/;"	m	class:constexpr::capnp::_::HashProtocol::_capnpPrivate	file:
schemas	apps/imdb/hashprotocol.capnp.cc	/^namespace schemas {$/;"	n	namespace:capnp	file:
set	apps/imdb/hashprotocol.capnp.cc	/^::kj::Promise<void> HashProtocol::Server::set(SetContext) {$/;"	f	class:HashProtocol::Server
setRequest	apps/imdb/hashprotocol.capnp.cc	/^HashProtocol::Client::setRequest(::kj::Maybe< ::capnp::MessageSize> sizeHint) {$/;"	f	class:HashProtocol::Client
Builder	apps/imdb/hashprotocol.capnp.hh	/^  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}$/;"	f	class:HashProtocol::GetParams::Builder
Builder	apps/imdb/hashprotocol.capnp.hh	/^  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}$/;"	f	class:HashProtocol::GetResults::Builder
Builder	apps/imdb/hashprotocol.capnp.hh	/^  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}$/;"	f	class:HashProtocol::SetParams::Builder
Builder	apps/imdb/hashprotocol.capnp.hh	/^  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}$/;"	f	class:HashProtocol::SetResults::Builder
Builder	apps/imdb/hashprotocol.capnp.hh	/^class HashProtocol::GetParams::Builder {$/;"	c	class:HashProtocol::GetParams
Builder	apps/imdb/hashprotocol.capnp.hh	/^class HashProtocol::GetResults::Builder {$/;"	c	class:HashProtocol::GetResults
Builder	apps/imdb/hashprotocol.capnp.hh	/^class HashProtocol::SetParams::Builder {$/;"	c	class:HashProtocol::SetParams
Builder	apps/imdb/hashprotocol.capnp.hh	/^class HashProtocol::SetResults::Builder {$/;"	c	class:HashProtocol::SetResults
Builds	apps/imdb/hashprotocol.capnp.hh	/^  typedef GetParams Builds;$/;"	t	class:HashProtocol::GetParams::Builder
Builds	apps/imdb/hashprotocol.capnp.hh	/^  typedef GetResults Builds;$/;"	t	class:HashProtocol::GetResults::Builder
Builds	apps/imdb/hashprotocol.capnp.hh	/^  typedef SetParams Builds;$/;"	t	class:HashProtocol::SetParams::Builder
Builds	apps/imdb/hashprotocol.capnp.hh	/^  typedef SetResults Builds;$/;"	t	class:HashProtocol::SetResults::Builder
CAPNP_INCLUDED_85150b117366d14b_	apps/imdb/hashprotocol.capnp.hh	5;"	d
Calls	apps/imdb/hashprotocol.capnp.hh	/^  typedef HashProtocol Calls;$/;"	t	class:HashProtocol::Client
Client	apps/imdb/hashprotocol.capnp.hh	/^class HashProtocol::Client$/;"	c	class:HashProtocol
Client	apps/imdb/hashprotocol.capnp.hh	/^inline HashProtocol::Client::Client($/;"	f	class:HashProtocol::Client
Client	apps/imdb/hashprotocol.capnp.hh	/^inline HashProtocol::Client::Client(::kj::Exception&& exception)$/;"	f	class:HashProtocol::Client
Client	apps/imdb/hashprotocol.capnp.hh	/^inline HashProtocol::Client::Client(::kj::Own<_t>&& server)$/;"	f	class:HashProtocol::Client
Client	apps/imdb/hashprotocol.capnp.hh	/^inline HashProtocol::Client::Client(::kj::Promise<_t>&& promise)$/;"	f	class:HashProtocol::Client
GetContext	apps/imdb/hashprotocol.capnp.hh	/^  typedef ::capnp::CallContext<GetParams, GetResults> GetContext;$/;"	t	class:HashProtocol::Server
GetParams	apps/imdb/hashprotocol.capnp.hh	/^  typedef  ::HashProtocol::GetParams GetParams;$/;"	t	class:HashProtocol::Server
GetParams	apps/imdb/hashprotocol.capnp.hh	/^struct HashProtocol::GetParams {$/;"	s	class:HashProtocol
GetResults	apps/imdb/hashprotocol.capnp.hh	/^  typedef  ::HashProtocol::GetResults GetResults;$/;"	t	class:HashProtocol::Server
GetResults	apps/imdb/hashprotocol.capnp.hh	/^struct HashProtocol::GetResults {$/;"	s	class:HashProtocol
HashProtocol	apps/imdb/hashprotocol.capnp.hh	/^struct HashProtocol {$/;"	s
Pipeline	apps/imdb/hashprotocol.capnp.hh	/^  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)$/;"	f	class:HashProtocol::GetParams::Pipeline
Pipeline	apps/imdb/hashprotocol.capnp.hh	/^  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)$/;"	f	class:HashProtocol::GetResults::Pipeline
Pipeline	apps/imdb/hashprotocol.capnp.hh	/^  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)$/;"	f	class:HashProtocol::SetParams::Pipeline
Pipeline	apps/imdb/hashprotocol.capnp.hh	/^  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)$/;"	f	class:HashProtocol::SetResults::Pipeline
Pipeline	apps/imdb/hashprotocol.capnp.hh	/^class HashProtocol::GetParams::Pipeline {$/;"	c	class:HashProtocol::GetParams
Pipeline	apps/imdb/hashprotocol.capnp.hh	/^class HashProtocol::GetResults::Pipeline {$/;"	c	class:HashProtocol::GetResults
Pipeline	apps/imdb/hashprotocol.capnp.hh	/^class HashProtocol::SetParams::Pipeline {$/;"	c	class:HashProtocol::SetParams
Pipeline	apps/imdb/hashprotocol.capnp.hh	/^class HashProtocol::SetResults::Pipeline {$/;"	c	class:HashProtocol::SetResults
Pipelines	apps/imdb/hashprotocol.capnp.hh	/^  typedef GetParams Pipelines;$/;"	t	class:HashProtocol::GetParams::Pipeline
Pipelines	apps/imdb/hashprotocol.capnp.hh	/^  typedef GetResults Pipelines;$/;"	t	class:HashProtocol::GetResults::Pipeline
Pipelines	apps/imdb/hashprotocol.capnp.hh	/^  typedef SetParams Pipelines;$/;"	t	class:HashProtocol::SetParams::Pipeline
Pipelines	apps/imdb/hashprotocol.capnp.hh	/^  typedef SetResults Pipelines;$/;"	t	class:HashProtocol::SetResults::Pipeline
Reader	apps/imdb/hashprotocol.capnp.hh	/^  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}$/;"	f	class:HashProtocol::GetParams::Reader
Reader	apps/imdb/hashprotocol.capnp.hh	/^  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}$/;"	f	class:HashProtocol::GetResults::Reader
Reader	apps/imdb/hashprotocol.capnp.hh	/^  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}$/;"	f	class:HashProtocol::SetParams::Reader
Reader	apps/imdb/hashprotocol.capnp.hh	/^  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}$/;"	f	class:HashProtocol::SetResults::Reader
Reader	apps/imdb/hashprotocol.capnp.hh	/^class HashProtocol::GetParams::Reader {$/;"	c	class:HashProtocol::GetParams
Reader	apps/imdb/hashprotocol.capnp.hh	/^class HashProtocol::GetResults::Reader {$/;"	c	class:HashProtocol::GetResults
Reader	apps/imdb/hashprotocol.capnp.hh	/^class HashProtocol::SetParams::Reader {$/;"	c	class:HashProtocol::SetParams
Reader	apps/imdb/hashprotocol.capnp.hh	/^class HashProtocol::SetResults::Reader {$/;"	c	class:HashProtocol::SetResults
Reads	apps/imdb/hashprotocol.capnp.hh	/^  typedef GetParams Reads;$/;"	t	class:HashProtocol::GetParams::Reader
Reads	apps/imdb/hashprotocol.capnp.hh	/^  typedef GetResults Reads;$/;"	t	class:HashProtocol::GetResults::Reader
Reads	apps/imdb/hashprotocol.capnp.hh	/^  typedef HashProtocol Reads;$/;"	t	class:HashProtocol::Client
Reads	apps/imdb/hashprotocol.capnp.hh	/^  typedef SetParams Reads;$/;"	t	class:HashProtocol::SetParams::Reader
Reads	apps/imdb/hashprotocol.capnp.hh	/^  typedef SetResults Reads;$/;"	t	class:HashProtocol::SetResults::Reader
Server	apps/imdb/hashprotocol.capnp.hh	/^class HashProtocol::Server$/;"	c	class:HashProtocol
Serves	apps/imdb/hashprotocol.capnp.hh	/^  typedef HashProtocol Serves;$/;"	t	class:HashProtocol::Server
SetContext	apps/imdb/hashprotocol.capnp.hh	/^  typedef ::capnp::CallContext<SetParams, SetResults> SetContext;$/;"	t	class:HashProtocol::Server
SetParams	apps/imdb/hashprotocol.capnp.hh	/^  typedef  ::HashProtocol::SetParams SetParams;$/;"	t	class:HashProtocol::Server
SetParams	apps/imdb/hashprotocol.capnp.hh	/^struct HashProtocol::SetParams {$/;"	s	class:HashProtocol
SetResults	apps/imdb/hashprotocol.capnp.hh	/^  typedef  ::HashProtocol::SetResults SetResults;$/;"	t	class:HashProtocol::Server
SetResults	apps/imdb/hashprotocol.capnp.hh	/^struct HashProtocol::SetResults {$/;"	s	class:HashProtocol
_builder	apps/imdb/hashprotocol.capnp.hh	/^  ::capnp::_::StructBuilder _builder;$/;"	m	class:HashProtocol::GetParams::Builder
_builder	apps/imdb/hashprotocol.capnp.hh	/^  ::capnp::_::StructBuilder _builder;$/;"	m	class:HashProtocol::GetResults::Builder
_builder	apps/imdb/hashprotocol.capnp.hh	/^  ::capnp::_::StructBuilder _builder;$/;"	m	class:HashProtocol::SetParams::Builder
_builder	apps/imdb/hashprotocol.capnp.hh	/^  ::capnp::_::StructBuilder _builder;$/;"	m	class:HashProtocol::SetResults::Builder
_capnpPrivate	apps/imdb/hashprotocol.capnp.hh	/^  struct _capnpPrivate {$/;"	s	struct:HashProtocol
_capnpPrivate	apps/imdb/hashprotocol.capnp.hh	/^  struct _capnpPrivate {$/;"	s	struct:HashProtocol::GetParams
_capnpPrivate	apps/imdb/hashprotocol.capnp.hh	/^  struct _capnpPrivate {$/;"	s	struct:HashProtocol::GetResults
_capnpPrivate	apps/imdb/hashprotocol.capnp.hh	/^  struct _capnpPrivate {$/;"	s	struct:HashProtocol::SetParams
_capnpPrivate	apps/imdb/hashprotocol.capnp.hh	/^  struct _capnpPrivate {$/;"	s	struct:HashProtocol::SetResults
_reader	apps/imdb/hashprotocol.capnp.hh	/^  ::capnp::_::StructReader _reader;$/;"	m	class:HashProtocol::GetParams::Reader
_reader	apps/imdb/hashprotocol.capnp.hh	/^  ::capnp::_::StructReader _reader;$/;"	m	class:HashProtocol::GetResults::Reader
_reader	apps/imdb/hashprotocol.capnp.hh	/^  ::capnp::_::StructReader _reader;$/;"	m	class:HashProtocol::SetParams::Reader
_reader	apps/imdb/hashprotocol.capnp.hh	/^  ::capnp::_::StructReader _reader;$/;"	m	class:HashProtocol::SetResults::Reader
_typeless	apps/imdb/hashprotocol.capnp.hh	/^  ::capnp::AnyPointer::Pipeline _typeless;$/;"	m	class:HashProtocol::GetParams::Pipeline
_typeless	apps/imdb/hashprotocol.capnp.hh	/^  ::capnp::AnyPointer::Pipeline _typeless;$/;"	m	class:HashProtocol::GetResults::Pipeline
_typeless	apps/imdb/hashprotocol.capnp.hh	/^  ::capnp::AnyPointer::Pipeline _typeless;$/;"	m	class:HashProtocol::SetParams::Pipeline
_typeless	apps/imdb/hashprotocol.capnp.hh	/^  ::capnp::AnyPointer::Pipeline _typeless;$/;"	m	class:HashProtocol::SetResults::Pipeline
asReader	apps/imdb/hashprotocol.capnp.hh	/^  inline Reader asReader() const { return *this; }$/;"	f	class:HashProtocol::GetParams::Builder
asReader	apps/imdb/hashprotocol.capnp.hh	/^  inline Reader asReader() const { return *this; }$/;"	f	class:HashProtocol::GetResults::Builder
asReader	apps/imdb/hashprotocol.capnp.hh	/^  inline Reader asReader() const { return *this; }$/;"	f	class:HashProtocol::SetParams::Builder
asReader	apps/imdb/hashprotocol.capnp.hh	/^  inline Reader asReader() const { return *this; }$/;"	f	class:HashProtocol::SetResults::Builder
brand	apps/imdb/hashprotocol.capnp.hh	/^    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;$/;"	m	class:HashProtocol::GetParams::_capnpPrivate::constexpr::capnp::_
brand	apps/imdb/hashprotocol.capnp.hh	/^    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;$/;"	m	class:HashProtocol::GetResults::_capnpPrivate::constexpr::capnp::_
brand	apps/imdb/hashprotocol.capnp.hh	/^    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;$/;"	m	class:HashProtocol::SetParams::_capnpPrivate::constexpr::capnp::_
brand	apps/imdb/hashprotocol.capnp.hh	/^    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;$/;"	m	class:HashProtocol::SetResults::_capnpPrivate::constexpr::capnp::_
brand	apps/imdb/hashprotocol.capnp.hh	/^    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;$/;"	m	class:HashProtocol::_capnpPrivate::constexpr::capnp::_
capnp	apps/imdb/hashprotocol.capnp.hh	/^namespace capnp {$/;"	n
decltype	apps/imdb/hashprotocol.capnp.hh	/^  inline Builder(decltype(nullptr)) {}$/;"	f	class:HashProtocol::GetParams::Builder
decltype	apps/imdb/hashprotocol.capnp.hh	/^  inline Builder(decltype(nullptr)) {}$/;"	f	class:HashProtocol::GetResults::Builder
decltype	apps/imdb/hashprotocol.capnp.hh	/^  inline Builder(decltype(nullptr)) {}$/;"	f	class:HashProtocol::SetParams::Builder
decltype	apps/imdb/hashprotocol.capnp.hh	/^  inline Builder(decltype(nullptr)) {}$/;"	f	class:HashProtocol::SetResults::Builder
decltype	apps/imdb/hashprotocol.capnp.hh	/^  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}$/;"	f	class:HashProtocol::GetParams::Pipeline
decltype	apps/imdb/hashprotocol.capnp.hh	/^  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}$/;"	f	class:HashProtocol::GetResults::Pipeline
decltype	apps/imdb/hashprotocol.capnp.hh	/^  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}$/;"	f	class:HashProtocol::SetParams::Pipeline
decltype	apps/imdb/hashprotocol.capnp.hh	/^  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}$/;"	f	class:HashProtocol::SetResults::Pipeline
decltype	apps/imdb/hashprotocol.capnp.hh	/^inline HashProtocol::Client::Client(decltype(nullptr))$/;"	f	class:HashProtocol::Client
getKey	apps/imdb/hashprotocol.capnp.hh	/^inline  ::int32_t HashProtocol::GetParams::Builder::getKey() {$/;"	f	class:HashProtocol::GetParams::Builder
getKey	apps/imdb/hashprotocol.capnp.hh	/^inline  ::int32_t HashProtocol::GetParams::Reader::getKey() const {$/;"	f	class:HashProtocol::GetParams::Reader
getKey	apps/imdb/hashprotocol.capnp.hh	/^inline  ::int32_t HashProtocol::SetParams::Builder::getKey() {$/;"	f	class:HashProtocol::SetParams::Builder
getKey	apps/imdb/hashprotocol.capnp.hh	/^inline  ::int32_t HashProtocol::SetParams::Reader::getKey() const {$/;"	f	class:HashProtocol::SetParams::Reader
getValue	apps/imdb/hashprotocol.capnp.hh	/^inline  ::capnp::Void HashProtocol::SetResults::Builder::getValue() {$/;"	f	class:HashProtocol::SetResults::Builder
getValue	apps/imdb/hashprotocol.capnp.hh	/^inline  ::capnp::Void HashProtocol::SetResults::Reader::getValue() const {$/;"	f	class:HashProtocol::SetResults::Reader
getValue	apps/imdb/hashprotocol.capnp.hh	/^inline  ::int32_t HashProtocol::GetResults::Builder::getValue() {$/;"	f	class:HashProtocol::GetResults::Builder
getValue	apps/imdb/hashprotocol.capnp.hh	/^inline  ::int32_t HashProtocol::GetResults::Reader::getValue() const {$/;"	f	class:HashProtocol::GetResults::Reader
getValue	apps/imdb/hashprotocol.capnp.hh	/^inline  ::int32_t HashProtocol::SetParams::Builder::getValue() {$/;"	f	class:HashProtocol::SetParams::Builder
getValue	apps/imdb/hashprotocol.capnp.hh	/^inline  ::int32_t HashProtocol::SetParams::Reader::getValue() const {$/;"	f	class:HashProtocol::SetParams::Reader
operator =	apps/imdb/hashprotocol.capnp.hh	/^inline  ::HashProtocol::Client& HashProtocol::Client::operator=(Client& other) {$/;"	f	class:HashProtocol::Client
operator =	apps/imdb/hashprotocol.capnp.hh	/^inline  ::HashProtocol::Client& HashProtocol::Client::operator=(Client&& other) {$/;"	f	class:HashProtocol::Client
operator Reader	apps/imdb/hashprotocol.capnp.hh	/^  inline operator Reader() const { return Reader(_builder.asReader()); }$/;"	f	class:HashProtocol::GetParams::Builder
operator Reader	apps/imdb/hashprotocol.capnp.hh	/^  inline operator Reader() const { return Reader(_builder.asReader()); }$/;"	f	class:HashProtocol::GetResults::Builder
operator Reader	apps/imdb/hashprotocol.capnp.hh	/^  inline operator Reader() const { return Reader(_builder.asReader()); }$/;"	f	class:HashProtocol::SetParams::Builder
operator Reader	apps/imdb/hashprotocol.capnp.hh	/^  inline operator Reader() const { return Reader(_builder.asReader()); }$/;"	f	class:HashProtocol::SetResults::Builder
override	apps/imdb/hashprotocol.capnp.hh	/^      override;$/;"	m	class:HashProtocol::Server
schemas	apps/imdb/hashprotocol.capnp.hh	/^namespace schemas {$/;"	n	namespace:capnp
setKey	apps/imdb/hashprotocol.capnp.hh	/^inline void HashProtocol::GetParams::Builder::setKey( ::int32_t value) {$/;"	f	class:HashProtocol::GetParams::Builder
setKey	apps/imdb/hashprotocol.capnp.hh	/^inline void HashProtocol::SetParams::Builder::setKey( ::int32_t value) {$/;"	f	class:HashProtocol::SetParams::Builder
setValue	apps/imdb/hashprotocol.capnp.hh	/^inline void HashProtocol::GetResults::Builder::setValue( ::int32_t value) {$/;"	f	class:HashProtocol::GetResults::Builder
setValue	apps/imdb/hashprotocol.capnp.hh	/^inline void HashProtocol::SetParams::Builder::setValue( ::int32_t value) {$/;"	f	class:HashProtocol::SetParams::Builder
setValue	apps/imdb/hashprotocol.capnp.hh	/^inline void HashProtocol::SetResults::Builder::setValue( ::capnp::Void value) {$/;"	f	class:HashProtocol::SetResults::Builder
toString	apps/imdb/hashprotocol.capnp.hh	/^  inline ::kj::StringTree toString() const { return asReader().toString(); }$/;"	f	class:HashProtocol::GetParams::Builder
toString	apps/imdb/hashprotocol.capnp.hh	/^  inline ::kj::StringTree toString() const { return asReader().toString(); }$/;"	f	class:HashProtocol::GetResults::Builder
toString	apps/imdb/hashprotocol.capnp.hh	/^  inline ::kj::StringTree toString() const { return asReader().toString(); }$/;"	f	class:HashProtocol::SetParams::Builder
toString	apps/imdb/hashprotocol.capnp.hh	/^  inline ::kj::StringTree toString() const { return asReader().toString(); }$/;"	f	class:HashProtocol::SetResults::Builder
toString	apps/imdb/hashprotocol.capnp.hh	/^  inline ::kj::StringTree toString() const {$/;"	f	class:HashProtocol::GetParams::Reader
toString	apps/imdb/hashprotocol.capnp.hh	/^  inline ::kj::StringTree toString() const {$/;"	f	class:HashProtocol::GetResults::Reader
toString	apps/imdb/hashprotocol.capnp.hh	/^  inline ::kj::StringTree toString() const {$/;"	f	class:HashProtocol::SetParams::Reader
toString	apps/imdb/hashprotocol.capnp.hh	/^  inline ::kj::StringTree toString() const {$/;"	f	class:HashProtocol::SetResults::Reader
totalSize	apps/imdb/hashprotocol.capnp.hh	/^  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }$/;"	f	class:HashProtocol::GetParams::Builder
totalSize	apps/imdb/hashprotocol.capnp.hh	/^  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }$/;"	f	class:HashProtocol::GetResults::Builder
totalSize	apps/imdb/hashprotocol.capnp.hh	/^  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }$/;"	f	class:HashProtocol::SetParams::Builder
totalSize	apps/imdb/hashprotocol.capnp.hh	/^  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }$/;"	f	class:HashProtocol::SetResults::Builder
totalSize	apps/imdb/hashprotocol.capnp.hh	/^  inline ::capnp::MessageSize totalSize() const {$/;"	f	class:HashProtocol::GetParams::Reader
totalSize	apps/imdb/hashprotocol.capnp.hh	/^  inline ::capnp::MessageSize totalSize() const {$/;"	f	class:HashProtocol::GetResults::Reader
totalSize	apps/imdb/hashprotocol.capnp.hh	/^  inline ::capnp::MessageSize totalSize() const {$/;"	f	class:HashProtocol::SetParams::Reader
totalSize	apps/imdb/hashprotocol.capnp.hh	/^  inline ::capnp::MessageSize totalSize() const {$/;"	f	class:HashProtocol::SetResults::Reader
DestructorDetector	apps/imdb/imdb-async-test.cc	/^  DestructorDetector(bool& setTrue): setTrue(setTrue) {}$/;"	f	class:DestructorDetector
DestructorDetector	apps/imdb/imdb-async-test.cc	/^class DestructorDetector {$/;"	c	file:
DummyEventPort	apps/imdb/imdb-async-test.cc	/^class DummyEventPort: public EventPort {$/;"	c	file:
EXPECT_ANY_THROW	apps/imdb/imdb-async-test.cc	350;"	d	file:
EXPECT_ANY_THROW	apps/imdb/imdb-async-test.cc	351;"	d	file:
ErrorHandlerImpl	apps/imdb/imdb-async-test.cc	/^class ErrorHandlerImpl: public TaskSet::ErrorHandler {$/;"	c	file:
RefcountedInt	apps/imdb/imdb-async-test.cc	/^  RefcountedInt(int i): i(i) {}$/;"	f	struct:RefcountedInt
RefcountedInt	apps/imdb/imdb-async-test.cc	/^struct RefcountedInt: public Refcounted {$/;"	s	file:
TEST	apps/imdb/imdb-async-test.cc	/^TEST(Async, ArrayJoin) {$/;"	f
TEST	apps/imdb/imdb-async-test.cc	/^TEST(Async, ArrayJoinVoid) {$/;"	f
TEST	apps/imdb/imdb-async-test.cc	/^TEST(Async, Attach) {$/;"	f
TEST	apps/imdb/imdb-async-test.cc	/^TEST(Async, Chain) {$/;"	f
TEST	apps/imdb/imdb-async-test.cc	/^TEST(Async, DeepChain) {$/;"	f
TEST	apps/imdb/imdb-async-test.cc	/^TEST(Async, DeepChain2) {$/;"	f
TEST	apps/imdb/imdb-async-test.cc	/^TEST(Async, DeepChain3) {$/;"	f
TEST	apps/imdb/imdb-async-test.cc	/^TEST(Async, DeepChain4) {$/;"	f
TEST	apps/imdb/imdb-async-test.cc	/^TEST(Async, Detach) {$/;"	f
TEST	apps/imdb/imdb-async-test.cc	/^TEST(Async, EagerlyEvaluate) {$/;"	f
TEST	apps/imdb/imdb-async-test.cc	/^TEST(Async, EvalInt) {$/;"	f
TEST	apps/imdb/imdb-async-test.cc	/^TEST(Async, EvalVoid) {$/;"	f
TEST	apps/imdb/imdb-async-test.cc	/^TEST(Async, Exception) {$/;"	f
TEST	apps/imdb/imdb-async-test.cc	/^TEST(Async, ExclusiveJoin) {$/;"	f
TEST	apps/imdb/imdb-async-test.cc	/^TEST(Async, Fork) {$/;"	f
TEST	apps/imdb/imdb-async-test.cc	/^TEST(Async, ForkRef) {$/;"	f
TEST	apps/imdb/imdb-async-test.cc	/^TEST(Async, HandleException) {$/;"	f
TEST	apps/imdb/imdb-async-test.cc	/^TEST(Async, Ordering) {$/;"	f
TEST	apps/imdb/imdb-async-test.cc	/^TEST(Async, PropagateException) {$/;"	f
TEST	apps/imdb/imdb-async-test.cc	/^TEST(Async, PropagateExceptionTypeChange) {$/;"	f
TEST	apps/imdb/imdb-async-test.cc	/^TEST(Async, SeparateFulfiller) {$/;"	f
TEST	apps/imdb/imdb-async-test.cc	/^TEST(Async, SeparateFulfillerCanceled) {$/;"	f
TEST	apps/imdb/imdb-async-test.cc	/^TEST(Async, SeparateFulfillerChained) {$/;"	f
TEST	apps/imdb/imdb-async-test.cc	/^TEST(Async, SeparateFulfillerDiscarded) {$/;"	f
TEST	apps/imdb/imdb-async-test.cc	/^TEST(Async, SeparateFulfillerMemoryLeak) {$/;"	f
TEST	apps/imdb/imdb-async-test.cc	/^TEST(Async, SeparateFulfillerVoid) {$/;"	f
TEST	apps/imdb/imdb-async-test.cc	/^TEST(Async, SetRunnable) {$/;"	f
TEST	apps/imdb/imdb-async-test.cc	/^TEST(Async, TaskSet) {$/;"	f
TEST	apps/imdb/imdb-async-test.cc	/^TEST(Async, Then) {$/;"	f
TEST	apps/imdb/imdb-async-test.cc	/^TEST(Async, There) {$/;"	f
TEST	apps/imdb/imdb-async-test.cc	/^TEST(Async, ThereVoid) {$/;"	f
addRef	apps/imdb/imdb-async-test.cc	/^  Own<RefcountedInt> addRef() { return kj::addRef(*this); }$/;"	f	struct:RefcountedInt
callCount	apps/imdb/imdb-async-test.cc	/^  int callCount = 0;$/;"	m	class:DummyEventPort	file:
exceptionCount	apps/imdb/imdb-async-test.cc	/^  uint exceptionCount = 0;$/;"	m	class:ErrorHandlerImpl	file:
i	apps/imdb/imdb-async-test.cc	/^  int i;$/;"	m	struct:RefcountedInt	file:
makeChain	apps/imdb/imdb-async-test.cc	/^Promise<void> makeChain(uint i) {$/;"	f
makeChain2	apps/imdb/imdb-async-test.cc	/^Promise<void> makeChain2(uint i, Promise<void> promise) {$/;"	f
runnable	apps/imdb/imdb-async-test.cc	/^  bool runnable = false;$/;"	m	class:DummyEventPort	file:
setTrue	apps/imdb/imdb-async-test.cc	/^  bool& setTrue;$/;"	m	class:DestructorDetector	file:
~DestructorDetector	apps/imdb/imdb-async-test.cc	/^  ~DestructorDetector() { setTrue = true; }$/;"	f	class:DestructorDetector
main	apps/imdb/imdb_client.cc	/^int main(int argc, const char* argv[]){$/;"	f
final	apps/imdb/imdb_server.cc	/^class AdderImpl final: public Adder::Server {$/;"	c	file:
main	apps/imdb/imdb_server.cc	/^int main(int argc, const char* argv[]) {$/;"	f
consume	apps/imdb/kj_iostream-impl.hh	/^kj_input_stream<CharType>::consume(Consumer& consumer) {$/;"	f	class:kj_input_stream
flush	apps/imdb/kj_iostream-impl.hh	/^kj_output_stream<CharType>::flush() {$/;"	f	class:kj_output_stream
read_exactly	apps/imdb/kj_iostream-impl.hh	/^kj_input_stream<CharType>::read_exactly(size_t n) {$/;"	f	class:kj_input_stream
read_exactly_part	apps/imdb/kj_iostream-impl.hh	/^kj_input_stream<CharType>::read_exactly_part(size_t n, tmp_buf out, size_t completed) {$/;"	f	class:kj_input_stream
split_and_put	apps/imdb/kj_iostream-impl.hh	/^kj_output_stream<CharType>::split_and_put(temporary_buffer<CharType> buf) {$/;"	f	class:kj_output_stream
write	apps/imdb/kj_iostream-impl.hh	/^future<> kj_output_stream<CharType>::write(const char_type* buf) {$/;"	f	class:kj_output_stream
write	apps/imdb/kj_iostream-impl.hh	/^future<> kj_output_stream<CharType>::write(const sstring& s) {$/;"	f	class:kj_output_stream
write	apps/imdb/kj_iostream-impl.hh	/^future<> kj_output_stream<CharType>::write(net::packet p) {$/;"	f	class:kj_output_stream
write	apps/imdb/kj_iostream-impl.hh	/^future<> kj_output_stream<CharType>::write(scattered_message<CharType> msg) {$/;"	f	class:kj_output_stream
write	apps/imdb/kj_iostream-impl.hh	/^kj_output_stream<CharType>::write(const char_type* buf, size_t n) {$/;"	f	class:kj_output_stream
ConsumerConcept	apps/imdb/kj_iostream.hh	/^    struct ConsumerConcept {$/;"	s	class:final
_begin	apps/imdb/kj_iostream.hh	/^    size_t _begin = 0;$/;"	m	class:final
_buf	apps/imdb/kj_iostream.hh	/^    temporary_buffer<CharType> _buf;$/;"	m	class:final
_dsi	apps/imdb/kj_iostream.hh	/^    std::unique_ptr<kj_data_sink_impl> _dsi;$/;"	m	class:kj_data_sink
_dsi	apps/imdb/kj_iostream.hh	/^    std::unique_ptr<kj_data_source_impl> _dsi;$/;"	m	class:kj_data_source
_end	apps/imdb/kj_iostream.hh	/^    size_t _end = 0;$/;"	m	class:final
_eof	apps/imdb/kj_iostream.hh	/^    bool _eof = false;$/;"	m	class:final
_fd	apps/imdb/kj_iostream.hh	/^    kj_data_sink _fd;$/;"	m	class:final
_fd	apps/imdb/kj_iostream.hh	/^    kj_data_source _fd;$/;"	m	class:final
_size	apps/imdb/kj_iostream.hh	/^    size_t _size = 0;$/;"	m	class:final
_trim_to_size	apps/imdb/kj_iostream.hh	/^    bool _trim_to_size = false;$/;"	m	class:final
allocate_buffer	apps/imdb/kj_iostream.hh	/^    temporary_buffer<char> allocate_buffer(size_t size) {$/;"	f	class:kj_data_sink
allocate_buffer	apps/imdb/kj_iostream.hh	/^    virtual temporary_buffer<char> allocate_buffer(size_t size) {$/;"	f	class:kj_data_sink_impl
available	apps/imdb/kj_iostream.hh	/^    size_t available() const { return _buf.size(); }$/;"	f	class:final
available	apps/imdb/kj_iostream.hh	/^    size_t available() const { return _end - _begin; }$/;"	f	class:final
close	apps/imdb/kj_iostream.hh	/^    future<> close() { return _dsi->close(); }$/;"	f	class:kj_data_sink
close	apps/imdb/kj_iostream.hh	/^    future<> close() { return _fd.close(); }$/;"	f	class:final
eof	apps/imdb/kj_iostream.hh	/^    bool eof() { return _eof; }$/;"	f	class:final
fd	apps/imdb/kj_iostream.hh	/^    kj_data_source* fd() { return &_fd; }$/;"	f	class:final
final	apps/imdb/kj_iostream.hh	/^class kj_input_stream final {$/;"	c
final	apps/imdb/kj_iostream.hh	/^class kj_output_stream final {$/;"	c
get	apps/imdb/kj_iostream.hh	/^    future<temporary_buffer<char>> get() { return _dsi->get(); }$/;"	f	class:kj_data_source
impl	apps/imdb/kj_iostream.hh	/^    kj_data_source_impl* impl() const { return _dsi.get(); }$/;"	f	class:kj_data_source
kj_data_sink	apps/imdb/kj_iostream.hh	/^    explicit kj_data_sink(std::unique_ptr<kj_data_sink_impl> dsi) : _dsi(std::move(dsi)) {}$/;"	f	class:kj_data_sink
kj_data_sink	apps/imdb/kj_iostream.hh	/^class kj_data_sink {$/;"	c
kj_data_sink_impl	apps/imdb/kj_iostream.hh	/^class kj_data_sink_impl {$/;"	c
kj_data_source	apps/imdb/kj_iostream.hh	/^    explicit kj_data_source(std::unique_ptr<kj_data_source_impl> dsi) : _dsi(std::move(dsi)) {}$/;"	f	class:kj_data_source
kj_data_source	apps/imdb/kj_iostream.hh	/^class kj_data_source {$/;"	c
kj_data_source_impl	apps/imdb/kj_iostream.hh	/^class kj_data_source_impl {$/;"	c
kj_input_stream	apps/imdb/kj_iostream.hh	/^    explicit kj_input_stream(data_source fd) : _fd(std::move(fd)), _buf(0) {}$/;"	f	class:final
kj_output_stream	apps/imdb/kj_iostream.hh	/^    kj_output_stream(kj_data_sink fd, size_t size, bool trim_to_size = false)$/;"	f	class:final
net	apps/imdb/kj_iostream.hh	/^namespace net { class packet; }$/;"	n
possibly_available	apps/imdb/kj_iostream.hh	/^    size_t possibly_available() const { return _size - _begin; }$/;"	f	class:final
put	apps/imdb/kj_iostream.hh	/^    future<> put(net::packet p) {$/;"	f	class:kj_data_sink
put	apps/imdb/kj_iostream.hh	/^    future<> put(std::vector<temporary_buffer<char>> data) {$/;"	f	class:kj_data_sink
put	apps/imdb/kj_iostream.hh	/^    future<> put(temporary_buffer<char> data) {$/;"	f	class:kj_data_sink
put	apps/imdb/kj_iostream.hh	/^    virtual future<> put(std::vector<temporary_buffer<char>> data) {$/;"	f	class:kj_data_sink_impl
put	apps/imdb/kj_iostream.hh	/^    virtual future<> put(temporary_buffer<char> buf) {$/;"	f	class:kj_data_sink_impl
reset	apps/imdb/kj_iostream.hh	/^    void reset() { _buf = {}; }$/;"	f	class:final
x	apps/imdb/kj_iostream.hh	/^    kj_data_sink& operator=(kj_data_sink&& x) = default;$/;"	m	class:kj_data_sink
x	apps/imdb/kj_iostream.hh	/^    kj_data_sink(kj_data_sink&& x) = default;$/;"	m	class:kj_data_sink
x	apps/imdb/kj_iostream.hh	/^    kj_data_source& operator=(kj_data_source&& x) = default;$/;"	m	class:kj_data_source
x	apps/imdb/kj_iostream.hh	/^    kj_data_source(kj_data_source&& x) = default;$/;"	m	class:kj_data_source
~kj_data_sink_impl	apps/imdb/kj_iostream.hh	/^    virtual ~kj_data_sink_impl() {}$/;"	f	class:kj_data_sink_impl
~kj_data_source_impl	apps/imdb/kj_iostream.hh	/^    virtual ~kj_data_source_impl() {}$/;"	f	class:kj_data_source_impl
acceptLoop	apps/imdb/main.cc	/^    void acceptLoop(ipv4_addr addr){        $/;"	f	class:tcp_server
done	apps/imdb/main.cc	/^    bool done;$/;"	m	class:tcp_server	file:
final	apps/imdb/main.cc	/^class AdderImpl final: public Adder::Server {$/;"	c	file:
final	apps/imdb/main.cc	/^class HashProtocolImpl final: public HashProtocol::Server {$/;"	c	file:
main	apps/imdb/main.cc	/^int main(int ac, char** av)$/;"	f
mymap	apps/imdb/main.cc	/^    std::map<int, int> mymap;$/;"	m	class:final	file:
server	apps/imdb/main.cc	/^    capnp::SeastarServer server;$/;"	m	class:tcp_server	file:
serverImpl	apps/imdb/main.cc	/^    capnp::Capability::Client serverImpl;$/;"	m	class:tcp_server	file:
taskFailed	apps/imdb/main.cc	/^    void taskFailed(kj::Exception&& exception) {$/;"	f	class:tcp_server
tasks	apps/imdb/main.cc	/^    kj::TaskSet tasks;$/;"	m	class:tcp_server	file:
tcp_server	apps/imdb/main.cc	/^    tcp_server(): waitScope(engine()), done(false), serverImpl(kj::heap<HashProtocolImpl>()), server(serverImpl), tasks(*this) {       $/;"	f	class:tcp_server
tcp_server	apps/imdb/main.cc	/^class tcp_server : private kj::TaskSet::ErrorHandler {$/;"	c	file:
waitScope	apps/imdb/main.cc	/^    kj::WaitScope waitScope;    $/;"	m	class:tcp_server	file:
~tcp_server	apps/imdb/main.cc	/^    ~tcp_server(){$/;"	f	class:tcp_server
AcceptedConnection	apps/imdb/vmts-rpc.cc	/^  explicit AcceptedConnection(kj::Maybe<Capability::Client> bootstrapInterface,$/;"	f	struct:capnp::SeastarServer::AcceptedConnection
AcceptedConnection	apps/imdb/vmts-rpc.cc	/^struct SeastarServer::AcceptedConnection {$/;"	s	class:capnp::SeastarServer	file:
IncomingMessageImpl	apps/imdb/vmts-rpc.cc	/^  IncomingMessageImpl(kj::Own<SeastarAsyncMessageReader> message): message(kj::mv(message)) {    $/;"	f	class:capnp::final
OutgoingMessageImpl	apps/imdb/vmts-rpc.cc	/^  OutgoingMessageImpl(SeastarNetwork& network, uint firstSegmentWordSize)$/;"	f	class:capnp::final
SeastarAsyncMessageReader	apps/imdb/vmts-rpc.cc	/^  inline SeastarAsyncMessageReader(kj::UvIoStream& _inputStream, ReaderOptions options): MessageReader(options), inputStream(_inputStream), totalWords(0), ownership(true) {$/;"	f	class:capnp::SeastarAsyncMessageReader
SeastarAsyncMessageReader	apps/imdb/vmts-rpc.cc	/^class SeastarAsyncMessageReader: public MessageReader {$/;"	c	namespace:capnp	file:
SeastarNetwork	apps/imdb/vmts-rpc.cc	/^SeastarNetwork::SeastarNetwork(kj::UvIoStream& stream, rpc::twoparty::Side side,$/;"	f	class:capnp::SeastarNetwork
SeastarServer	apps/imdb/vmts-rpc.cc	/^SeastarServer::SeastarServer(kj::Maybe<Capability::Client> bootstrapInterface)$/;"	f	class:capnp::SeastarServer
_tryReadMessage	apps/imdb/vmts-rpc.cc	/^kj::Promise<kj::Maybe<kj::Own<SeastarAsyncMessageReader>>> _tryReadMessage($/;"	f	namespace:capnp
accept	apps/imdb/vmts-rpc.cc	/^kj::Promise<kj::Own<TwoPartyVatNetworkBase::Connection>> SeastarNetwork::accept() {$/;"	f	class:capnp::SeastarNetwork
asConnection	apps/imdb/vmts-rpc.cc	/^kj::Own<TwoPartyVatNetworkBase::Connection> SeastarNetwork::asConnection() {$/;"	f	class:capnp::SeastarNetwork
capnp	apps/imdb/vmts-rpc.cc	/^namespace capnp {$/;"	n	file:
connect	apps/imdb/vmts-rpc.cc	/^kj::Maybe<kj::Own<TwoPartyVatNetworkBase::Connection>> SeastarNetwork::connect($/;"	f	class:capnp::SeastarNetwork
connection	apps/imdb/vmts-rpc.cc	/^  kj::Own<kj::UvIoStream> connection;$/;"	m	struct:capnp::SeastarServer::AcceptedConnection	file:
disposeImpl	apps/imdb/vmts-rpc.cc	/^void SeastarNetwork::FulfillerDisposer::disposeImpl(void* pointer) const {$/;"	f	class:capnp::SeastarNetwork::FulfillerDisposer
final	apps/imdb/vmts-rpc.cc	/^class SeastarNetwork::IncomingMessageImpl final: public IncomingRpcMessage {$/;"	c	namespace:capnp	file:
final	apps/imdb/vmts-rpc.cc	/^class SeastarNetwork::OutgoingMessageImpl final$/;"	c	namespace:capnp	file:
firstWord	apps/imdb/vmts-rpc.cc	/^  _::WireValue<uint32_t> firstWord[2];$/;"	m	class:capnp::SeastarAsyncMessageReader	file:
getPeerVatId	apps/imdb/vmts-rpc.cc	/^rpc::twoparty::VatId::Reader SeastarNetwork::getPeerVatId() {$/;"	f	class:capnp::SeastarNetwork
inputStream	apps/imdb/vmts-rpc.cc	/^  kj::UvIoStream& inputStream;$/;"	m	class:capnp::SeastarAsyncMessageReader	file:
listen	apps/imdb/vmts-rpc.cc	/^kj::Promise<void> SeastarServer::listen(ipv4_addr addr) {$/;"	f	class:capnp::SeastarServer
message	apps/imdb/vmts-rpc.cc	/^  MallocMessageBuilder message;$/;"	m	class:capnp::final	file:
message	apps/imdb/vmts-rpc.cc	/^  kj::Own<SeastarAsyncMessageReader> message;$/;"	m	class:capnp::final	file:
moreSizes	apps/imdb/vmts-rpc.cc	/^  kj::Array<_::WireValue<uint32_t>> moreSizes;$/;"	m	class:capnp::SeastarAsyncMessageReader	file:
network	apps/imdb/vmts-rpc.cc	/^  SeastarNetwork network;$/;"	m	struct:capnp::SeastarServer::AcceptedConnection	file:
network	apps/imdb/vmts-rpc.cc	/^  SeastarNetwork& network;$/;"	m	class:capnp::final	file:
newOutgoingMessage	apps/imdb/vmts-rpc.cc	/^kj::Own<OutgoingRpcMessage> SeastarNetwork::newOutgoingMessage(uint firstSegmentWordSize) {$/;"	f	class:capnp::SeastarNetwork
noexcept	apps/imdb/vmts-rpc.cc	/^  ~SeastarAsyncMessageReader() noexcept(false) {$/;"	f	class:capnp::SeastarAsyncMessageReader
ownedSpace	apps/imdb/vmts-rpc.cc	/^  kj::Array<word> ownedSpace;$/;"	m	class:capnp::SeastarAsyncMessageReader	file:
ownership	apps/imdb/vmts-rpc.cc	/^  bool ownership = false;$/;"	m	class:capnp::SeastarAsyncMessageReader	file:
read	apps/imdb/vmts-rpc.cc	/^kj::Promise<bool> SeastarAsyncMessageReader::read() {  $/;"	f	class:capnp::SeastarAsyncMessageReader
readAfterFirstWord	apps/imdb/vmts-rpc.cc	/^kj::Promise<void> SeastarAsyncMessageReader::readAfterFirstWord() {$/;"	f	class:capnp::SeastarAsyncMessageReader
readSegments	apps/imdb/vmts-rpc.cc	/^kj::Promise<void> SeastarAsyncMessageReader::readSegments() {$/;"	f	class:capnp::SeastarAsyncMessageReader
receiveIncomingMessage	apps/imdb/vmts-rpc.cc	/^kj::Promise<kj::Maybe<kj::Own<IncomingRpcMessage>>> SeastarNetwork::receiveIncomingMessage() {$/;"	f	class:capnp::SeastarNetwork
rpcSystem	apps/imdb/vmts-rpc.cc	/^  RpcSystem<rpc::twoparty::VatId> rpcSystem;$/;"	m	struct:capnp::SeastarServer::AcceptedConnection	file:
segment0Size	apps/imdb/vmts-rpc.cc	/^  inline uint segment0Size() { return firstWord[1].get(); }$/;"	f	class:capnp::SeastarAsyncMessageReader	file:
segmentCount	apps/imdb/vmts-rpc.cc	/^  inline uint segmentCount() { return firstWord[0].get() + 1; }$/;"	f	class:capnp::SeastarAsyncMessageReader	file:
segmentStarts	apps/imdb/vmts-rpc.cc	/^  kj::Array<const word*> segmentStarts;$/;"	m	class:capnp::SeastarAsyncMessageReader	file:
shutdown	apps/imdb/vmts-rpc.cc	/^kj::Promise<void> SeastarNetwork::shutdown() {$/;"	f	class:capnp::SeastarNetwork
size	apps/imdb/vmts-rpc.cc	/^  size_t size(){$/;"	f	class:capnp::SeastarAsyncMessageReader
taskFailed	apps/imdb/vmts-rpc.cc	/^void SeastarServer::taskFailed(kj::Exception&& exception) {$/;"	f	class:capnp::SeastarServer
totalWords	apps/imdb/vmts-rpc.cc	/^  size_t totalWords;$/;"	m	class:capnp::SeastarAsyncMessageReader	file:
ArrDisposer	apps/imdb/vmts-rpc.hh	/^    ArrDisposer() : parent(nullptr) {};$/;"	f	class:kj::ZeroCopyScratchspace::ArrDisposer
ArrDisposer	apps/imdb/vmts-rpc.hh	/^    ArrDisposer(ZeroCopyScratchspace* parent) : parent(parent) {};$/;"	f	class:kj::ZeroCopyScratchspace::ArrDisposer
ArrDisposer	apps/imdb/vmts-rpc.hh	/^  class ArrDisposer : public kj::ArrayDisposer {$/;"	c	struct:kj::ZeroCopyScratchspace
CAPNP_Vmts_RPC_H_	apps/imdb/vmts-rpc.hh	25;"	d
DEFAUlT_RELOCATE_THREADSHOLD	apps/imdb/vmts-rpc.hh	92;"	d
DEFAUlT_SCRATCH_SPACE_SIZE	apps/imdb/vmts-rpc.hh	91;"	d
FulfillerDisposer	apps/imdb/vmts-rpc.hh	/^  class FulfillerDisposer: public kj::Disposer {$/;"	c	class:capnp::final
SeastarServer	apps/imdb/vmts-rpc.hh	/^class SeastarServer: private kj::TaskSet::ErrorHandler {$/;"	c	namespace:capnp
UvIoStream	apps/imdb/vmts-rpc.hh	/^  UvIoStream(kj::connection&& _conn, size_t buffer_size = DEFAUlT_SCRATCH_SPACE_SIZE ): conn(kj::mv(_conn) ),buffer( kj::heap<ZeroCopyScratchspace>(buffer_size) ) {    $/;"	f	struct:kj::UvIoStream
UvIoStream	apps/imdb/vmts-rpc.hh	/^struct UvIoStream: public kj::AsyncIoStream {$/;"	s	namespace:kj
ZeroCopyScratchspace	apps/imdb/vmts-rpc.hh	/^  ZeroCopyScratchspace(size_t sz = DEFAUlT_SCRATCH_SPACE_SIZE) : scratchSpace(kj::heapArray<char>(sz)), readCounter(0), writerCounter(0), freed(0), disposer(this) { };$/;"	f	struct:kj::ZeroCopyScratchspace
ZeroCopyScratchspace	apps/imdb/vmts-rpc.hh	/^struct ZeroCopyScratchspace {$/;"	s	namespace:kj
_fd	apps/imdb/vmts-rpc.hh	/^  connected_socket _fd;$/;"	m	struct:kj::connection
_read_buf	apps/imdb/vmts-rpc.hh	/^  input_stream<char> _read_buf;$/;"	m	struct:kj::connection
_write_buf	apps/imdb/vmts-rpc.hh	/^  output_stream<char> _write_buf;$/;"	m	struct:kj::connection
acceptFulfiller	apps/imdb/vmts-rpc.hh	/^  kj::Own<kj::PromiseFulfiller<kj::Own<TwoPartyVatNetworkBase::Connection>>> acceptFulfiller;$/;"	m	class:capnp::final
accepted	apps/imdb/vmts-rpc.hh	/^  bool accepted = false;$/;"	m	class:capnp::final
available	apps/imdb/vmts-rpc.hh	/^  inline size_t available() {$/;"	f	struct:kj::ZeroCopyScratchspace
bootstrapInterface	apps/imdb/vmts-rpc.hh	/^  kj::Maybe<Capability::Client> bootstrapInterface;$/;"	m	class:capnp::SeastarServer
buffer	apps/imdb/vmts-rpc.hh	/^  kj::Own<ZeroCopyScratchspace> buffer;$/;"	m	struct:kj::UvIoStream
byte	apps/imdb/vmts-rpc.hh	/^typedef unsigned char byte;$/;"	t	namespace:kj
capnp	apps/imdb/vmts-rpc.hh	/^namespace capnp {$/;"	n
conn	apps/imdb/vmts-rpc.hh	/^  kj::connection conn;$/;"	m	struct:kj::UvIoStream
connection	apps/imdb/vmts-rpc.hh	/^  connection(connected_socket&& fd, socket_address addr)$/;"	f	struct:kj::connection
connection	apps/imdb/vmts-rpc.hh	/^struct connection {$/;"	s	namespace:kj
consumable	apps/imdb/vmts-rpc.hh	/^  inline size_t consumable() {$/;"	f	struct:kj::ZeroCopyScratchspace
consumed	apps/imdb/vmts-rpc.hh	/^  inline void consumed(size_t cnt) {$/;"	f	struct:kj::ZeroCopyScratchspace
consuming	apps/imdb/vmts-rpc.hh	/^  inline kj::Array<char> consuming(size_t cnt) {$/;"	f	struct:kj::ZeroCopyScratchspace
copy	apps/imdb/vmts-rpc.hh	/^  inline void copy(void* buffer, size_t len) {$/;"	f	struct:kj::ZeroCopyScratchspace
createNewSegment	apps/imdb/vmts-rpc.hh	/^  void createNewSegment(size_t size) {$/;"	f	struct:kj::UvIoStream
disconnectFulfiller	apps/imdb/vmts-rpc.hh	/^  FulfillerDisposer disconnectFulfiller;$/;"	m	class:capnp::final
disconnectPromise	apps/imdb/vmts-rpc.hh	/^  kj::ForkedPromise<void> disconnectPromise = nullptr;$/;"	m	class:capnp::final
disposeImpl	apps/imdb/vmts-rpc.hh	/^    virtual void disposeImpl(void* firstElement, size_t elementSize, size_t elementCount,$/;"	f	class:kj::ZeroCopyScratchspace::ArrDisposer
disposer	apps/imdb/vmts-rpc.hh	/^  kj::Maybe<ArrDisposer> disposer;$/;"	m	struct:kj::ZeroCopyScratchspace
final	apps/imdb/vmts-rpc.hh	/^class SeastarNetwork final : public TwoPartyVatNetworkBase,$/;"	c	namespace:capnp
freed	apps/imdb/vmts-rpc.hh	/^  size_t freed;$/;"	m	struct:kj::ZeroCopyScratchspace
fulfiller	apps/imdb/vmts-rpc.hh	/^    mutable kj::Own<kj::PromiseFulfiller<void>> fulfiller;$/;"	m	class:capnp::final::FulfillerDisposer
kj	apps/imdb/vmts-rpc.hh	/^namespace kj {$/;"	n
maxReadable	apps/imdb/vmts-rpc.hh	/^  inline size_t maxReadable() {$/;"	f	struct:kj::ZeroCopyScratchspace
noexcept	apps/imdb/vmts-rpc.hh	/^  ~UvIoStream() noexcept(false) {$/;"	f	struct:kj::UvIoStream
onDisconnect	apps/imdb/vmts-rpc.hh	/^  kj::Promise<void> onDisconnect() { return disconnectPromise.addBranch(); }$/;"	f	class:capnp::final
operator []	apps/imdb/vmts-rpc.hh	/^  inline char operator[](size_t i){$/;"	f	struct:kj::ZeroCopyScratchspace
override	apps/imdb/vmts-rpc.hh	/^        rpc::twoparty::VatId::Reader ref) override;$/;"	m	class:capnp::final
override	apps/imdb/vmts-rpc.hh	/^    void disposeImpl(void* pointer) const override;$/;"	m	class:capnp::final::FulfillerDisposer
override	apps/imdb/vmts-rpc.hh	/^  kj::Own<OutgoingRpcMessage> newOutgoingMessage(uint firstSegmentWordSize) override;$/;"	m	class:capnp::final
override	apps/imdb/vmts-rpc.hh	/^  kj::Promise<kj::Maybe<kj::Own<IncomingRpcMessage>>> receiveIncomingMessage() override;$/;"	m	class:capnp::final
override	apps/imdb/vmts-rpc.hh	/^  kj::Promise<kj::Own<TwoPartyVatNetworkBase::Connection>> accept() override;$/;"	m	class:capnp::final
override	apps/imdb/vmts-rpc.hh	/^  kj::Promise<void> shutdown() override;$/;"	m	class:capnp::final
override	apps/imdb/vmts-rpc.hh	/^  rpc::twoparty::VatId::Reader getPeerVatId() override;$/;"	m	class:capnp::final
override	apps/imdb/vmts-rpc.hh	/^  void taskFailed(kj::Exception&& exception) override;$/;"	m	class:capnp::SeastarServer
parent	apps/imdb/vmts-rpc.hh	/^    kj::Maybe<ZeroCopyScratchspace&> parent;$/;"	m	class:kj::ZeroCopyScratchspace::ArrDisposer
peerVatId	apps/imdb/vmts-rpc.hh	/^  MallocMessageBuilder peerVatId;$/;"	m	class:capnp::final
pools	apps/imdb/vmts-rpc.hh	/^  std::vector< kj::Own<ZeroCopyScratchspace> > pools;$/;"	m	struct:kj::UvIoStream
previousWrite	apps/imdb/vmts-rpc.hh	/^  kj::Maybe<kj::Promise<void>> previousWrite;$/;"	m	class:capnp::final
read	apps/imdb/vmts-rpc.hh	/^  Promise<void> read(void* buffer, size_t bytes) {  $/;"	f	struct:kj::UvIoStream
read	apps/imdb/vmts-rpc.hh	/^  inline void read(size_t cnt) {$/;"	f	struct:kj::ZeroCopyScratchspace
read	apps/imdb/vmts-rpc.hh	/^  kj::Promise<size_t> read(size_t minBytes) {$/;"	f	struct:kj::UvIoStream
readCounter	apps/imdb/vmts-rpc.hh	/^  size_t readCounter;$/;"	m	struct:kj::ZeroCopyScratchspace
receiveOptions	apps/imdb/vmts-rpc.hh	/^  ReaderOptions receiveOptions;$/;"	m	class:capnp::final
refcount	apps/imdb/vmts-rpc.hh	/^    mutable uint refcount = 0;$/;"	m	class:capnp::final::FulfillerDisposer
release	apps/imdb/vmts-rpc.hh	/^  inline void release(size_t amount) {$/;"	f	struct:kj::ZeroCopyScratchspace
reserve	apps/imdb/vmts-rpc.hh	/^  inline void reserve(size_t sz) {$/;"	f	struct:kj::ZeroCopyScratchspace
reset	apps/imdb/vmts-rpc.hh	/^  inline void reset() {$/;"	f	struct:kj::ZeroCopyScratchspace
scratchSpace	apps/imdb/vmts-rpc.hh	/^  kj::ArrayPtr<char> scratchSpace;$/;"	m	struct:kj::ZeroCopyScratchspace
server	apps/imdb/vmts-rpc.hh	/^  kj::Own<server_socket> server;$/;"	m	class:capnp::SeastarServer
shrink_to_fit	apps/imdb/vmts-rpc.hh	/^  inline shrink_to_fit(size_t sz = DEFAUlT_SCRATCH_SPACE_SIZE) {$/;"	f	struct:kj::ZeroCopyScratchspace
side	apps/imdb/vmts-rpc.hh	/^  rpc::twoparty::Side side;$/;"	m	class:capnp::final
size	apps/imdb/vmts-rpc.hh	/^  inline size_t size() {$/;"	f	struct:kj::ZeroCopyScratchspace
startRead	apps/imdb/vmts-rpc.hh	/^  inline char* startRead() {$/;"	f	struct:kj::ZeroCopyScratchspace
stream	apps/imdb/vmts-rpc.hh	/^  kj::UvIoStream& stream;$/;"	m	class:capnp::final
tasks	apps/imdb/vmts-rpc.hh	/^  kj::TaskSet tasks;$/;"	m	class:capnp::SeastarServer
toString	apps/imdb/vmts-rpc.hh	/^  kj::String toString() {$/;"	f	struct:kj::UvIoStream
uint	apps/imdb/vmts-rpc.hh	/^typedef unsigned int uint;$/;"	t	namespace:kj
writerCounter	apps/imdb/vmts-rpc.hh	/^  size_t writerCounter;$/;"	m	struct:kj::ZeroCopyScratchspace
PLATFORM	apps/memcached/memcache.cc	47;"	d	file:
VERSION	apps/memcached/memcache.cc	48;"	d	file:
VERSION_STRING	apps/memcached/memcache.cc	49;"	d	file:
_addr	apps/memcached/memcache.cc	/^        socket_address _addr;$/;"	m	struct:memcache::tcp_server::connection	file:
_alive	apps/memcached/memcache.cc	/^    seastar::timer_set<item, &item::_timer_link> _alive;$/;"	m	class:memcache::cache	file:
_ascii_prefix_size	apps/memcached/memcache.cc	/^    uint8_t _ascii_prefix_size;$/;"	m	class:memcache::item	file:
_buckets	apps/memcached/memcache.cc	/^    cache_type::bucket_type* _buckets;$/;"	m	class:memcache::cache	file:
_cache	apps/memcached/memcache.cc	/^    cache_type _cache;$/;"	m	class:memcache::cache	file:
_cache	apps/memcached/memcache.cc	/^    sharded_cache& _cache;$/;"	m	class:memcache::stats_printer	file:
_cache	apps/memcached/memcache.cc	/^    sharded_cache& _cache;$/;"	m	class:memcache::tcp_server	file:
_cache	apps/memcached/memcache.cc	/^    sharded_cache& _cache;$/;"	m	class:memcache::udp_server	file:
_cache_link	apps/memcached/memcache.cc	/^    hook_type _cache_link;$/;"	m	class:memcache::item	file:
_chan	apps/memcached/memcache.cc	/^    udp_channel _chan;$/;"	m	class:memcache::udp_server	file:
_data	apps/memcached/memcache.cc	/^    char _data[]; \/\/ layout: data=key, (data+key_size)=ascii_prefix, (data+key_size+ascii_prefix_size)=value.$/;"	m	class:memcache::item	file:
_expiry	apps/memcached/memcache.cc	/^    expiration _expiry;$/;"	m	class:memcache::item	file:
_flush_timer	apps/memcached/memcache.cc	/^    timer<> _flush_timer;$/;"	m	class:memcache::cache	file:
_in	apps/memcached/memcache.cc	/^        input_stream<char> _in;$/;"	m	struct:memcache::tcp_server::connection	file:
_in	apps/memcached/memcache.cc	/^        input_stream<char> _in;$/;"	m	struct:memcache::udp_server::connection	file:
_insertion	apps/memcached/memcache.cc	/^    item_insertion_data _insertion;$/;"	m	class:memcache::ascii_protocol	file:
_item_key	apps/memcached/memcache.cc	/^    item_key _item_key;$/;"	m	class:memcache::ascii_protocol	file:
_items	apps/memcached/memcache.cc	/^    std::vector<item_ptr> _items;$/;"	m	class:memcache::ascii_protocol	file:
_key_hash	apps/memcached/memcache.cc	/^    size_t _key_hash;$/;"	m	class:memcache::item	file:
_key_size	apps/memcached/memcache.cc	/^    uint8_t _key_size;$/;"	m	class:memcache::item	file:
_listener	apps/memcached/memcache.cc	/^    lw_shared_ptr<server_socket> _listener;$/;"	m	class:memcache::tcp_server	file:
_max_datagram_size	apps/memcached/memcache.cc	/^    size_t _max_datagram_size = default_max_datagram_size;$/;"	m	class:memcache::udp_server	file:
_n	apps/memcached/memcache.cc	/^        packed<uint16_t> _n;$/;"	m	struct:memcache::udp_server::header	file:
_out	apps/memcached/memcache.cc	/^        output_stream<char> _out;$/;"	m	struct:memcache::tcp_server::connection	file:
_out	apps/memcached/memcache.cc	/^        output_stream<char> _out;$/;"	m	struct:memcache::udp_server::connection	file:
_out_bufs	apps/memcached/memcache.cc	/^        std::vector<packet> _out_bufs;$/;"	m	struct:memcache::udp_server::connection	file:
_parser	apps/memcached/memcache.cc	/^    memcache_ascii_parser _parser;$/;"	m	class:memcache::ascii_protocol	file:
_peers	apps/memcached/memcache.cc	/^    distributed<cache>& _peers;$/;"	m	class:memcache::sharded_cache	file:
_port	apps/memcached/memcache.cc	/^    uint16_t _port;$/;"	m	class:memcache::tcp_server	file:
_port	apps/memcached/memcache.cc	/^    uint16_t _port;$/;"	m	class:memcache::udp_server	file:
_proto	apps/memcached/memcache.cc	/^        ascii_protocol _proto;$/;"	m	struct:memcache::tcp_server::connection	file:
_proto	apps/memcached/memcache.cc	/^        ascii_protocol _proto;$/;"	m	struct:memcache::udp_server::connection	file:
_ref_count	apps/memcached/memcache.cc	/^    uint16_t _ref_count;$/;"	m	class:memcache::item	file:
_request_id	apps/memcached/memcache.cc	/^        packed<uint16_t> _request_id;$/;"	m	struct:memcache::udp_server::header	file:
_request_id	apps/memcached/memcache.cc	/^        uint16_t _request_id;$/;"	m	struct:memcache::udp_server::connection	file:
_reserved	apps/memcached/memcache.cc	/^        packed<uint16_t> _reserved;$/;"	m	struct:memcache::udp_server::header	file:
_resize_up_threshold	apps/memcached/memcache.cc	/^    size_t _resize_up_threshold = load_factor * initial_bucket_count;$/;"	m	class:memcache::cache	file:
_sequence_number	apps/memcached/memcache.cc	/^        packed<uint16_t> _sequence_number;$/;"	m	struct:memcache::udp_server::header	file:
_slab_page_index	apps/memcached/memcache.cc	/^    uint32_t _slab_page_index;$/;"	m	class:memcache::item	file:
_socket	apps/memcached/memcache.cc	/^        connected_socket _socket;$/;"	m	struct:memcache::tcp_server::connection	file:
_src	apps/memcached/memcache.cc	/^        ipv4_addr _src;$/;"	m	struct:memcache::udp_server::connection	file:
_start_time	apps/memcached/memcache.cc	/^    clock_type::time_point _start_time;$/;"	m	struct:memcache::system_stats	file:
_stats	apps/memcached/memcache.cc	/^    cache_stats _stats;$/;"	m	class:memcache::cache	file:
_system_stats	apps/memcached/memcache.cc	/^        distributed<system_stats>& _system_stats;$/;"	m	struct:memcache::tcp_server::connection	file:
_system_stats	apps/memcached/memcache.cc	/^    distributed<system_stats>& _system_stats;$/;"	m	class:memcache::ascii_protocol	file:
_system_stats	apps/memcached/memcache.cc	/^    distributed<system_stats>& _system_stats;$/;"	m	class:memcache::tcp_server	file:
_system_stats	apps/memcached/memcache.cc	/^    distributed<system_stats>& _system_stats;$/;"	m	class:memcache::udp_server	file:
_time	apps/memcached/memcache.cc	/^    uint32_t _time;$/;"	m	struct:memcache::expiration	file:
_timer	apps/memcached/memcache.cc	/^    timer<> _timer;$/;"	m	class:memcache::cache	file:
_timer	apps/memcached/memcache.cc	/^    timer<> _timer;$/;"	m	class:memcache::stats_printer	file:
_timer_link	apps/memcached/memcache.cc	/^    bi::list_member_hook<> _timer_link;$/;"	m	class:memcache::item	file:
_value_size	apps/memcached/memcache.cc	/^    uint32_t _value_size;$/;"	m	class:memcache::item	file:
add	apps/memcached/memcache.cc	/^    bool add(item_insertion_data& insertion) {$/;"	f	class:memcache::cache
add	apps/memcached/memcache.cc	/^    future<bool> add(item_insertion_data& insertion) {$/;"	f	class:memcache::sharded_cache
add_new	apps/memcached/memcache.cc	/^    void add_new(item_insertion_data& insertion) {$/;"	f	class:memcache::cache	file:
add_overriding	apps/memcached/memcache.cc	/^    cache_iterator add_overriding(cache_iterator i, item_insertion_data& insertion) {$/;"	f	class:memcache::cache	file:
adjust_endianness	apps/memcached/memcache.cc	/^        auto adjust_endianness(Adjuster a) {$/;"	f	struct:memcache::udp_server::header
append_item	apps/memcached/memcache.cc	/^    static void append_item(scattered_message<char>& msg, item_ptr item) {$/;"	f	class:memcache::ascii_protocol	file:
ascii_prefix	apps/memcached/memcache.cc	/^    const std::experimental::string_view ascii_prefix() const {$/;"	f	class:memcache::item
ascii_prefix	apps/memcached/memcache.cc	/^    sstring ascii_prefix;$/;"	m	struct:memcache::item_insertion_data	file:
ascii_prefix_size	apps/memcached/memcache.cc	/^    size_t ascii_prefix_size() const {$/;"	f	class:memcache::item
ascii_protocol	apps/memcached/memcache.cc	/^    ascii_protocol(sharded_cache& cache, distributed<system_stats>& system_stats)$/;"	f	class:memcache::ascii_protocol
ascii_protocol	apps/memcached/memcache.cc	/^class ascii_protocol {$/;"	c	namespace:memcache	file:
bucket_count	apps/memcached/memcache.cc	/^    size_t bucket_count() {$/;"	f	class:memcache::cache
cache	apps/memcached/memcache.cc	/^    cache(uint64_t per_cpu_slab_size, uint64_t slab_page_size)$/;"	f	class:memcache::cache
cache	apps/memcached/memcache.cc	/^class cache {$/;"	c	namespace:memcache	file:
cache_stats	apps/memcached/memcache.cc	/^struct cache_stats {$/;"	s	namespace:memcache	file:
cancel	apps/memcached/memcache.cc	/^    bool cancel() {$/;"	f	class:memcache::item
cas	apps/memcached/memcache.cc	/^    cas_result cas(item_insertion_data& insertion, item::version_type version) {$/;"	f	class:memcache::cache
cas	apps/memcached/memcache.cc	/^    future<cas_result> cas(item_insertion_data& insertion, item::version_type version) {$/;"	f	class:memcache::sharded_cache
cas_result	apps/memcached/memcache.cc	/^enum class cas_result {$/;"	c	namespace:memcache	file:
compare	apps/memcached/memcache.cc	/^    bool compare(const item_key& key, const item& it) const {$/;"	f	struct:memcache::item_key_cmp	file:
connection	apps/memcached/memcache.cc	/^        connection(connected_socket&& socket, socket_address addr, sharded_cache& c, distributed<system_stats>& system_stats)$/;"	f	struct:memcache::tcp_server::connection
connection	apps/memcached/memcache.cc	/^        connection(ipv4_addr src, uint16_t request_id, input_stream<char>&& in, size_t out_size,$/;"	f	struct:memcache::udp_server::connection
connection	apps/memcached/memcache.cc	/^    struct connection {$/;"	s	class:memcache::tcp_server	file:
connection	apps/memcached/memcache.cc	/^    struct connection {$/;"	s	class:memcache::udp_server	file:
data	apps/memcached/memcache.cc	/^    sstring data;$/;"	m	struct:memcache::item_insertion_data	file:
data_as_integral	apps/memcached/memcache.cc	/^    optional<uint64_t> data_as_integral() {$/;"	f	class:memcache::item
decr	apps/memcached/memcache.cc	/^    future<std::pair<item_ptr, bool>> decr(item_key& key, uint64_t delta) {$/;"	f	class:memcache::sharded_cache
decr	apps/memcached/memcache.cc	/^    std::pair<item_ptr, bool> decr(item_key& key, uint64_t delta) {$/;"	f	class:memcache::cache
default_max_datagram_size	apps/memcached/memcache.cc	/^    static const size_t default_max_datagram_size = 1400;$/;"	m	class:memcache::udp_server	file:
default_per_cpu_slab_size	apps/memcached/memcache.cc	/^static constexpr uint64_t default_per_cpu_slab_size = 0UL; \/\/ zero means reclaimer is enabled.$/;"	m	namespace:memcache	file:
default_slab_growth_factor	apps/memcached/memcache.cc	/^static constexpr double default_slab_growth_factor = 1.25;$/;"	m	namespace:memcache	file:
default_slab_page_size	apps/memcached/memcache.cc	/^static constexpr uint64_t default_slab_page_size = 1UL*MB;$/;"	m	namespace:memcache	file:
erase	apps/memcached/memcache.cc	/^    void erase(item& item_ref) {$/;"	f	class:memcache::cache	file:
ever_expires	apps/memcached/memcache.cc	/^    bool ever_expires() {$/;"	f	struct:memcache::expiration
expiration	apps/memcached/memcache.cc	/^    expiration() : _time(0U) {}$/;"	f	struct:memcache::expiration
expiration	apps/memcached/memcache.cc	/^    expiration(uint32_t seconds) {$/;"	f	struct:memcache::expiration
expiration	apps/memcached/memcache.cc	/^struct expiration {$/;"	s	namespace:memcache	file:
expire	apps/memcached/memcache.cc	/^    void expire() {$/;"	f	class:memcache::cache	file:
expiry	apps/memcached/memcache.cc	/^    expiration expiry;$/;"	m	struct:memcache::item_insertion_data	file:
field_alignment	apps/memcached/memcache.cc	/^    static constexpr uint8_t field_alignment = alignof(void*);$/;"	m	class:memcache::item	file:
find	apps/memcached/memcache.cc	/^    cache_iterator find(const item_key& key) {$/;"	f	class:memcache::cache	file:
flush_all	apps/memcached/memcache.cc	/^    future<> flush_all() {$/;"	f	class:memcache::sharded_cache
flush_all	apps/memcached/memcache.cc	/^    void flush_all() {$/;"	f	class:memcache::cache
flush_at	apps/memcached/memcache.cc	/^    future<> flush_at(clock_type::time_point time_point) {$/;"	f	class:memcache::sharded_cache
flush_at	apps/memcached/memcache.cc	/^    void flush_at(clock_type::time_point time_point) {$/;"	f	class:memcache::cache
get	apps/memcached/memcache.cc	/^    future<item_ptr> get(const item_key& key) {$/;"	f	class:memcache::sharded_cache
get	apps/memcached/memcache.cc	/^    item_ptr get(const item_key& key) {$/;"	f	class:memcache::cache
get_cpu	apps/memcached/memcache.cc	/^    unsigned get_cpu(const item_key& key) {$/;"	f	class:memcache::sharded_cache	file:
get_slab_page_index	apps/memcached/memcache.cc	/^    uint32_t get_slab_page_index() const {$/;"	f	class:memcache::item
get_timeout	apps/memcached/memcache.cc	/^    clock_type::time_point get_timeout() {$/;"	f	class:memcache::item
handle	apps/memcached/memcache.cc	/^    future<> handle(input_stream<char>& in, output_stream<char>& out) {$/;"	f	class:memcache::ascii_protocol
handle_get	apps/memcached/memcache.cc	/^    future<> handle_get(output_stream<char>& out) {$/;"	f	class:memcache::ascii_protocol	file:
hash_value	apps/memcached/memcache.cc	/^    friend std::size_t hash_value(const item &i) {$/;"	f	class:memcache::item
header	apps/memcached/memcache.cc	/^    struct header {$/;"	s	class:memcache::udp_server	file:
incr	apps/memcached/memcache.cc	/^    future<std::pair<item_ptr, bool>> incr(item_key& key, uint64_t delta) {$/;"	f	class:memcache::sharded_cache
incr	apps/memcached/memcache.cc	/^    std::pair<item_ptr, bool> incr(item_key& key, uint64_t delta) {$/;"	f	class:memcache::cache
initial_bucket_count	apps/memcached/memcache.cc	/^    static constexpr size_t initial_bucket_count = 1 << 10;$/;"	m	class:memcache::cache	file:
intrusive_ptr_add_ref	apps/memcached/memcache.cc	/^    friend inline void intrusive_ptr_add_ref(item* it) {$/;"	f	class:memcache::item
intrusive_ptr_release	apps/memcached/memcache.cc	/^    friend inline void intrusive_ptr_release(item* it) {$/;"	f	class:memcache::item
is_unlocked	apps/memcached/memcache.cc	/^    bool is_unlocked() const {$/;"	f	class:memcache::item
item	apps/memcached/memcache.cc	/^    item(uint32_t slab_page_index, item_key&& key, sstring&& ascii_prefix,$/;"	f	class:memcache::item
item	apps/memcached/memcache.cc	/^class item : public slab_item_base {$/;"	c	namespace:memcache	file:
item_insertion_data	apps/memcached/memcache.cc	/^struct item_insertion_data {$/;"	s	namespace:memcache	file:
item_key_cmp	apps/memcached/memcache.cc	/^struct item_key_cmp$/;"	s	namespace:memcache	file:
item_size	apps/memcached/memcache.cc	/^    size_t item_size(item& item_ref) {$/;"	f	class:memcache::cache	file:
item_size	apps/memcached/memcache.cc	/^    size_t item_size(item_insertion_data& insertion) {$/;"	f	class:memcache::cache	file:
key	apps/memcached/memcache.cc	/^    const std::experimental::string_view key() const {$/;"	f	class:memcache::item
key	apps/memcached/memcache.cc	/^    item_key key;$/;"	m	struct:memcache::item_insertion_data	file:
key_size	apps/memcached/memcache.cc	/^    size_t key_size() const {$/;"	f	class:memcache::item
load_factor	apps/memcached/memcache.cc	/^    static constexpr float load_factor = 0.75f;$/;"	m	class:memcache::cache	file:
local_origin_tag	apps/memcached/memcache.cc	/^struct local_origin_tag {$/;"	s	namespace:memcache	file:
main	apps/memcached/memcache.cc	/^int main(int ac, char** av) {$/;"	f
maybe_rehash	apps/memcached/memcache.cc	/^    void maybe_rehash() {$/;"	f	class:memcache::cache	file:
memcache	apps/memcached/memcache.cc	/^namespace memcache {$/;"	n	file:
move_if_local	apps/memcached/memcache.cc	/^    T move_if_local(T& ref) {$/;"	f	struct:memcache::local_origin_tag
move_if_local	apps/memcached/memcache.cc	/^    T move_if_local(T& ref) {$/;"	f	struct:memcache::remote_origin_tag
msg_crlf	apps/memcached/memcache.cc	/^    static constexpr const char *msg_crlf = "\\r\\n";$/;"	m	class:memcache::ascii_protocol	file:
msg_deleted	apps/memcached/memcache.cc	/^    static constexpr const char *msg_deleted = "DELETED\\r\\n";$/;"	m	class:memcache::ascii_protocol	file:
msg_end	apps/memcached/memcache.cc	/^    static constexpr const char *msg_end = "END\\r\\n";$/;"	m	class:memcache::ascii_protocol	file:
msg_error	apps/memcached/memcache.cc	/^    static constexpr const char *msg_error = "ERROR\\r\\n";$/;"	m	class:memcache::ascii_protocol	file:
msg_error_non_numeric_value	apps/memcached/memcache.cc	/^    static constexpr const char *msg_error_non_numeric_value = "CLIENT_ERROR cannot increment or decrement non-numeric value\\r\\n";$/;"	m	class:memcache::ascii_protocol	file:
msg_exists	apps/memcached/memcache.cc	/^    static constexpr const char *msg_exists = "EXISTS\\r\\n";$/;"	m	class:memcache::ascii_protocol	file:
msg_not_found	apps/memcached/memcache.cc	/^    static constexpr const char *msg_not_found = "NOT_FOUND\\r\\n";$/;"	m	class:memcache::ascii_protocol	file:
msg_not_stored	apps/memcached/memcache.cc	/^    static constexpr const char *msg_not_stored = "NOT_STORED\\r\\n";$/;"	m	class:memcache::ascii_protocol	file:
msg_ok	apps/memcached/memcache.cc	/^    static constexpr const char *msg_ok = "OK\\r\\n";$/;"	m	class:memcache::ascii_protocol	file:
msg_out_of_memory	apps/memcached/memcache.cc	/^    static constexpr const char *msg_out_of_memory = "SERVER_ERROR Out of memory allocating new item\\r\\n";$/;"	m	class:memcache::ascii_protocol	file:
msg_stat	apps/memcached/memcache.cc	/^    static constexpr const char *msg_stat = "STAT ";$/;"	m	class:memcache::ascii_protocol	file:
msg_stored	apps/memcached/memcache.cc	/^    static constexpr const char *msg_stored = "STORED\\r\\n";$/;"	m	class:memcache::ascii_protocol	file:
msg_value	apps/memcached/memcache.cc	/^    static constexpr const char *msg_value = "VALUE ";$/;"	m	class:memcache::ascii_protocol	file:
msg_version	apps/memcached/memcache.cc	/^    static constexpr const char *msg_version = "VERSION " VERSION_STRING "\\r\\n";$/;"	m	class:memcache::ascii_protocol	file:
not_found	apps/memcached/memcache.cc	/^    not_found, stored, bad_version$/;"	m	class:memcache::cas_result	file:
operator ()	apps/memcached/memcache.cc	/^    bool operator()(const item& it, const item_key& key) const {$/;"	f	struct:memcache::item_key_cmp
operator ()	apps/memcached/memcache.cc	/^    bool operator()(const item_key& key, const item& it) const {$/;"	f	struct:memcache::item_key_cmp
operator +=	apps/memcached/memcache.cc	/^    void operator+=(const cache_stats& o) {$/;"	f	struct:memcache::cache_stats
operator +=	apps/memcached/memcache.cc	/^    void operator+=(const system_stats& other) {$/;"	f	struct:memcache::system_stats
operator ==	apps/memcached/memcache.cc	/^    friend bool operator==(const item &a, const item &b) {$/;"	f	class:memcache::item
prepare_insertion	apps/memcached/memcache.cc	/^    void prepare_insertion() {$/;"	f	class:memcache::ascii_protocol
print_hash_stats	apps/memcached/memcache.cc	/^    future<> print_hash_stats(output_stream<char>& out) {$/;"	f	class:memcache::sharded_cache
print_hash_stats	apps/memcached/memcache.cc	/^    std::pair<unsigned, foreign_ptr<lw_shared_ptr<std::string>>> print_hash_stats() {$/;"	f	class:memcache::cache
print_stat	apps/memcached/memcache.cc	/^    static future<> print_stat(output_stream<char>& out, const char* key, Value value) {$/;"	f	class:memcache::ascii_protocol	file:
print_stats	apps/memcached/memcache.cc	/^    future<> print_stats(output_stream<char>& out) {$/;"	f	class:memcache::ascii_protocol	file:
remote_origin_tag	apps/memcached/memcache.cc	/^struct remote_origin_tag {$/;"	s	namespace:memcache	file:
remove	apps/memcached/memcache.cc	/^    bool remove(const item_key& key) {$/;"	f	class:memcache::cache
remove	apps/memcached/memcache.cc	/^    future<bool> remove(const item_key& key) {$/;"	f	class:memcache::sharded_cache
replace	apps/memcached/memcache.cc	/^    bool replace(item_insertion_data& insertion) {$/;"	f	class:memcache::cache
replace	apps/memcached/memcache.cc	/^    future<bool> replace(item_insertion_data& insertion) {$/;"	f	class:memcache::sharded_cache
respond	apps/memcached/memcache.cc	/^        future<> respond(udp_channel& chan) {$/;"	f	struct:memcache::udp_server::connection
seconds_in_a_month	apps/memcached/memcache.cc	/^    static constexpr uint32_t seconds_in_a_month = 60U * 60 * 24 * 30;$/;"	m	struct:memcache::expiration	file:
self	apps/memcached/memcache.cc	/^    system_stats self() {$/;"	f	struct:memcache::system_stats
set	apps/memcached/memcache.cc	/^    bool set(item_insertion_data& insertion) {$/;"	f	class:memcache::cache
set	apps/memcached/memcache.cc	/^    future<bool> set(item_insertion_data& insertion) {$/;"	f	class:memcache::sharded_cache
set_max_datagram_size	apps/memcached/memcache.cc	/^    void set_max_datagram_size(size_t max_datagram_size) {$/;"	f	class:memcache::udp_server
sharded_cache	apps/memcached/memcache.cc	/^    sharded_cache(distributed<cache>& peers) : _peers(peers) {}$/;"	f	class:memcache::sharded_cache
sharded_cache	apps/memcached/memcache.cc	/^class sharded_cache {$/;"	c	namespace:memcache	file:
size	apps/memcached/memcache.cc	/^    size_t size() {$/;"	f	class:memcache::cache
slab	apps/memcached/memcache.cc	/^static __thread slab_allocator<item>* slab;$/;"	m	namespace:memcache	file:
start	apps/memcached/memcache.cc	/^    void start() {$/;"	f	class:memcache::stats_printer
start	apps/memcached/memcache.cc	/^    void start() {$/;"	f	class:memcache::tcp_server
start	apps/memcached/memcache.cc	/^    void start() {$/;"	f	class:memcache::udp_server
stats	apps/memcached/memcache.cc	/^    cache_stats stats() {$/;"	f	class:memcache::cache
stats	apps/memcached/memcache.cc	/^    future<cache_stats> stats() {$/;"	f	class:memcache::sharded_cache
stats_printer	apps/memcached/memcache.cc	/^    stats_printer(sharded_cache& cache)$/;"	f	class:memcache::stats_printer
stats_printer	apps/memcached/memcache.cc	/^class stats_printer {$/;"	c	namespace:memcache	file:
stop	apps/memcached/memcache.cc	/^    future<> stop() { return make_ready_future<>(); }$/;"	f	class:memcache::cache
stop	apps/memcached/memcache.cc	/^    future<> stop() { return make_ready_future<>(); }$/;"	f	class:memcache::stats_printer
stop	apps/memcached/memcache.cc	/^    future<> stop() { return make_ready_future<>(); }$/;"	f	class:memcache::tcp_server
stop	apps/memcached/memcache.cc	/^    future<> stop() { return make_ready_future<>(); }$/;"	f	class:memcache::udp_server
stop	apps/memcached/memcache.cc	/^    future<> stop() { return make_ready_future<>(); }$/;"	f	struct:memcache::system_stats
stored	apps/memcached/memcache.cc	/^    not_found, stored, bad_version$/;"	m	class:memcache::cas_result	file:
system_stats	apps/memcached/memcache.cc	/^    system_stats() {$/;"	f	struct:memcache::system_stats
system_stats	apps/memcached/memcache.cc	/^    system_stats(clock_type::time_point start_time)$/;"	f	struct:memcache::system_stats
system_stats	apps/memcached/memcache.cc	/^struct system_stats {$/;"	s	namespace:memcache	file:
tcp_server	apps/memcached/memcache.cc	/^    tcp_server(sharded_cache& cache, distributed<system_stats>& system_stats, uint16_t port = 11211)$/;"	f	class:memcache::tcp_server
tcp_server	apps/memcached/memcache.cc	/^class tcp_server {$/;"	c	namespace:memcache	file:
to_time_point	apps/memcached/memcache.cc	/^    clock_type::time_point to_time_point() {$/;"	f	struct:memcache::expiration
udp_server	apps/memcached/memcache.cc	/^    udp_server(sharded_cache& c, distributed<system_stats>& system_stats, uint16_t port = 11211)$/;"	f	class:memcache::udp_server
udp_server	apps/memcached/memcache.cc	/^class udp_server {$/;"	c	namespace:memcache	file:
value	apps/memcached/memcache.cc	/^    const std::experimental::string_view value() const {$/;"	f	class:memcache::item
value_size	apps/memcached/memcache.cc	/^    size_t value_size() const {$/;"	f	class:memcache::item
version	apps/memcached/memcache.cc	/^    version_type version() {$/;"	f	class:memcache::item
~cache	apps/memcached/memcache.cc	/^    ~cache() {$/;"	f	class:memcache::cache
~connection	apps/memcached/memcache.cc	/^        ~connection() {$/;"	f	struct:memcache::tcp_server::connection
_MEMCACHED_HH	apps/memcached/memcached.hh	19;"	d
_hash	apps/memcached/memcached.hh	/^    size_t _hash;$/;"	m	class:memcache::item_key
_key	apps/memcached/memcached.hh	/^    sstring _key;$/;"	m	class:memcache::item_key
hash	apps/memcached/memcached.hh	/^    size_t hash() const {$/;"	f	class:memcache::item_key
hash	apps/memcached/memcached.hh	/^struct hash<memcache::item_key> {$/;"	s	namespace:std
item_key	apps/memcached/memcached.hh	/^    item_key(item_key&& other)$/;"	f	class:memcache::item_key
item_key	apps/memcached/memcached.hh	/^    item_key(sstring key)$/;"	f	class:memcache::item_key
item_key	apps/memcached/memcached.hh	/^class item_key {$/;"	c	namespace:memcache
key	apps/memcached/memcached.hh	/^    const sstring& key() const {$/;"	f	class:memcache::item_key
memcache	apps/memcached/memcached.hh	/^namespace memcache {$/;"	n
operator ()	apps/memcached/memcached.hh	/^    size_t operator()(const memcache::item_key& key) {$/;"	f	struct:std::hash
operator =	apps/memcached/memcached.hh	/^    void operator=(item_key&& other) {$/;"	f	class:memcache::item_key
operator ==	apps/memcached/memcached.hh	/^    bool operator==(const item_key& other) const {$/;"	f	class:memcache::item_key
std	apps/memcached/memcached.hh	/^namespace std {$/;"	n
main	apps/seastar/main.cc	/^int main(int ac, char** av)$/;"	f
_conn_per_core	apps/seawreck/seawreck.cc	/^    unsigned _conn_per_core;$/;"	m	class:http_client	file:
_duration	apps/seawreck/seawreck.cc	/^    unsigned _duration;$/;"	m	class:http_client	file:
_fd	apps/seawreck/seawreck.cc	/^        connected_socket _fd;$/;"	m	class:http_client::connection	file:
_http_client	apps/seawreck/seawreck.cc	/^        http_client* _http_client;$/;"	m	class:http_client::connection	file:
_parser	apps/seawreck/seawreck.cc	/^        http_response_parser _parser;$/;"	m	class:http_client::connection	file:
_read_buf	apps/seawreck/seawreck.cc	/^        input_stream<char> _read_buf;$/;"	m	class:http_client::connection	file:
_reqs_per_conn	apps/seawreck/seawreck.cc	/^    unsigned _reqs_per_conn;$/;"	m	class:http_client	file:
_run_timer	apps/seawreck/seawreck.cc	/^    timer<> _run_timer;$/;"	m	class:http_client	file:
_sockets	apps/seawreck/seawreck.cc	/^    std::vector<connected_socket> _sockets;$/;"	m	class:http_client	file:
_timer_based	apps/seawreck/seawreck.cc	/^    bool _timer_based;$/;"	m	class:http_client	file:
_write_buf	apps/seawreck/seawreck.cc	/^        output_stream<char> _write_buf;$/;"	m	class:http_client::connection	file:
connect	apps/seawreck/seawreck.cc	/^    future<> connect(ipv4_addr server_addr) {$/;"	f	class:http_client
connection	apps/seawreck/seawreck.cc	/^        connection(connected_socket&& fd, http_client* client)$/;"	f	class:http_client::connection
connection	apps/seawreck/seawreck.cc	/^    class connection {$/;"	c	class:http_client	file:
do_req	apps/seawreck/seawreck.cc	/^        future<> do_req() {$/;"	f	class:http_client::connection
done	apps/seawreck/seawreck.cc	/^    bool done(uint64_t nr_done) {$/;"	f	class:http_client
http_client	apps/seawreck/seawreck.cc	/^    http_client(unsigned duration, unsigned total_conn, unsigned reqs_per_conn)$/;"	f	class:http_client
http_client	apps/seawreck/seawreck.cc	/^class http_client {$/;"	c	file:
http_debug	apps/seawreck/seawreck.cc	/^void http_debug(const char* fmt, Args&&... args) {$/;"	f
main	apps/seawreck/seawreck.cc	/^int main(int ac, char** av) {$/;"	f
nr_done	apps/seawreck/seawreck.cc	/^        uint64_t nr_done() {$/;"	f	class:http_client::connection
run	apps/seawreck/seawreck.cc	/^    future<> run() {$/;"	f	class:http_client
stop	apps/seawreck/seawreck.cc	/^    future<> stop() {$/;"	f	class:http_client
total_reqs	apps/seawreck/seawreck.cc	/^    future<uint64_t> total_reqs() {$/;"	f	class:http_client
add_tristate	configure.py	/^def add_tristate(arg_parser, name, dest, help):$/;"	f
all_artifacts	configure.py	/^all_artifacts = apps + tests + ['libseastar.a', 'seastar.pc']$/;"	v
apply_tristate	configure.py	/^def apply_tristate(var, test, note, missing):$/;"	f
apps	configure.py	/^apps = [$/;"	v
arg_parser	configure.py	/^arg_parser = argparse.ArgumentParser('Configure seastar')$/;"	v
args	configure.py	/^args = arg_parser.parse_args()$/;"	v
artifacts	configure.py	/^            artifacts = str.join(' ', ('$builddir\/' + mode + '\/' + x for x in build_artifacts))))$/;"	v
boost_test_lib	configure.py	/^boost_test_lib = [$/;"	v
build_artifacts	configure.py	/^build_artifacts = all_artifacts if not args.artifacts else args.artifacts$/;"	v
buildfile	configure.py	/^buildfile = 'build.ninja'$/;"	v
compiles	configure.py	/^        compiles = {}$/;"	v
configure_args	configure.py	/^configure_args = str.join(' ', [shlex.quote(x) for x in sys.argv[1:]])$/;"	v
core	configure.py	/^core = [$/;"	v
dbgflag	configure.py	/^dbgflag = debug_flag(args.cxx) if args.debuginfo else ''$/;"	v
debug_flag	configure.py	/^def debug_flag(compiler):$/;"	f
defines	configure.py	/^defines = ' '.join(['-D' + d for d in defines])$/;"	v
defines	configure.py	/^defines = []$/;"	v
deps	configure.py	/^deps = {$/;"	v
do_sanitize	configure.py	/^    do_sanitize = False$/;"	v
do_sanitize	configure.py	/^do_sanitize = True$/;"	v
dpdk_cflags	configure.py	/^def dpdk_cflags (dpdk_target):$/;"	f
gen_headers	configure.py	/^            gen_headers = list(ragels.keys()) + list(swaggers.keys())$/;"	v
get_flags	configure.py	/^def get_flags():$/;"	f
have_hwloc	configure.py	/^def have_hwloc():$/;"	f
have_xen	configure.py	/^def have_xen():$/;"	f
help	configure.py	/^                        help = 'Build position-independent executable (PIE)')$/;"	v
help	configure.py	/^                        help = 'Build shared object (SO) instead of executable')$/;"	v
help	configure.py	/^                        help = 'C++ compiler path')$/;"	v
help	configure.py	/^                        help = 'Enable(1)\/disable(0)compiler debug information generation')$/;"	v
help	configure.py	/^                        help = 'Extra flags for the C++ compiler')$/;"	v
help	configure.py	/^                        help = 'Extra flags for the linker')$/;"	v
help	configure.py	/^                        help = 'Path to DPDK SDK target location (e.g. <DPDK SDK dir>\/x86_64-native-linuxapp-gcc)')$/;"	v
help	configure.py	/^                        help = 'Shortcut for compile for OSv')$/;"	v
hh	configure.py	/^                    hh = '$builddir\/' + mode + '\/gen\/' + src + '.hh'$/;"	v
hh	configure.py	/^                    hh = '$builddir\/' + mode + '\/gen\/' + src.replace('.rl', '.hh')$/;"	v
http	configure.py	/^http = ['http\/transformers.cc',$/;"	v
hwloc_libs	configure.py	/^hwloc_libs = '-lhwloc -lnuma -lpciaccess -lxml2 -lz'$/;"	v
libnet	configure.py	/^libnet = [$/;"	v
libs	configure.py	/^libs = '-laio -lboost_program_options -lboost_system -lstdc++ -lm -lboost_unit_test_framework -lboost_thread -lcapnpc -lcapnp-rpc -lcapnp -lkj-async -lkj -luv -lcryptopp -lrt'$/;"	v
link_pool_depth	configure.py	/^link_pool_depth = max(int(total_memory \/ 7e9), 1)$/;"	v
memcache_base	configure.py	/^memcache_base = [$/;"	v
missing	configure.py	/^                  missing = 'Error: required package xen-devel not installed.'):$/;"	v
modes	configure.py	/^modes = {$/;"	v
modeval	configure.py	/^        modeval = modes[mode]$/;"	v
note	configure.py	/^                  note = 'Note: xen-devel not installed.  No Xen support.',$/;"	v
obj	configure.py	/^                    obj = '$builddir\/' + mode + '\/' + src.replace('.cc', '.o')$/;"	v
objs	configure.py	/^            objs = ['$builddir\/' + mode + '\/' + src.replace('.cc', '.o')$/;"	v
outdir	configure.py	/^outdir = 'build'$/;"	v
ragels	configure.py	/^        ragels = {}$/;"	v
src	configure.py	/^            src = compiles[obj]$/;"	v
src	configure.py	/^            src = ragels[hh]$/;"	v
src	configure.py	/^            src = swaggers[hh]$/;"	v
srcs	configure.py	/^            srcs = deps[binary]$/;"	v
swaggers	configure.py	/^        swaggers = {}$/;"	v
tests	configure.py	/^tests = [$/;"	v
total_memory	configure.py	/^total_memory = os.sysconf('SC_PAGE_SIZE') * os.sysconf('SC_PHYS_PAGES')$/;"	v
try_compile	configure.py	/^def try_compile(compiler, source = '', flags = []):$/;"	f
vars	configure.py	/^                vars = modeval.copy()$/;"	v
warning_supported	configure.py	/^def warning_supported(warning, compiler):$/;"	f
warnings	configure.py	/^warnings = ' '.join(warnings)$/;"	v
warnings	configure.py	/^warnings = [$/;"	v
warnings	configure.py	/^warnings = [w$/;"	v
xen_used	configure.py	/^    xen_used=True$/;"	v
xen_used	configure.py	/^xen_used = False$/;"	v
ALIGN_HH_	core/align.hh	23;"	d
align_down	core/align.hh	/^T align_down(T v, T align) {$/;"	f
align_down	core/align.hh	/^T* align_down(T* v, size_t align) {$/;"	f
align_up	core/align.hh	/^T align_up(T v, T align) {$/;"	f
align_up	core/align.hh	/^T* align_up(T* v, size_t align) {$/;"	f
add_options	core/app-template.cc	/^app_template::add_options() {$/;"	f	class:app_template
add_positional_options	core/app-template.cc	/^app_template::add_positional_options(std::initializer_list<positional_option> options) {$/;"	f	class:app_template
app_template	core/app-template.cc	/^app_template::app_template()$/;"	f	class:app_template
configuration	core/app-template.cc	/^app_template::configuration() {$/;"	f	class:app_template
kj_run	core/app-template.cc	/^app_template::kj_run(int ac, char ** av, std::function<void ()>&& func) {$/;"	f	class:app_template
run	core/app-template.cc	/^app_template::run(int ac, char ** av, std::function<void ()>&& func) {$/;"	f	class:app_template
_APP_TEMPLATE_HH	core/app-template.hh	22;"	d
_configuration	core/app-template.hh	/^    boost::optional<boost::program_options::variables_map> _configuration;$/;"	m	class:app_template
_opts	core/app-template.hh	/^    boost::program_options::options_description _opts;$/;"	m	class:app_template
_pos_opts	core/app-template.hh	/^    boost::program_options::positional_options_description _pos_opts;$/;"	m	class:app_template
app_template	core/app-template.hh	/^class app_template {$/;"	c
help	core/app-template.hh	/^        const char* help;$/;"	m	struct:app_template::positional_option
max_count	core/app-template.hh	/^        int max_count;$/;"	m	struct:app_template::positional_option
name	core/app-template.hh	/^        const char* name;$/;"	m	struct:app_template::positional_option
positional_option	core/app-template.hh	/^    struct positional_option {$/;"	s	class:app_template
value_semantic	core/app-template.hh	/^        const boost::program_options::value_semantic* value_semantic;$/;"	m	struct:app_template::positional_option
APPLY_HH_	core/apply.hh	23;"	d
apply	core/apply.hh	/^    static auto apply(Func&& func, Tuple args) {$/;"	f	struct:apply_helper
apply	core/apply.hh	/^auto apply(Func&& func, const std::tuple<T...>& args) {$/;"	f
apply	core/apply.hh	/^auto apply(Func&& func, std::tuple<T...>& args) {$/;"	f
apply	core/apply.hh	/^auto apply(Func&& func, std::tuple<T...>&& args) {$/;"	f
apply_helper	core/apply.hh	/^struct apply_helper<Func, Tuple, std::index_sequence<I...>> {$/;"	s
ARRAY_MAP_HH_	core/array_map.hh	23;"	d
array_map	core/array_map.hh	/^    array_map(std::initializer_list<std::pair<size_t, Value>> i) {$/;"	f	class:array_map
array_map	core/array_map.hh	/^class array_map {$/;"	c
at	core/array_map.hh	/^    Value& at(size_t key) {$/;"	f	class:array_map
operator []	core/array_map.hh	/^    Value& operator[](size_t key) { return _a[key]; }$/;"	f	class:array_map
operator []	core/array_map.hh	/^    const Value& operator[](size_t key) const { return _a[key]; }$/;"	f	class:array_map
BITOPS_HH_	core/bitops.hh	23;"	d
count_leading_zeros	core/bitops.hh	/^constexpr unsigned count_leading_zeros(unsigned long long x) {$/;"	f
count_leading_zeros	core/bitops.hh	/^constexpr unsigned count_leading_zeros(unsigned long x) {$/;"	f
count_leading_zeros	core/bitops.hh	/^constexpr unsigned count_leading_zeros(unsigned x) {$/;"	f
count_trailing_zeros	core/bitops.hh	/^constexpr unsigned count_trailing_zeros(unsigned long long x) {$/;"	f
count_trailing_zeros	core/bitops.hh	/^constexpr unsigned count_trailing_zeros(unsigned long x) {$/;"	f
count_trailing_zeros	core/bitops.hh	/^constexpr unsigned count_trailing_zeros(unsigned x) {$/;"	f
__OSV_BITSET_ITER	core/bitset-iter.hh	15;"	d
_bitset	core/bitset-iter.hh	/^    std::bitset<N> _bitset;$/;"	m	class:bitsets::set_iterator
_bitset	core/bitset-iter.hh	/^    std::bitset<N> _bitset;$/;"	m	class:bitsets::set_range
_index	core/bitset-iter.hh	/^    int _index;$/;"	m	class:bitsets::set_iterator
_offset	core/bitset-iter.hh	/^    int _offset;$/;"	m	class:bitsets::set_range
advance	core/bitset-iter.hh	/^    void advance()$/;"	f	class:bitsets::set_iterator
begin	core/bitset-iter.hh	/^    iterator begin() const { return iterator(_bitset, _offset); }$/;"	f	class:bitsets::set_range
bitsets	core/bitset-iter.hh	/^namespace bitsets {$/;"	n
count_leading_zeros	core/bitset-iter.hh	/^inline size_t count_leading_zeros<long>(long value)$/;"	f	namespace:bitsets
count_leading_zeros	core/bitset-iter.hh	/^inline size_t count_leading_zeros<unsigned long>(unsigned long value)$/;"	f	namespace:bitsets
count_trailing_zeros	core/bitset-iter.hh	/^size_t count_trailing_zeros<long>(long value)$/;"	f	namespace:bitsets
count_trailing_zeros	core/bitset-iter.hh	/^size_t count_trailing_zeros<unsigned long>(unsigned long value)$/;"	f	namespace:bitsets
end	core/bitset-iter.hh	/^    iterator end() const { return iterator(0); }$/;"	f	class:bitsets::set_range
for_each_set	core/bitset-iter.hh	/^static inline set_range<N> for_each_set(std::bitset<N> bitset, int offset = 0)$/;"	f	namespace:bitsets
get_first_set	core/bitset-iter.hh	/^static inline size_t get_first_set(const std::bitset<N>& bitset)$/;"	f	namespace:bitsets
get_last_set	core/bitset-iter.hh	/^static inline size_t get_last_set(const std::bitset<N>& bitset)$/;"	f	namespace:bitsets
operator !=	core/bitset-iter.hh	/^    bool operator!=(const set_iterator& other) const$/;"	f	class:bitsets::set_iterator
operator *	core/bitset-iter.hh	/^    int operator*() const$/;"	f	class:bitsets::set_iterator
operator ++	core/bitset-iter.hh	/^    void operator++()$/;"	f	class:bitsets::set_iterator
operator ==	core/bitset-iter.hh	/^    bool operator==(const set_iterator& other) const$/;"	f	class:bitsets::set_iterator
set_iterator	core/bitset-iter.hh	/^    set_iterator(std::bitset<N> bitset, int offset = 0)$/;"	f	class:bitsets::set_iterator
set_iterator	core/bitset-iter.hh	/^class set_iterator : public std::iterator<std::input_iterator_tag, int>$/;"	c	namespace:bitsets
set_range	core/bitset-iter.hh	/^    set_range(std::bitset<N> bitset, int offset = 0)$/;"	f	class:bitsets::set_range
set_range	core/bitset-iter.hh	/^class set_range$/;"	c	namespace:bitsets
ulong_bits	core/bitset-iter.hh	/^static constexpr int ulong_bits = std::numeric_limits<unsigned long>::digits;$/;"	m	namespace:bitsets
CIRCULAR_BUFFER_HH_	core/circular_buffer.hh	23;"	d
X	core/circular_buffer.hh	/^    circular_buffer(const circular_buffer& X) = delete;$/;"	m	class:circular_buffer
_impl	core/circular_buffer.hh	/^    impl _impl;$/;"	m	class:circular_buffer
access_element_unsafe	core/circular_buffer.hh	/^circular_buffer<T, Alloc>::access_element_unsafe(size_t idx) {$/;"	f	class:circular_buffer
back	core/circular_buffer.hh	/^circular_buffer<T, Alloc>::back() {$/;"	f	class:circular_buffer
begin	core/circular_buffer.hh	/^        size_t begin = 0;$/;"	m	struct:circular_buffer::impl
begin	core/circular_buffer.hh	/^    const_iterator begin() const {$/;"	f	class:circular_buffer
begin	core/circular_buffer.hh	/^    iterator begin() {$/;"	f	class:circular_buffer
capacity	core/circular_buffer.hh	/^        size_t capacity = 0;$/;"	m	struct:circular_buffer::impl
capacity	core/circular_buffer.hh	/^circular_buffer<T, Alloc>::capacity() const {$/;"	f	class:circular_buffer
cb	core/circular_buffer.hh	/^        CB* cb;$/;"	m	struct:circular_buffer::cbiterator
cbegin	core/circular_buffer.hh	/^    const_iterator cbegin() const {$/;"	f	class:circular_buffer
cbiterator	core/circular_buffer.hh	/^        cbiterator<CB, ValueType>(CB* b, size_t i) : cb(b), idx(i) {}$/;"	f	struct:circular_buffer::cbiterator
cbiterator	core/circular_buffer.hh	/^    struct cbiterator : std::iterator<std::random_access_iterator_tag, ValueType> {$/;"	s	class:circular_buffer
cend	core/circular_buffer.hh	/^    const_iterator cend() const {$/;"	f	class:circular_buffer
circular_buffer	core/circular_buffer.hh	/^circular_buffer<T, Alloc>::circular_buffer(circular_buffer&& x)$/;"	f	class:circular_buffer
circular_buffer	core/circular_buffer.hh	/^class circular_buffer {$/;"	c
const_iterator	core/circular_buffer.hh	/^    typedef cbiterator<const circular_buffer, const T> const_iterator;$/;"	t	class:circular_buffer
emplace_back	core/circular_buffer.hh	/^circular_buffer<T, Alloc>::emplace_back(Args&&... args) {$/;"	f	class:circular_buffer
emplace_front	core/circular_buffer.hh	/^circular_buffer<T, Alloc>::emplace_front(Args&&... args) {$/;"	f	class:circular_buffer
empty	core/circular_buffer.hh	/^circular_buffer<T, Alloc>::empty() const {$/;"	f	class:circular_buffer
end	core/circular_buffer.hh	/^        size_t end = 0;$/;"	m	struct:circular_buffer::impl
end	core/circular_buffer.hh	/^    const_iterator end() const {$/;"	f	class:circular_buffer
end	core/circular_buffer.hh	/^    iterator end() {$/;"	f	class:circular_buffer
expand	core/circular_buffer.hh	/^circular_buffer<T, Alloc>::expand() {$/;"	f	class:circular_buffer
for_each	core/circular_buffer.hh	/^circular_buffer<T, Alloc>::for_each(Func func) {$/;"	f	class:circular_buffer
front	core/circular_buffer.hh	/^circular_buffer<T, Alloc>::front() {$/;"	f	class:circular_buffer
idx	core/circular_buffer.hh	/^        size_t idx;$/;"	m	struct:circular_buffer::cbiterator
impl	core/circular_buffer.hh	/^    struct impl : Alloc {$/;"	s	class:circular_buffer
iterator	core/circular_buffer.hh	/^    typedef cbiterator<circular_buffer, T> iterator;$/;"	t	class:circular_buffer
mask	core/circular_buffer.hh	/^circular_buffer<T, Alloc>::mask(size_t idx) const {$/;"	f	class:circular_buffer
maybe_expand	core/circular_buffer.hh	/^circular_buffer<T, Alloc>::maybe_expand(size_t nr) {$/;"	f	class:circular_buffer
operator !=	core/circular_buffer.hh	/^        bool operator!=(const cbiterator<CB, ValueType>& rhs) const {$/;"	f	struct:circular_buffer::cbiterator
operator *	core/circular_buffer.hh	/^        ValueType& operator*() const { return cb->_impl.storage[cb->mask(idx)]; }$/;"	f	struct:circular_buffer::cbiterator
operator +	core/circular_buffer.hh	/^        cbiterator<CB, ValueType> operator+(typename super_t::difference_type n) const {$/;"	f	struct:circular_buffer::cbiterator
operator ++	core/circular_buffer.hh	/^        cbiterator<CB, ValueType> operator++(int unused) {$/;"	f	struct:circular_buffer::cbiterator
operator ++	core/circular_buffer.hh	/^        cbiterator<CB, ValueType>& operator++() {$/;"	f	struct:circular_buffer::cbiterator
operator +=	core/circular_buffer.hh	/^        cbiterator<CB, ValueType>& operator+=(typename super_t::difference_type n) {$/;"	f	struct:circular_buffer::cbiterator
operator -	core/circular_buffer.hh	/^        cbiterator<CB, ValueType> operator-(typename super_t::difference_type n) const {$/;"	f	struct:circular_buffer::cbiterator
operator -	core/circular_buffer.hh	/^       typename super_t::difference_type operator-(const cbiterator<CB, ValueType>& rhs) const {$/;"	f	struct:circular_buffer::cbiterator
operator --	core/circular_buffer.hh	/^        cbiterator<CB, ValueType> operator--(int unused) {$/;"	f	struct:circular_buffer::cbiterator
operator --	core/circular_buffer.hh	/^        cbiterator<CB, ValueType>& operator--() {$/;"	f	struct:circular_buffer::cbiterator
operator -=	core/circular_buffer.hh	/^        cbiterator<CB, ValueType>& operator-=(typename super_t::difference_type n) {$/;"	f	struct:circular_buffer::cbiterator
operator ->	core/circular_buffer.hh	/^        ValueType* operator->() const { return &cb->_impl.storage[cb->mask(idx)]; }$/;"	f	struct:circular_buffer::cbiterator
operator <	core/circular_buffer.hh	/^        bool operator<(const cbiterator<CB, ValueType>& rhs) const {$/;"	f	struct:circular_buffer::cbiterator
operator <=	core/circular_buffer.hh	/^        bool operator<=(const cbiterator<CB, ValueType>& rhs) const {$/;"	f	struct:circular_buffer::cbiterator
operator ==	core/circular_buffer.hh	/^        bool operator==(const cbiterator<CB, ValueType>& rhs) const {$/;"	f	struct:circular_buffer::cbiterator
operator >	core/circular_buffer.hh	/^        bool operator>(const cbiterator<CB, ValueType>& rhs) const {$/;"	f	struct:circular_buffer::cbiterator
operator >=	core/circular_buffer.hh	/^        bool operator>=(const cbiterator<CB, ValueType>& rhs) const {$/;"	f	struct:circular_buffer::cbiterator
operator []	core/circular_buffer.hh	/^circular_buffer<T, Alloc>::operator[](size_t idx) {$/;"	f	class:circular_buffer
pop_back	core/circular_buffer.hh	/^circular_buffer<T, Alloc>::pop_back() {$/;"	f	class:circular_buffer
pop_front	core/circular_buffer.hh	/^circular_buffer<T, Alloc>::pop_front() {$/;"	f	class:circular_buffer
push_back	core/circular_buffer.hh	/^circular_buffer<T, Alloc>::push_back(T&& data) {$/;"	f	class:circular_buffer
push_back	core/circular_buffer.hh	/^circular_buffer<T, Alloc>::push_back(const T& data) {$/;"	f	class:circular_buffer
push_front	core/circular_buffer.hh	/^circular_buffer<T, Alloc>::push_front(T&& data) {$/;"	f	class:circular_buffer
push_front	core/circular_buffer.hh	/^circular_buffer<T, Alloc>::push_front(const T& data) {$/;"	f	class:circular_buffer
size	core/circular_buffer.hh	/^circular_buffer<T, Alloc>::size() const {$/;"	f	class:circular_buffer
storage	core/circular_buffer.hh	/^        T* storage = nullptr;$/;"	m	struct:circular_buffer::impl
super_t	core/circular_buffer.hh	/^        typedef std::iterator<std::random_access_iterator_tag, ValueType> super_t;$/;"	t	struct:circular_buffer::cbiterator
~circular_buffer	core/circular_buffer.hh	/^circular_buffer<T, Alloc>::~circular_buffer() {$/;"	f	class:circular_buffer
DELETER_HH_	core/deleter.hh	23;"	d
_impl	core/deleter.hh	/^    impl* _impl = nullptr;$/;"	m	class:final
append	core/deleter.hh	/^void deleter::append(deleter d) {$/;"	f	class:deleter
del	core/deleter.hh	/^    Deleter del;$/;"	m	struct:final
deleter	core/deleter.hh	/^    deleter(deleter&& x) : _impl(x._impl) { x._impl = nullptr; }$/;"	f	class:final
deleter	core/deleter.hh	/^    deleter(raw_object_tag tag, void* object)$/;"	f	class:final
deleter	core/deleter.hh	/^    explicit deleter(impl* i) : _impl(i) {}$/;"	f	class:final
final	core/deleter.hh	/^class deleter final {$/;"	c
final	core/deleter.hh	/^struct free_deleter_impl final : deleter::impl {$/;"	s
final	core/deleter.hh	/^struct lambda_deleter_impl final : deleter::impl {$/;"	s
final	core/deleter.hh	/^struct object_deleter_impl final : deleter::impl {$/;"	s
free_deleter_impl	core/deleter.hh	/^    free_deleter_impl(void* obj) : impl(deleter()), obj(obj) {}$/;"	f	struct:final
from_raw_object	core/deleter.hh	/^    impl* from_raw_object(void* object) {$/;"	f	class:final
impl	core/deleter.hh	/^    impl(deleter next) : next(std::move(next)) {}$/;"	f	struct:deleter::impl
impl	core/deleter.hh	/^struct deleter::impl {$/;"	s	class:deleter
is_raw_object	core/deleter.hh	/^    bool is_raw_object() const {$/;"	f	class:final
is_raw_object	core/deleter.hh	/^    static bool is_raw_object(impl* i) {$/;"	f	class:final
lambda_deleter_impl	core/deleter.hh	/^    lambda_deleter_impl(deleter next, Deleter&& del)$/;"	f	struct:final
make_deleter	core/deleter.hh	/^make_deleter(Object o) {$/;"	f
make_deleter	core/deleter.hh	/^make_deleter(deleter next, Object o) {$/;"	f
make_free_deleter	core/deleter.hh	/^make_free_deleter(deleter next, void* obj) {$/;"	f
make_free_deleter	core/deleter.hh	/^make_free_deleter(void* obj) {$/;"	f
make_object_deleter	core/deleter.hh	/^make_object_deleter(T&& obj) {$/;"	f
make_object_deleter	core/deleter.hh	/^make_object_deleter(deleter d, T&& obj) {$/;"	f
make_object_deleter_impl	core/deleter.hh	/^object_deleter_impl<Object>* make_object_deleter_impl(deleter next, Object obj) {$/;"	f
next	core/deleter.hh	/^    deleter next;$/;"	m	struct:deleter::impl
obj	core/deleter.hh	/^    Object obj;$/;"	m	struct:final
obj	core/deleter.hh	/^    void* obj;$/;"	m	struct:final
object_deleter_impl	core/deleter.hh	/^    object_deleter_impl(deleter next, Object&& obj)$/;"	f	struct:final
operator =	core/deleter.hh	/^deleter& deleter::operator=(deleter&& x) {$/;"	f	class:deleter
operator bool	core/deleter.hh	/^    explicit operator bool() const { return bool(_impl); }$/;"	f	class:final
raw_object_tag	core/deleter.hh	/^    struct raw_object_tag {};$/;"	s	class:final
refs	core/deleter.hh	/^    unsigned refs = 1;$/;"	m	struct:deleter::impl
reset	core/deleter.hh	/^    void reset(impl* i) {$/;"	f	class:final
share	core/deleter.hh	/^deleter::share() {$/;"	f	class:deleter
to_raw_object	core/deleter.hh	/^    static void* to_raw_object(impl* i) {$/;"	f	class:final
to_raw_object	core/deleter.hh	/^    void* to_raw_object() const {$/;"	f	class:final
~deleter	core/deleter.hh	/^deleter::~deleter() {$/;"	f	class:deleter
~impl	core/deleter.hh	/^    virtual ~impl() {}$/;"	f	struct:deleter::impl
DISTRIBUTED_HH_	core/distributed.hh	23;"	d
_cpu	core/distributed.hh	/^    unsigned _cpu;$/;"	m	class:foreign_ptr
_instances	core/distributed.hh	/^    std::vector<Service*> _instances;$/;"	m	class:distributed
_value	core/distributed.hh	/^    PtrType _value;$/;"	m	class:foreign_ptr
distributed	core/distributed.hh	/^    distributed() {}$/;"	f	class:distributed
distributed	core/distributed.hh	/^class distributed {$/;"	c
foreign_ptr	core/distributed.hh	/^    foreign_ptr()$/;"	f	class:foreign_ptr
foreign_ptr	core/distributed.hh	/^    foreign_ptr(PtrType value)$/;"	f	class:foreign_ptr
foreign_ptr	core/distributed.hh	/^    foreign_ptr(std::nullptr_t) : foreign_ptr() {}$/;"	f	class:foreign_ptr
foreign_ptr	core/distributed.hh	/^class foreign_ptr {$/;"	c
invoke_on	core/distributed.hh	/^    invoke_on(unsigned id, Func&& func) {$/;"	f	class:distributed
invoke_on	core/distributed.hh	/^    invoke_on(unsigned id, Ret (Service::*func)(FuncArgs...), Args&&... args) {$/;"	f	class:distributed
invoke_on	core/distributed.hh	/^    void invoke_on(unsigned id, void (Service::*func)(FuncArgs...), Args&&... args) {$/;"	f	class:distributed
invoke_on_all	core/distributed.hh	/^distributed<Service>::invoke_on_all(Func&& func) {$/;"	f	class:distributed
invoke_on_all	core/distributed.hh	/^distributed<Service>::invoke_on_all(void (Service::*func)(Args...), Args... args) {$/;"	f	class:distributed
local	core/distributed.hh	/^Service& distributed<Service>::local() {$/;"	f	class:distributed
local_is_initialized	core/distributed.hh	/^inline bool distributed<Service>::local_is_initialized() {$/;"	f	class:distributed
make_foreign	core/distributed.hh	/^foreign_ptr<T> make_foreign(T ptr) {$/;"	f
make_local_and_release	core/distributed.hh	/^    element_type make_local_and_release() {$/;"	f	class:foreign_ptr
map_reduce0	core/distributed.hh	/^    map_reduce0(Mapper map, Initial initial, Reduce reduce) {$/;"	f	class:distributed
on_origin	core/distributed.hh	/^    bool on_origin() {$/;"	f	class:foreign_ptr
operator *	core/distributed.hh	/^    element_type& operator*() const { return *_value; }$/;"	f	class:foreign_ptr
operator ->	core/distributed.hh	/^    element_type* operator->() const { return &*_value; }$/;"	f	class:foreign_ptr
operator bool	core/distributed.hh	/^    operator bool() const { return static_cast<bool>(_value); }$/;"	f	class:foreign_ptr
other	core/distributed.hh	/^    distributed& operator=(const distributed& other) = delete;$/;"	m	class:distributed
other	core/distributed.hh	/^    distributed& operator=(distributed& other) = default;$/;"	m	class:distributed
other	core/distributed.hh	/^    distributed(const distributed& other) = delete;$/;"	m	class:distributed
other	core/distributed.hh	/^    distributed(distributed&& other) = default;$/;"	m	class:distributed
other	core/distributed.hh	/^    foreign_ptr& operator=(foreign_ptr&& other) = default;$/;"	m	class:foreign_ptr
other	core/distributed.hh	/^    foreign_ptr(foreign_ptr&& other) = default;$/;"	m	class:foreign_ptr
start	core/distributed.hh	/^distributed<Service>::start(Args&&... args) {$/;"	f	class:distributed
start_single	core/distributed.hh	/^distributed<Service>::start_single(Args&&... args) {$/;"	f	class:distributed
stop	core/distributed.hh	/^distributed<Service>::stop() {$/;"	f	class:distributed
~distributed	core/distributed.hh	/^distributed<Service>::~distributed() {$/;"	f	class:distributed
~foreign_ptr	core/distributed.hh	/^    ~foreign_ptr() {$/;"	f	class:foreign_ptr
do_with	core/do_with.hh	/^auto do_with(T&& rvalue, F&& f) {$/;"	f
dpdk	core/dpdk_rte.cc	/^namespace dpdk {$/;"	n	file:
init	core/dpdk_rte.cc	/^void eal::init(cpuset cpus, boost::program_options::variables_map opts)$/;"	f	class:dpdk::eal
initialized	core/dpdk_rte.cc	/^bool eal::initialized = false;$/;"	m	class:dpdk::eal	file:
mem_size	core/dpdk_rte.cc	/^size_t eal::mem_size(int num_cpus, bool hugetlbfs_membackend)$/;"	f	class:dpdk::eal
qp_mempool_obj_size	core/dpdk_rte.cc	/^uint32_t __attribute__((weak)) qp_mempool_obj_size(bool hugetlbfs_membackend)$/;"	f	namespace:dpdk
DPDK_RTE_HH_	core/dpdk_rte.hh	19;"	d
RTE_VERSION_1_7	core/dpdk_rte.hh	35;"	d
dpdk	core/dpdk_rte.hh	/^namespace dpdk {$/;"	n
eal	core/dpdk_rte.hh	/^class eal {$/;"	c	namespace:dpdk
initialized	core/dpdk_rte.hh	/^    static bool initialized;$/;"	m	class:dpdk::eal
rte_mbuf_buf_addr	core/dpdk_rte.hh	54;"	d
rte_mbuf_buf_addr	core/dpdk_rte.hh	71;"	d
rte_mbuf_buf_len	core/dpdk_rte.hh	56;"	d
rte_mbuf_buf_len	core/dpdk_rte.hh	73;"	d
rte_mbuf_buf_physaddr	core/dpdk_rte.hh	55;"	d
rte_mbuf_buf_physaddr	core/dpdk_rte.hh	72;"	d
rte_mbuf_data_len	core/dpdk_rte.hh	48;"	d
rte_mbuf_data_len	core/dpdk_rte.hh	65;"	d
rte_mbuf_l2_len	core/dpdk_rte.hh	52;"	d
rte_mbuf_l2_len	core/dpdk_rte.hh	69;"	d
rte_mbuf_l3_len	core/dpdk_rte.hh	53;"	d
rte_mbuf_l3_len	core/dpdk_rte.hh	70;"	d
rte_mbuf_nb_segs	core/dpdk_rte.hh	51;"	d
rte_mbuf_nb_segs	core/dpdk_rte.hh	68;"	d
rte_mbuf_next	core/dpdk_rte.hh	50;"	d
rte_mbuf_next	core/dpdk_rte.hh	67;"	d
rte_mbuf_pkt_len	core/dpdk_rte.hh	49;"	d
rte_mbuf_pkt_len	core/dpdk_rte.hh	66;"	d
rte_mbuf_rss_hash	core/dpdk_rte.hh	47;"	d
rte_mbuf_rss_hash	core/dpdk_rte.hh	64;"	d
rte_mbuf_vlan_tci	core/dpdk_rte.hh	46;"	d
rte_mbuf_vlan_tci	core/dpdk_rte.hh	63;"	d
enum_hash	core/enum.hh	/^class enum_hash {$/;"	c
operator ()	core/enum.hh	/^    std::size_t operator()(const T& e) const {$/;"	f	class:enum_hash
FILE_HH_	core/file.hh	23;"	d
_fd	core/file.hh	/^    int _fd;$/;"	m	class:posix_file_impl
_file_impl	core/file.hh	/^    std::unique_ptr<file_impl> _file_impl;$/;"	m	class:file
_front	core/file.hh	/^        uint64_t     _front;$/;"	m	struct:file::read_state
_offset	core/file.hh	/^        uint64_t     _offset;$/;"	m	struct:file::read_state
_to_read	core/file.hh	/^        size_t       _to_read;$/;"	m	struct:file::read_state
allocate	core/file.hh	/^    future<> allocate(uint64_t position, uint64_t length) {$/;"	f	class:file
append_new_data	core/file.hh	/^        void append_new_data(tmp_buf_type& new_data) {$/;"	f	struct:file::read_state
block_device	core/file.hh	/^    block_device,$/;"	m	class:directory_entry_type
blockdev_file_impl	core/file.hh	/^    blockdev_file_impl(int fd) : posix_file_impl(fd) {}$/;"	f	class:blockdev_file_impl
blockdev_file_impl	core/file.hh	/^class blockdev_file_impl : public posix_file_impl {$/;"	c
buf	core/file.hh	/^        tmp_buf_type buf;$/;"	m	struct:file::read_state
char_device	core/file.hh	/^    char_device,$/;"	m	class:directory_entry_type
cur_offset	core/file.hh	/^        uint64_t cur_offset() const {$/;"	f	struct:file::read_state
directory	core/file.hh	/^    directory,$/;"	m	class:directory_entry_type
directory_entry	core/file.hh	/^struct directory_entry {$/;"	s
directory_entry_type	core/file.hh	/^enum class directory_entry_type {$/;"	c
discard	core/file.hh	/^    future<> discard(uint64_t offset, uint64_t length) {$/;"	f	class:file
dma_alignment	core/file.hh	/^    static constexpr uint64_t dma_alignment = 4096;$/;"	m	class:file
dma_read	core/file.hh	/^    dma_read(uint64_t aligned_pos, CharType* aligned_buffer, size_t aligned_len) {$/;"	f	class:file
dma_read	core/file.hh	/^    future<size_t> dma_read(uint64_t pos, std::vector<iovec> iov) {$/;"	f	class:file
dma_read	core/file.hh	/^    future<temporary_buffer<CharType>> dma_read(uint64_t pos, size_t len) {$/;"	f	class:file
dma_read_bulk	core/file.hh	/^file::dma_read_bulk(uint64_t offset, size_t range_size) {$/;"	f	class:file
dma_read_exactly	core/file.hh	/^    dma_read_exactly(uint64_t pos, size_t len) {$/;"	f	class:file
dma_write	core/file.hh	/^    future<size_t> dma_write(uint64_t pos, const CharType* buffer, size_t len) {$/;"	f	class:file
dma_write	core/file.hh	/^    future<size_t> dma_write(uint64_t pos, std::vector<iovec> iov) {$/;"	f	class:file
done	core/file.hh	/^        bool done() const {$/;"	f	struct:file::read_state
eof	core/file.hh	/^        bool         eof      = false;$/;"	m	struct:file::read_state
eof_error	core/file.hh	/^    class eof_error : public std::exception {};$/;"	c	class:file
fifo	core/file.hh	/^    fifo,$/;"	m	class:directory_entry_type
file	core/file.hh	/^    explicit file(int fd) : _file_impl(make_file_impl(fd)) {}$/;"	f	class:file
file	core/file.hh	/^    file(file&& x) : _file_impl(std::move(x._file_impl)) {}$/;"	f	class:file
file	core/file.hh	/^class file {$/;"	c
file_impl	core/file.hh	/^class file_impl {$/;"	c
flush	core/file.hh	/^    future<> flush() {$/;"	f	class:file
have_good_bytes	core/file.hh	/^        bool have_good_bytes() const {$/;"	f	struct:file::read_state
kj_allocate	core/file.hh	/^    kj::Promise<void> kj_allocate(uint64_t position, uint64_t length) {$/;"	f	class:file
kj_discard	core/file.hh	/^    kj::Promise<void> kj_discard(uint64_t offset, uint64_t length) {$/;"	f	class:file
kj_dma_read	core/file.hh	/^    kj::Promise<size_t> kj_dma_read(uint64_t pos, CharType* buffer, size_t len) {$/;"	f	class:file
kj_dma_read	core/file.hh	/^    kj::Promise<size_t> kj_dma_read(uint64_t pos, std::vector<iovec> iov) {$/;"	f	class:file
kj_dma_read_bulk	core/file.hh	/^file::kj_dma_read_bulk(uint64_t offset, size_t range_size) {$/;"	f	class:file
kj_dma_write	core/file.hh	/^    kj::Promise<size_t> kj_dma_write(uint64_t pos, const CharType* buffer, size_t len) {$/;"	f	class:file
kj_dma_write	core/file.hh	/^    kj::Promise<size_t> kj_dma_write(uint64_t pos, std::vector<iovec> iov) {$/;"	f	class:file
kj_flush	core/file.hh	/^    kj::Promise<void> kj_flush() {$/;"	f	class:file
kj_read_maybe_eof	core/file.hh	/^file::kj_read_maybe_eof(uint64_t pos, size_t len) {$/;"	f	class:file
kj_size	core/file.hh	/^    kj::Promise<size_t> kj_size() {$/;"	f	class:file
kj_stat	core/file.hh	/^    kj::Promise<struct stat> kj_stat() {$/;"	f	class:file
kj_truncate	core/file.hh	/^    kj::Promise<void> kj_truncate(uint64_t length) {$/;"	f	class:file
left_space	core/file.hh	/^        size_t left_space() const {$/;"	f	struct:file::read_state
left_to_read	core/file.hh	/^        size_t left_to_read() const {$/;"	f	struct:file::read_state
link	core/file.hh	/^    link,$/;"	m	class:directory_entry_type
list_directory	core/file.hh	/^    subscription<directory_entry> list_directory(std::function<future<> (directory_entry de)> next) {$/;"	f	class:file
make_file_impl	core/file.hh	/^make_file_impl(int fd) {$/;"	f
name	core/file.hh	/^    sstring name;$/;"	m	struct:directory_entry
noexcept	core/file.hh	/^    file& operator=(file&& x) noexcept = default;$/;"	m	class:file
override	core/file.hh	/^	kj::Promise<void> kj_allocate(uint64_t position, uint64_t length) override;$/;"	m	class:posix_file_impl
override	core/file.hh	/^	virtual future<> allocate(uint64_t position, uint64_t length) override;$/;"	m	class:blockdev_file_impl
override	core/file.hh	/^	virtual kj::Promise<void> kj_allocate(uint64_t position, uint64_t length) override;$/;"	m	class:blockdev_file_impl
override	core/file.hh	/^    future<> discard(uint64_t offset, uint64_t length) override;$/;"	m	class:blockdev_file_impl
override	core/file.hh	/^    future<> truncate(uint64_t length) override;$/;"	m	class:blockdev_file_impl
override	core/file.hh	/^    future<size_t> size(void) override;$/;"	m	class:blockdev_file_impl
override	core/file.hh	/^    kj::Promise<size_t> kj_read_dma(uint64_t pos, std::vector<iovec> iov) override;$/;"	m	class:posix_file_impl
override	core/file.hh	/^    kj::Promise<size_t> kj_read_dma(uint64_t pos, void* buffer, size_t len) override;$/;"	m	class:posix_file_impl
override	core/file.hh	/^    kj::Promise<size_t> kj_size(void) override;$/;"	m	class:posix_file_impl
override	core/file.hh	/^    kj::Promise<size_t> kj_write_dma(uint64_t pos, const void* buffer, size_t len) override;$/;"	m	class:posix_file_impl
override	core/file.hh	/^    kj::Promise<size_t> kj_write_dma(uint64_t pos, std::vector<iovec> iov) override;$/;"	m	class:posix_file_impl
override	core/file.hh	/^    kj::Promise<struct stat> kj_stat(void) override;$/;"	m	class:posix_file_impl
override	core/file.hh	/^    kj::Promise<void> kj_discard(uint64_t offset, uint64_t length) override;$/;"	m	class:posix_file_impl
override	core/file.hh	/^    kj::Promise<void> kj_flush(void) override;$/;"	m	class:posix_file_impl
override	core/file.hh	/^    kj::Promise<void> kj_truncate(uint64_t length) override;$/;"	m	class:posix_file_impl
override	core/file.hh	/^    virtual future<> allocate(uint64_t position, uint64_t length) override;$/;"	m	class:posix_file_impl
override	core/file.hh	/^    virtual subscription<directory_entry> list_directory(std::function<future<> (directory_entry de)> next) override;$/;"	m	class:posix_file_impl
pos	core/file.hh	/^        size_t       pos      = 0;$/;"	m	struct:file::read_state
posix_file_impl	core/file.hh	/^    posix_file_impl(int fd) : _fd(fd) {}$/;"	f	class:posix_file_impl
posix_file_impl	core/file.hh	/^class posix_file_impl : public file_impl {$/;"	c
read_maybe_eof	core/file.hh	/^file::read_maybe_eof(uint64_t pos, size_t len) {$/;"	f	class:file
read_state	core/file.hh	/^        read_state(uint64_t offset, uint64_t front, size_t to_read)$/;"	f	struct:file::read_state
read_state	core/file.hh	/^    struct read_state {$/;"	s	class:file
regular	core/file.hh	/^    regular,$/;"	m	class:directory_entry_type
size	core/file.hh	/^    future<size_t> size() {$/;"	f	class:file
socket	core/file.hh	/^    socket,$/;"	m	class:directory_entry_type
stat	core/file.hh	/^    future<struct stat> stat() {$/;"	f	class:file
tmp_buf_type	core/file.hh	/^        typedef temporary_buffer<CharType> tmp_buf_type;$/;"	t	struct:file::read_state
trim_buf_before_ret	core/file.hh	/^        void trim_buf_before_ret() {$/;"	f	struct:file::read_state
truncate	core/file.hh	/^    future<> truncate(uint64_t length) {$/;"	f	class:file
type	core/file.hh	/^    std::experimental::optional<directory_entry_type> type;$/;"	m	struct:directory_entry
~file_impl	core/file.hh	/^    virtual ~file_impl() {}$/;"	f	class:file_impl
~posix_file_impl	core/file.hh	/^    ~posix_file_impl() {$/;"	f	class:posix_file_impl
_buffer_size	core/fstream.cc	/^    size_t _buffer_size;$/;"	m	class:file_data_sink_impl	file:
_buffer_size	core/fstream.cc	/^    size_t _buffer_size;$/;"	m	class:file_data_source_impl	file:
_file	core/fstream.cc	/^    lw_shared_ptr<file> _file;$/;"	m	class:file_data_sink_impl	file:
_file	core/fstream.cc	/^    lw_shared_ptr<file> _file;$/;"	m	class:file_data_source_impl	file:
_fsize	core/fstream.cc	/^    std::experimental::optional<size_t> _fsize;$/;"	m	class:file_data_source_impl	file:
_pos	core/fstream.cc	/^    uint64_t _pos = 0;$/;"	m	class:file_data_sink_impl	file:
_pos	core/fstream.cc	/^    uint64_t _pos;$/;"	m	class:file_data_source_impl	file:
close	core/fstream.cc	/^    future<> close() { return _file->flush(); }$/;"	f	class:file_data_sink_impl
do_get	core/fstream.cc	/^    future<temporary_buffer<char>> do_get() {$/;"	f	class:file_data_source_impl	file:
file_data_sink	core/fstream.cc	/^    file_data_sink(lw_shared_ptr<file> f, size_t buffer_size)$/;"	f	class:file_data_sink
file_data_sink	core/fstream.cc	/^class file_data_sink : public data_sink {$/;"	c	file:
file_data_sink_impl	core/fstream.cc	/^    file_data_sink_impl(lw_shared_ptr<file> f, size_t buffer_size)$/;"	f	class:file_data_sink_impl
file_data_sink_impl	core/fstream.cc	/^class file_data_sink_impl : public data_sink_impl {$/;"	c	file:
file_data_source	core/fstream.cc	/^    file_data_source(lw_shared_ptr<file> f, uint64_t offset, size_t buffer_size)$/;"	f	class:file_data_source
file_data_source	core/fstream.cc	/^class file_data_source : public data_source {$/;"	c	file:
file_data_source_impl	core/fstream.cc	/^    file_data_source_impl(lw_shared_ptr<file> f, uint64_t pos, size_t buffer_size)$/;"	f	class:file_data_source_impl
file_data_source_impl	core/fstream.cc	/^class file_data_source_impl : public data_source_impl {$/;"	c	file:
kj_close	core/fstream.cc	/^    kj::Promise<void> kj_close() { return _file->kj_flush(); }$/;"	f	class:file_data_sink_impl
kj_do_get	core/fstream.cc	/^    kj::Promise<temporary_buffer<char>> kj_do_get() {$/;"	f	class:file_data_source_impl	file:
kj_put	core/fstream.cc	/^    kj::Promise<void> kj_put(net::packet data) { return kj::READY_NOW; }$/;"	f	class:file_data_sink_impl
make_file_input_stream	core/fstream.cc	/^input_stream<char> make_file_input_stream($/;"	f
make_file_output_stream	core/fstream.cc	/^output_stream<char> make_file_output_stream(lw_shared_ptr<file> f, size_t buffer_size) {$/;"	f
put	core/fstream.cc	/^    future<> put(net::packet data) { return make_ready_future<>(); }$/;"	f	class:file_data_sink_impl
arg	core/function_traits.hh	/^    struct arg$/;"	s	struct:function_traits
arity	core/function_traits.hh	/^    static constexpr std::size_t arity = sizeof...(Args);$/;"	m	struct:function_traits
function_traits	core/function_traits.hh	/^struct function_traits<Ret(Args...)>$/;"	s
CORE_FUTURE_UTIL_HH_	core/future-util.hh	24;"	d
_result	core/future-util.hh	/^    Result _result;$/;"	m	class:adder
adder	core/future-util.hh	/^class adder {$/;"	c
complete_when_all	core/future-util.hh	/^complete_when_all(std::vector<Future>&& futures, typename std::vector<Future>::iterator pos) {$/;"	f
do_for_each	core/future-util.hh	/^future<> do_for_each(Container& c, AsyncAction&& action) {$/;"	f
do_for_each	core/future-util.hh	/^future<> do_for_each(Iterator begin, Iterator end, AsyncAction&& action) {$/;"	f
do_until	core/future-util.hh	/^future<> do_until(StopCondition&& stop_cond, AsyncAction&& action) {$/;"	f
do_until_continued	core/future-util.hh	/^void do_until_continued(StopCondition&& stop_cond, AsyncAction&& action, promise<> p) {$/;"	f
do_when_all	core/future-util.hh	/^struct do_when_all {$/;"	s
get	core/future-util.hh	/^    Result get() && {$/;"	f	class:adder
keep_doing	core/future-util.hh	/^future<> keep_doing(AsyncAction&& action) {$/;"	f
kj_do_until	core/future-util.hh	/^kj::Promise<void> kj_do_until(StopCondition&& stop_cond, AsyncAction&& action) {$/;"	f
kj_do_until_continued	core/future-util.hh	/^void kj_do_until_continued(StopCondition&& stop_cond, AsyncAction&& action, kj::Own<kj::PromiseFulfiller<void>> fulfiller) {    $/;"	f
kj_keep_doing	core/future-util.hh	/^kj::Promise<void> kj_keep_doing(AsyncAction&& action) {$/;"	f
map_reduce	core/future-util.hh	/^map_reduce(Iterator begin, Iterator end, Mapper&& mapper, Initial initial, Reduce reduce) {$/;"	f
maybe_call_get	core/future-util.hh	/^    static future_type maybe_call_get(future<> f, lw_shared_ptr<T> r) {$/;"	f	struct:reducer_traits
maybe_call_get	core/future-util.hh	/^    static future_type maybe_call_get(future<> f, lw_shared_ptr<T> r) {$/;"	f	struct:reducer_with_get_traits
now	core/future-util.hh	/^future<> now() {$/;"	f
operator ()	core/future-util.hh	/^    future<> operator()(const Addend& value) {$/;"	f	class:adder
operator ()	core/future-util.hh	/^    future<std::tuple<Future...>> operator()(Future&&... fut) const {$/;"	f	struct:do_when_all
parallel_for_each	core/future-util.hh	/^parallel_for_each(Iterator begin, Iterator end, Func&& func) {$/;"	f
parallel_for_each	core/future-util.hh	/^parallel_for_each(Range&& range, Func&& func) {$/;"	f
reducer_traits	core/future-util.hh	/^struct reducer_traits {$/;"	s
reducer_traits	core/future-util.hh	/^struct reducer_traits<T, decltype(std::declval<T>().get(), void())> : public reducer_with_get_traits<T> {};$/;"	s
reducer_with_get_traits	core/future-util.hh	/^struct reducer_with_get_traits {$/;"	s
when_all	core/future-util.hh	/^when_all() {$/;"	f
when_all	core/future-util.hh	/^when_all(FutureIterator begin, FutureIterator end) {$/;"	f
when_all	core/future-util.hh	/^when_all(future<FutureArgs...>&& fut, Rest&&... rest) {$/;"	f
when_all_estimate_vector_capacity	core/future-util.hh	/^when_all_estimate_vector_capacity(Iterator begin, Iterator end, IteratorCategory category) {$/;"	f
when_all_estimate_vector_capacity	core/future-util.hh	/^when_all_estimate_vector_capacity(Iterator begin, Iterator end, std::forward_iterator_tag category) {$/;"	f
FUTURE_HH_	core/future.hh	23;"	d
KJ_DETACH	core/future.hh	946;"	d
_func	core/future.hh	/^    Func _func;$/;"	m	struct:final
_future	core/future.hh	/^    future<T...>* _future = nullptr;$/;"	m	class:promise
_local_state	core/future.hh	/^    future_state<T...> _local_state;  \/\/ valid if !_promise$/;"	m	class:future
_local_state	core/future.hh	/^    future_state<T...> _local_state;$/;"	m	class:promise
_promise	core/future.hh	/^    future(exception_future_marker, std::exception_ptr ex) noexcept : _promise(nullptr) {$/;"	f	class:future
_promise	core/future.hh	/^    future(promise<T...>* pr) noexcept : _promise(pr) {$/;"	f	class:future
_promise	core/future.hh	/^    promise<T...>* _promise;$/;"	m	class:future
_state	core/future.hh	/^    future_state<T...> _state;$/;"	m	struct:final
_state	core/future.hh	/^    future_state<T...>* _state;$/;"	m	class:promise
_state	core/future.hh	/^    } _state = state::future;$/;"	m	struct:future_state	typeref:class:future_state::state
_task	core/future.hh	/^    std::unique_ptr<task> _task;$/;"	m	class:promise
_u	core/future.hh	/^    } _u;$/;"	m	struct:future_state	typeref:union:future_state::any
any	core/future.hh	/^        any() { st = state::future; }$/;"	f	union:future_state::any
any	core/future.hh	/^        any() {}$/;"	f	union:future_state::any
any	core/future.hh	/^    union any {$/;"	u	struct:future_state
apply	core/future.hh	/^typename futurize<T>::type futurize<T>::apply(Func&& func, FuncArgs&&... args) {$/;"	f	class:futurize
apply	core/future.hh	/^typename futurize<T>::type futurize<T>::apply(Func&& func, std::tuple<FuncArgs...>&& args) {$/;"	f	class:futurize
apply	core/future.hh	/^typename futurize<future<Args...>>::type futurize<future<Args...>>::apply(Func&& func, FuncArgs&&... args) {$/;"	f	class:futurize
apply	core/future.hh	/^typename futurize<future<Args...>>::type futurize<future<Args...>>::apply(Func&& func, std::tuple<FuncArgs...>&& args) {$/;"	f	class:futurize
apply	core/future.hh	/^typename futurize<void>::type futurize<void>::apply(Func&& func, FuncArgs&&... args) {$/;"	f	class:futurize
apply	core/future.hh	/^typename futurize<void>::type futurize<void>::apply(Func&& func, std::tuple<FuncArgs...>&& args) {$/;"	f	class:futurize
continuation	core/future.hh	/^    continuation(Func&& func) : _func(std::move(func)) {}$/;"	f	struct:final
continuation	core/future.hh	/^    continuation(Func&& func, future_state<T...>&& state) : _state(std::move(state)), _func(std::move(func)) {}$/;"	f	struct:final
copy_noexcept	core/future.hh	/^    static constexpr bool copy_noexcept = future_state<T...>::copy_noexcept;$/;"	m	class:future
copy_noexcept	core/future.hh	/^    static constexpr bool copy_noexcept = future_state<T...>::copy_noexcept;$/;"	m	class:promise
copy_noexcept	core/future.hh	/^    static constexpr bool copy_noexcept = std::is_nothrow_copy_constructible<std::tuple<T...>>::value;$/;"	m	struct:future_state
copy_noexcept	core/future.hh	/^    static constexpr bool copy_noexcept = true;$/;"	m	struct:future_state
ex	core/future.hh	/^        std::exception_ptr ex;$/;"	m	union:future_state::any
exception	core/future.hh	/^         exception,$/;"	m	class:future_state::state
exception_future_marker	core/future.hh	/^struct exception_future_marker {};$/;"	s
exception_min	core/future.hh	/^         exception_min = 3,  \/\/ or anything greater$/;"	m	class:future_state::state
final	core/future.hh	/^struct continuation final : task {$/;"	s
future	core/future.hh	/^         future = 1,$/;"	m	class:future_state::state
future	core/future.hh	/^         future,$/;"	m	class:future_state::state
future	core/future.hh	/^    future(ready_future_from_tuple_marker, std::tuple<A...>&& data) : _promise(nullptr) {$/;"	f	class:future
future	core/future.hh	/^    future(ready_future_marker, A&&... a) : _promise(nullptr) {$/;"	f	class:future
future	core/future.hh	/^class future {$/;"	c
future_state	core/future.hh	/^struct future_state {$/;"	s
future_state	core/future.hh	/^struct future_state<> {$/;"	s
futurize	core/future.hh	/^struct futurize {$/;"	s
futurize	core/future.hh	/^struct futurize<future<Args...>> {$/;"	s
futurize	core/future.hh	/^struct futurize<void> {$/;"	s
get	core/future.hh	/^    std::tuple<> get() {$/;"	f	struct:future_state
get	core/future.hh	/^    std::tuple<T...> get() {$/;"	f	class:future
get	core/future.hh	/^    std::tuple<T...> get() {$/;"	f	struct:future_state
get0	core/future.hh	/^    static get0_return_type get0(std::tuple<>&&) {$/;"	f	struct:future_state
get0	core/future.hh	/^    static get0_return_type get0(std::tuple<T...>&& x) {$/;"	f	struct:future_state
get0	core/future.hh	/^    typename future_state<T...>::get0_return_type get0() {$/;"	f	class:future
get_available_state	core/future.hh	/^    future_state<T...> get_available_state() {$/;"	f	class:future
invalid	core/future.hh	/^         invalid = 0,$/;"	m	class:future_state::state
invalid	core/future.hh	/^         invalid,$/;"	m	class:future_state::state
is_future	core/future.hh	/^template <typename... T> struct is_future : std::false_type {};$/;"	s
is_future	core/future.hh	/^template <typename... T> struct is_future<future<T...>> : std::true_type {};$/;"	s
make_kj_promise	core/future.hh	/^inline kj::Promise< std::pair<T,V> > make_kj_promise(future<T,V>&& pm) {$/;"	f
make_kj_promise	core/future.hh	/^inline kj::Promise<T> make_kj_promise(future<T>&& pm) {$/;"	f
make_kj_promise	core/future.hh	/^inline kj::Promise<void> make_kj_promise(future<>&& pm) {$/;"	f
make_ready_future	core/future.hh	/^future<T...> make_ready_future(A&&... value) {$/;"	f
max_inlined_continuations	core/future.hh	/^static constexpr unsigned max_inlined_continuations = 1;$/;"	v
max_inlined_continuations	core/future.hh	/^static constexpr unsigned max_inlined_continuations = 256;$/;"	v
move	core/future.hh	/^            : _promise(nullptr), _local_state(std::move(state)) {$/;"	f	class:future
move_noexcept	core/future.hh	/^    static constexpr bool move_noexcept = future_state<T...>::move_noexcept;$/;"	m	class:future
move_noexcept	core/future.hh	/^    static constexpr bool move_noexcept = future_state<T...>::move_noexcept;$/;"	m	class:promise
move_noexcept	core/future.hh	/^    static constexpr bool move_noexcept = std::is_nothrow_move_constructible<std::tuple<T...>>::value;$/;"	m	struct:future_state
move_noexcept	core/future.hh	/^    static constexpr bool move_noexcept = true;$/;"	m	struct:future_state
noexcept	core/future.hh	/^    friend future<U...> make_exception_future(Exception&& ex) noexcept;$/;"	m	class:future
noexcept	core/future.hh	/^    friend future<U...> make_exception_future(std::exception_ptr ex) noexcept;$/;"	m	class:future
noexcept	core/future.hh	/^    future(future&& x) noexcept(move_noexcept) : _promise(x._promise) {$/;"	f	class:future
noexcept	core/future.hh	/^    future<T...> get_future() noexcept;$/;"	m	class:promise
noexcept	core/future.hh	/^    future_state& operator=(future_state&& x) noexcept(move_noexcept) {$/;"	f	struct:future_state
noexcept	core/future.hh	/^    future_state(future_state&& x) noexcept(move_noexcept)$/;"	f	struct:future_state
noexcept	core/future.hh	/^    promise& operator=(promise&& x) noexcept(move_noexcept) {$/;"	f	class:promise
noexcept	core/future.hh	/^    promise(promise&& x) noexcept(move_noexcept) : _future(x._future), _state(x._state), _task(std::move(x._task)) {$/;"	f	class:promise
noexcept	core/future.hh	/^    void forward_to(promise<>& pr) noexcept;$/;"	m	struct:future_state
noexcept	core/future.hh	/^    void make_ready() noexcept;$/;"	m	class:promise
noexcept	core/future.hh	/^    void migrated() noexcept;$/;"	m	class:promise
noexcept	core/future.hh	/^    void set(const std::tuple<T...>& value) noexcept(copy_noexcept) {$/;"	f	struct:future_state
noexcept	core/future.hh	/^    void set(std::tuple<T...>&& value) noexcept(move_noexcept) {$/;"	f	struct:future_state
noexcept	core/future.hh	/^    void set_value(const std::tuple<T...>& result) noexcept(copy_noexcept) {$/;"	f	class:promise
noexcept	core/future.hh	/^    void set_value(std::tuple<T...>&& result) noexcept(move_noexcept) {$/;"	f	class:promise
noexcept	core/future.hh	/^void promise<T...>::abandoned() noexcept(move_noexcept) {$/;"	f
promise	core/future.hh	/^class promise {$/;"	c
promise	core/future.hh	/^class promise<void> : public promise<> {};$/;"	c
ready_future_from_tuple_marker	core/future.hh	/^struct ready_future_from_tuple_marker {};$/;"	s
ready_future_marker	core/future.hh	/^struct ready_future_marker {};$/;"	s
result	core/future.hh	/^         result = 2,$/;"	m	class:future_state::state
result	core/future.hh	/^         result,$/;"	m	class:future_state::state
seastar	core/future.hh	/^namespace seastar {$/;"	n
set	core/future.hh	/^    void set() {$/;"	f	struct:future_state
set	core/future.hh	/^    void set(A&&... a) {$/;"	f	struct:future_state
sizeof	core/future.hh	/^    static_assert(sizeof(std::exception_ptr) == sizeof(void*), "exception_ptr not a pointer");$/;"	m	struct:future_state
st	core/future.hh	/^        state st;$/;"	m	union:future_state::any
state	core/future.hh	/^    enum class state : uintptr_t {$/;"	c	struct:future_state
state	core/future.hh	/^    enum class state {$/;"	c	struct:future_state
thread_impl	core/future.hh	/^namespace thread_impl {$/;"	n	namespace:seastar
value	core/future.hh	/^        std::tuple<T...> value;$/;"	m	union:future_state::any
wait	core/future.hh	/^    void wait() {$/;"	f	class:future
~any	core/future.hh	/^        ~any() {}$/;"	f	union:future_state::any
~future	core/future.hh	/^    ~future() {$/;"	f	class:future
consume	core/iostream-impl.hh	/^input_stream<CharType>::consume(Consumer& consumer) {$/;"	f	class:input_stream
flush	core/iostream-impl.hh	/^output_stream<CharType>::flush() {$/;"	f	class:output_stream
kj_consume	core/iostream-impl.hh	/^input_stream<CharType>::kj_consume(Consumer& consumer) {$/;"	f	class:input_stream
kj_flush	core/iostream-impl.hh	/^output_stream<CharType>::kj_flush() {    $/;"	f	class:output_stream
kj_read_exactly	core/iostream-impl.hh	/^input_stream<CharType>::kj_read_exactly(size_t n) {    $/;"	f	class:input_stream
kj_read_exactly_part	core/iostream-impl.hh	/^input_stream<CharType>::kj_read_exactly_part(size_t n, tmp_buf out, size_t completed) {$/;"	f	class:input_stream
kj_split_and_put	core/iostream-impl.hh	/^output_stream<CharType>::kj_split_and_put(temporary_buffer<CharType> buf) {$/;"	f	class:output_stream
kj_write	core/iostream-impl.hh	/^kj::Promise<void> output_stream<CharType>::kj_write(const basic_sstring<StringChar, SizeType, MaxSize>& s) {$/;"	f	class:output_stream
kj_write	core/iostream-impl.hh	/^kj::Promise<void> output_stream<CharType>::kj_write(const char_type* buf) {$/;"	f	class:output_stream
kj_write	core/iostream-impl.hh	/^kj::Promise<void> output_stream<CharType>::kj_write(const std::basic_string<CharType>& s) {$/;"	f	class:output_stream
kj_write	core/iostream-impl.hh	/^kj::Promise<void> output_stream<CharType>::kj_write(net::packet p) {$/;"	f	class:output_stream
kj_write	core/iostream-impl.hh	/^kj::Promise<void> output_stream<CharType>::kj_write(scattered_message<CharType> msg) {$/;"	f	class:output_stream
kj_write	core/iostream-impl.hh	/^output_stream<CharType>::kj_write(const char_type* buf, size_t n) {    $/;"	f	class:output_stream
read_exactly	core/iostream-impl.hh	/^input_stream<CharType>::read_exactly(size_t n) {$/;"	f	class:input_stream
read_exactly_part	core/iostream-impl.hh	/^input_stream<CharType>::read_exactly_part(size_t n, tmp_buf out, size_t completed) {$/;"	f	class:input_stream
split_and_put	core/iostream-impl.hh	/^output_stream<CharType>::split_and_put(temporary_buffer<CharType> buf) {$/;"	f	class:output_stream
write	core/iostream-impl.hh	/^future<> output_stream<CharType>::write(const basic_sstring<StringChar, SizeType, MaxSize>& s) {$/;"	f	class:output_stream
write	core/iostream-impl.hh	/^future<> output_stream<CharType>::write(const char_type* buf) {$/;"	f	class:output_stream
write	core/iostream-impl.hh	/^future<> output_stream<CharType>::write(const std::basic_string<CharType>& s) {$/;"	f	class:output_stream
write	core/iostream-impl.hh	/^future<> output_stream<CharType>::write(net::packet p) {$/;"	f	class:output_stream
write	core/iostream-impl.hh	/^future<> output_stream<CharType>::write(scattered_message<CharType> msg) {$/;"	f	class:output_stream
write	core/iostream-impl.hh	/^output_stream<CharType>::write(const char_type* buf, size_t n) {$/;"	f	class:output_stream
ConsumerConcept	core/iostream.hh	/^    struct ConsumerConcept {$/;"	s	class:final
IOV_MAX	core/iostream.hh	50;"	d
_begin	core/iostream.hh	/^    size_t _begin = 0;$/;"	m	class:final
_buf	core/iostream.hh	/^    temporary_buffer<CharType> _buf;$/;"	m	class:final
_dsi	core/iostream.hh	/^    std::unique_ptr<data_sink_impl> _dsi;$/;"	m	class:data_sink
_dsi	core/iostream.hh	/^    std::unique_ptr<data_source_impl> _dsi;$/;"	m	class:data_source
_end	core/iostream.hh	/^    size_t _end = 0;$/;"	m	class:final
_eof	core/iostream.hh	/^    bool _eof = false;$/;"	m	class:final
_fd	core/iostream.hh	/^    data_sink _fd;$/;"	m	class:final
_fd	core/iostream.hh	/^    data_source _fd;$/;"	m	class:final
_size	core/iostream.hh	/^    size_t _size = 0;$/;"	m	class:final
_trim_to_size	core/iostream.hh	/^    bool _trim_to_size = false;$/;"	m	class:final
allocate_buffer	core/iostream.hh	/^    temporary_buffer<char> allocate_buffer(size_t size) {$/;"	f	class:data_sink
allocate_buffer	core/iostream.hh	/^    virtual temporary_buffer<char> allocate_buffer(size_t size) {$/;"	f	class:data_sink_impl
available	core/iostream.hh	/^    size_t available() const { return _buf.size(); }$/;"	f	class:final
available	core/iostream.hh	/^    size_t available() const { return _end - _begin; }$/;"	f	class:final
close	core/iostream.hh	/^    future<> close() { return _dsi->close(); }$/;"	f	class:data_sink
close	core/iostream.hh	/^    future<> close() { return flush().then([this] { return _fd.close(); }); }$/;"	f	class:final
data_sink	core/iostream.hh	/^    explicit data_sink(std::unique_ptr<data_sink_impl> dsi) : _dsi(std::move(dsi)) {}$/;"	f	class:data_sink
data_sink	core/iostream.hh	/^class data_sink {$/;"	c
data_sink_impl	core/iostream.hh	/^class data_sink_impl {$/;"	c
data_source	core/iostream.hh	/^    explicit data_source(std::unique_ptr<data_source_impl> dsi) : _dsi(std::move(dsi)) {}$/;"	f	class:data_source
data_source	core/iostream.hh	/^class data_source {$/;"	c
data_source_impl	core/iostream.hh	/^class data_source_impl {$/;"	c
eof	core/iostream.hh	/^    bool eof() { return _eof; }$/;"	f	class:final
fd	core/iostream.hh	/^    data_source* fd() { return &_fd; }$/;"	f	class:final
final	core/iostream.hh	/^class input_stream final : public kj::AsyncInputStream {$/;"	c
final	core/iostream.hh	/^class output_stream final : public kj::AsyncOutputStream {$/;"	c
get	core/iostream.hh	/^    future<temporary_buffer<char>> get() { return _dsi->get(); }$/;"	f	class:data_source
impl	core/iostream.hh	/^    data_source_impl* impl() const { return _dsi.get(); }$/;"	f	class:data_source
input_stream	core/iostream.hh	/^    explicit input_stream(data_source fd) : _fd(std::move(fd)), _buf(0) {}$/;"	f	class:final
kj_close	core/iostream.hh	/^    kj::Promise<void> kj_close() { return _dsi->kj_close(); }$/;"	f	class:data_sink
kj_close	core/iostream.hh	/^    kj::Promise<void> kj_close() { return kj_flush().then([this] { return _fd.kj_close(); }); }$/;"	f	class:final
kj_get	core/iostream.hh	/^    kj::Promise<temporary_buffer<char>> kj_get(size_t maxBytes = 8192) {$/;"	f	class:data_source
kj_put	core/iostream.hh	/^    kj::Promise<void> kj_put(net::packet p) {$/;"	f	class:data_sink
kj_put	core/iostream.hh	/^    kj::Promise<void> kj_put(std::vector<temporary_buffer<char>> data) {$/;"	f	class:data_sink
kj_put	core/iostream.hh	/^    kj::Promise<void> kj_put(temporary_buffer<char> data) {$/;"	f	class:data_sink
kj_put	core/iostream.hh	/^    virtual kj::Promise<void> kj_put(std::vector<temporary_buffer<char>> data) {$/;"	f	class:data_sink_impl
kj_put	core/iostream.hh	/^    virtual kj::Promise<void> kj_put(temporary_buffer<char> buf) {$/;"	f	class:data_sink_impl
net	core/iostream.hh	/^namespace net { class packet; }$/;"	n
output_stream	core/iostream.hh	/^    output_stream(data_sink fd, size_t size, bool trim_to_size = false)$/;"	f	class:final
possibly_available	core/iostream.hh	/^    size_t possibly_available() const { return _size - _begin; }$/;"	f	class:final
put	core/iostream.hh	/^    future<> put(net::packet p) {$/;"	f	class:data_sink
put	core/iostream.hh	/^    future<> put(std::vector<temporary_buffer<char>> data) {$/;"	f	class:data_sink
put	core/iostream.hh	/^    future<> put(temporary_buffer<char> data) {$/;"	f	class:data_sink
put	core/iostream.hh	/^    virtual future<> put(std::vector<temporary_buffer<char>> data) {$/;"	f	class:data_sink_impl
put	core/iostream.hh	/^    virtual future<> put(temporary_buffer<char> buf) {$/;"	f	class:data_sink_impl
reset	core/iostream.hh	/^    void reset() { _buf = {}; }$/;"	f	class:final
setBuffer	core/iostream.hh	/^    void setBuffer(temporary_buffer<char> && buf){$/;"	f	class:data_source
tryReadInternal	core/iostream.hh	/^    kj::Promise<size_t> tryReadInternal(void* buffer, size_t minBytes, size_t maxBytes,$/;"	f	class:final
writeInternal	core/iostream.hh	/^    kj::Promise<void> writeInternal(kj::ArrayPtr<const kj::byte> firstPiece,$/;"	f	class:final
x	core/iostream.hh	/^    data_sink& operator=(data_sink&& x) = default;$/;"	m	class:data_sink
x	core/iostream.hh	/^    data_sink(data_sink&& x) = default;$/;"	m	class:data_sink
x	core/iostream.hh	/^    data_source& operator=(data_source&& x) = default;$/;"	m	class:data_source
x	core/iostream.hh	/^    data_source(data_source&& x) = default;$/;"	m	class:data_source
~data_sink_impl	core/iostream.hh	/^    virtual ~data_sink_impl() {}$/;"	f	class:data_sink_impl
~data_source_impl	core/iostream.hh	/^    virtual ~data_source_impl() {}$/;"	f	class:data_source_impl
_back	core/memory.cc	/^    uint32_t _back = 0;$/;"	m	class:memory::page_list	file:
_free	core/memory.cc	/^    free_object* _free = nullptr;$/;"	m	class:memory::small_pool	file:
_free_count	core/memory.cc	/^    size_t _free_count = 0;$/;"	m	class:memory::small_pool	file:
_front	core/memory.cc	/^    uint32_t _front = 0;$/;"	m	class:memory::page_list	file:
_max_free	core/memory.cc	/^    unsigned _max_free;$/;"	m	class:memory::small_pool	file:
_min_free	core/memory.cc	/^    unsigned _min_free;$/;"	m	class:memory::small_pool	file:
_next	core/memory.cc	/^    uint32_t _next;$/;"	m	class:memory::page_list_link	file:
_object_size	core/memory.cc	/^    unsigned _object_size;$/;"	m	class:memory::small_pool	file:
_prev	core/memory.cc	/^    uint32_t _prev;$/;"	m	class:memory::page_list_link	file:
_span_list	core/memory.cc	/^    page_list _span_list;$/;"	m	class:memory::small_pool	file:
_span_size	core/memory.cc	/^    unsigned _span_size;$/;"	m	class:memory::small_pool	file:
_u	core/memory.cc	/^    } _u;$/;"	m	class:memory::small_pool_array	typeref:union:memory::small_pool_array::u	file:
a	core/memory.cc	/^        small_pool a[nr_small_pools];$/;"	m	union:memory::small_pool_array::u	file:
add_more_objects	core/memory.cc	/^small_pool::add_more_objects() {$/;"	f	class:memory::small_pool
aligned_alloc	core/memory.cc	/^void *aligned_alloc(size_t align, size_t size) {$/;"	f
all_cpus	core/memory.cc	/^    static cpu_pages* all_cpus[max_cpus];$/;"	m	struct:memory::cpu_pages	file:
all_cpus	core/memory.cc	/^cpu_pages* cpu_pages::all_cpus[max_cpus];$/;"	m	class:memory::cpu_pages	file:
allocate	core/memory.cc	/^small_pool::allocate() {$/;"	f	class:memory::small_pool
allocate	core/memory.cc	/^void* allocate(size_t size) {$/;"	f	namespace:memory
allocate_aligned	core/memory.cc	/^void* allocate_aligned(size_t align, size_t size) {$/;"	f	namespace:memory
allocate_anonymous_memory	core/memory.cc	/^allocate_anonymous_memory(optional<void*> where, size_t how_much) {$/;"	f	namespace:memory
allocate_hugetlbfs_memory	core/memory.cc	/^allocate_hugetlbfs_memory(file_desc& fd, optional<void*> where, size_t how_much) {$/;"	f	namespace:memory
allocate_large	core/memory.cc	/^cpu_pages::allocate_large(unsigned n_pages) {$/;"	f	class:memory::cpu_pages
allocate_large	core/memory.cc	/^void* allocate_large(size_t size) {$/;"	f	namespace:memory
allocate_large_aligned	core/memory.cc	/^cpu_pages::allocate_large_aligned(unsigned align_pages, unsigned n_pages) {$/;"	f	class:memory::cpu_pages
allocate_large_aligned	core/memory.cc	/^void* allocate_large_aligned(size_t align, size_t size) {$/;"	f	namespace:memory
allocate_large_and_trim	core/memory.cc	/^cpu_pages::allocate_large_and_trim(unsigned n_pages, Trimmer trimmer) {$/;"	f	class:memory::cpu_pages
allocate_small	core/memory.cc	/^cpu_pages::allocate_small(unsigned size) {$/;"	f	class:memory::cpu_pages
back	core/memory.cc	/^    page& back(page* ary) { return ary[_back]; }$/;"	f	class:memory::page_list
cache_line_size	core/memory.cc	/^static constexpr size_t cache_line_size = 64;$/;"	m	namespace:memory	file:
calloc	core/memory.cc	/^void* calloc(size_t nmemb, size_t size) {$/;"	f
cfree	core/memory.cc	/^void cfree(void* obj) {$/;"	f
configure	core/memory.cc	/^void configure(std::vector<resource::memory> m, std::experimental::optional<std::string> hugepages_path) {$/;"	f	namespace:memory
configure	core/memory.cc	/^void configure(std::vector<resource::memory> m,$/;"	f	namespace:memory
cpu_id	core/memory.cc	/^    unsigned cpu_id = -1U;$/;"	m	struct:memory::cpu_pages	file:
cpu_id_gen	core/memory.cc	/^    static std::atomic<unsigned> cpu_id_gen;$/;"	m	struct:memory::cpu_pages	file:
cpu_id_gen	core/memory.cc	/^std::atomic<unsigned> cpu_pages::cpu_id_gen;$/;"	m	class:memory::cpu_pages	file:
cpu_id_shift	core/memory.cc	/^static constexpr unsigned cpu_id_shift = 36; \/\/ FIXME: make dynamic$/;"	m	namespace:memory	file:
cpu_mem	core/memory.cc	/^static thread_local cpu_pages cpu_mem;$/;"	m	namespace:memory	file:
cpu_pages	core/memory.cc	/^struct cpu_pages {$/;"	s	namespace:memory	file:
cross_cpu_free_item	core/memory.cc	/^struct cross_cpu_free_item {$/;"	s	namespace:memory	file:
current_min_free_pages	core/memory.cc	/^    uint32_t current_min_free_pages = 0;$/;"	m	struct:memory::cpu_pages	file:
deallocate	core/memory.cc	/^small_pool::deallocate(void* object) {$/;"	f	class:memory::small_pool
do_resize	core/memory.cc	/^void cpu_pages::do_resize(size_t new_size, allocate_system_memory_fn alloc_sys_mem) {$/;"	f	class:memory::cpu_pages
drain_cross_cpu_freelist	core/memory.cc	/^bool cpu_pages::drain_cross_cpu_freelist() {$/;"	f	class:memory::cpu_pages
drain_cross_cpu_freelist	core/memory.cc	/^bool drain_cross_cpu_freelist() {$/;"	f	namespace:memory
empty	core/memory.cc	/^    bool empty() const { return !_front; }$/;"	f	class:memory::page_list
erase	core/memory.cc	/^    void erase(page* ary, page& span) {$/;"	f	class:memory::page_list
free	core/memory.cc	/^    bool free;$/;"	m	struct:memory::page	file:
free	core/memory.cc	/^void cpu_pages::free(void* ptr) {$/;"	f	class:memory::cpu_pages
free	core/memory.cc	/^void cpu_pages::free(void* ptr, size_t size) {$/;"	f	class:memory::cpu_pages
free	core/memory.cc	/^void free(void* obj) {$/;"	f	namespace:memory
free	core/memory.cc	/^void free(void* obj, size_t size) {$/;"	f	namespace:memory
free	core/memory.cc	/^void free(void* ptr) {$/;"	f
free_cross_cpu	core/memory.cc	/^void cpu_pages::free_cross_cpu(unsigned cpu_id, void* ptr) {$/;"	f	class:memory::cpu_pages
free_large	core/memory.cc	/^void cpu_pages::free_large(void* ptr) {$/;"	f	class:memory::cpu_pages
free_large	core/memory.cc	/^void free_large(void* ptr) {$/;"	f	namespace:memory
free_object	core/memory.cc	/^struct free_object {$/;"	s	namespace:memory	file:
free_span	core/memory.cc	/^void cpu_pages::free_span(uint32_t span_start, uint32_t nr_pages) {$/;"	f	class:memory::cpu_pages
free_span_no_merge	core/memory.cc	/^void cpu_pages::free_span_no_merge(uint32_t span_start, uint32_t nr_pages) {$/;"	f	class:memory::cpu_pages
free_spans	core/memory.cc	/^        page_list free_spans[nr_span_lists];  \/\/ contains spans with span_size >= 2^idx$/;"	m	union:memory::cpu_pages::pla	file:
freelist	core/memory.cc	/^    free_object* freelist;$/;"	m	struct:memory::page	file:
front	core/memory.cc	/^    page& front(page* ary) { return ary[_front]; }$/;"	f	class:memory::page_list
fsu	core/memory.cc	/^    } fsu;$/;"	m	struct:memory::cpu_pages	typeref:union:memory::cpu_pages::pla	file:
g_allocs	core/memory.cc	/^static thread_local uint64_t g_allocs;$/;"	m	namespace:memory	file:
g_cross_cpu_frees	core/memory.cc	/^static thread_local uint64_t g_cross_cpu_frees;$/;"	m	namespace:memory	file:
g_frees	core/memory.cc	/^static thread_local uint64_t g_frees;$/;"	m	namespace:memory	file:
idx_frac_bits	core/memory.cc	/^    static constexpr unsigned idx_frac_bits = 2;$/;"	m	class:memory::small_pool	file:
idx_to_size	core/memory.cc	/^small_pool::idx_to_size(unsigned idx) {$/;"	f	class:memory::small_pool
index_of	core/memory.cc	/^unsigned index_of(unsigned pages) {$/;"	f	namespace:memory
index_of_conservative	core/memory.cc	/^unsigned index_of_conservative(unsigned pages) {$/;"	f	namespace:memory
init_virt_to_phys_map	core/memory.cc	/^void cpu_pages::init_virt_to_phys_map() {$/;"	f	class:memory::cpu_pages
initialize	core/memory.cc	/^bool cpu_pages::initialize() {$/;"	f	class:memory::cpu_pages
link	core/memory.cc	/^    page_list_link link;$/;"	m	struct:memory::page	file:
link	core/memory.cc	/^cpu_pages::link(page_list& list, page* span) {$/;"	f	class:memory::cpu_pages
log2	core/memory.cc	/^static constexpr unsigned log2(unsigned n) {$/;"	f	namespace:memory
malloc	core/memory.cc	/^void* malloc(size_t n) throw () {$/;"	f
malloc_trim	core/memory.cc	/^int malloc_trim(size_t pad) {$/;"	f
malloc_usable_size	core/memory.cc	/^size_t malloc_usable_size(void* obj) {$/;"	f
max_cpus	core/memory.cc	/^static constexpr unsigned max_cpus = 256;$/;"	m	namespace:memory	file:
max_small_allocation	core/memory.cc	/^static constexpr size_t max_small_allocation$/;"	m	namespace:memory	file:
mem	core/memory.cc	/^    char* mem() { return memory; }$/;"	f	struct:memory::cpu_pages
mem_base	core/memory.cc	/^static char* mem_base() {$/;"	f	namespace:memory
memalign	core/memory.cc	/^void* memalign(size_t align, size_t size) {$/;"	f
memory	core/memory.cc	/^    char* memory;$/;"	m	struct:memory::cpu_pages	file:
memory	core/memory.cc	/^namespace memory {$/;"	n	file:
min_free_pages	core/memory.cc	/^    static constexpr unsigned min_free_pages = 20000000 \/ page_size;$/;"	m	struct:memory::cpu_pages	file:
next	core/memory.cc	/^    cross_cpu_free_item* next;$/;"	m	struct:memory::cross_cpu_free_item	file:
next	core/memory.cc	/^    free_object* next;$/;"	m	struct:memory::free_object	file:
noexcept	core/memory.cc	/^    explicit small_pool(unsigned object_size) noexcept;$/;"	m	class:memory::small_pool	file:
nr_free_pages	core/memory.cc	/^    uint32_t nr_free_pages;$/;"	m	struct:memory::cpu_pages	file:
nr_pages	core/memory.cc	/^        unsigned nr_pages;$/;"	m	struct:memory::cpu_pages::trim	file:
nr_pages	core/memory.cc	/^    uint32_t nr_pages;$/;"	m	struct:memory::cpu_pages	file:
nr_small_alloc	core/memory.cc	/^    uint16_t nr_small_alloc;$/;"	m	struct:memory::page	file:
nr_small_pools	core/memory.cc	/^    static constexpr unsigned nr_small_pools = small_pool::size_to_idx(4 * page_size) + 1;$/;"	m	class:memory::small_pool_array	file:
nr_span_lists	core/memory.cc	/^    static constexpr unsigned nr_span_lists = 32;$/;"	m	struct:memory::cpu_pages	file:
object_cpu_id	core/memory.cc	/^unsigned object_cpu_id(const void* ptr) {$/;"	f	namespace:memory
object_size	core/memory.cc	/^    unsigned object_size() const { return _object_size; }$/;"	f	class:memory::small_pool
object_size	core/memory.cc	/^size_t cpu_pages::object_size(void* ptr) {$/;"	f	class:memory::cpu_pages
object_size	core/memory.cc	/^size_t object_size(void* ptr) {$/;"	f	namespace:memory
offset	core/memory.cc	/^        unsigned offset;$/;"	m	struct:memory::cpu_pages::trim	file:
offset_in_span	core/memory.cc	/^    uint8_t offset_in_span;$/;"	m	struct:memory::page	file:
operator []	core/memory.cc	/^    small_pool& operator[](unsigned idx) { return _u.a[idx]; }$/;"	f	class:memory::small_pool_array
operator delete	core/memory.cc	/^void operator delete(void* ptr) throw () {$/;"	f
operator delete	core/memory.cc	/^void operator delete(void* ptr, size_t size) throw () {$/;"	f
operator delete	core/memory.cc	/^void operator delete(void* ptr, size_t size, std::nothrow_t) throw () {$/;"	f
operator delete	core/memory.cc	/^void operator delete(void* ptr, std::nothrow_t) throw () {$/;"	f
operator delete	core/memory.cc	/^void operator delete(void* ptr, with_alignment wa) {$/;"	f
operator delete[]	core/memory.cc	/^void operator delete[](void* ptr) throw () {$/;"	f
operator delete[]	core/memory.cc	/^void operator delete[](void* ptr, size_t size) throw () {$/;"	f
operator delete[]	core/memory.cc	/^void operator delete[](void* ptr, size_t size, std::nothrow_t) throw () {$/;"	f
operator delete[]	core/memory.cc	/^void operator delete[](void* ptr, std::nothrow_t) throw () {$/;"	f
operator delete[]	core/memory.cc	/^void operator delete[](void* ptr, with_alignment wa) {$/;"	f
operator new	core/memory.cc	/^void* operator new(size_t size) {$/;"	f
operator new	core/memory.cc	/^void* operator new(size_t size, std::nothrow_t) throw () {$/;"	f
operator new	core/memory.cc	/^void* operator new(size_t size, with_alignment wa) {$/;"	f
operator new[]	core/memory.cc	/^void* operator new[](size_t size) {$/;"	f
operator new[]	core/memory.cc	/^void* operator new[](size_t size, std::nothrow_t) throw () {$/;"	f
operator new[]	core/memory.cc	/^void* operator new[](size_t size, with_alignment wa) {$/;"	f
page	core/memory.cc	/^struct page {$/;"	s	namespace:memory	file:
page_list	core/memory.cc	/^class page_list {$/;"	c	namespace:memory	file:
page_list_link	core/memory.cc	/^class page_list_link {$/;"	c	namespace:memory	file:
pages	core/memory.cc	/^    page* pages;$/;"	m	struct:memory::cpu_pages	file:
pla	core/memory.cc	/^        pla() {$/;"	f	union:memory::cpu_pages::pla
pla	core/memory.cc	/^    union pla {$/;"	u	struct:memory::cpu_pages	file:
pool	core/memory.cc	/^    small_pool* pool;  \/\/ if used in a small_pool$/;"	m	struct:memory::page	file:
pop_front	core/memory.cc	/^    void pop_front(page* ary) {$/;"	f	class:memory::page_list
posix_memalign	core/memory.cc	/^int posix_memalign(void** ptr, size_t align, size_t size) {$/;"	f
push_front	core/memory.cc	/^    void push_front(page* ary, page& span) {$/;"	f	class:memory::page_list
realloc	core/memory.cc	/^void* realloc(void* ptr, size_t size) {$/;"	f
reclaim	core/memory.cc	/^void cpu_pages::reclaim() {$/;"	f	class:memory::cpu_pages
reclaim_hook	core/memory.cc	/^    std::function<void (std::function<void ()>)> reclaim_hook;$/;"	m	struct:memory::cpu_pages	file:
reclaimer	core/memory.cc	/^reclaimer::reclaimer(std::function<void ()> reclaim) {$/;"	f	class:memory::reclaimer
reclaimer	core/memory.cc	/^reclaimer::reclaimer(std::function<void ()> reclaim)$/;"	f	class:memory::reclaimer
reclaimers	core/memory.cc	/^    std::vector<reclaimer*> reclaimers;$/;"	m	struct:memory::cpu_pages	file:
replace_memory_backing	core/memory.cc	/^void cpu_pages::replace_memory_backing(allocate_system_memory_fn alloc_sys_mem) {$/;"	f	class:memory::cpu_pages
resize	core/memory.cc	/^void cpu_pages::resize(size_t new_size, allocate_system_memory_fn alloc_memory) {$/;"	f	class:memory::cpu_pages
set_reclaim_hook	core/memory.cc	/^void cpu_pages::set_reclaim_hook(std::function<void (std::function<void ()>)> hook) {$/;"	f	class:memory::cpu_pages
set_reclaim_hook	core/memory.cc	/^void set_reclaim_hook(std::function<void (std::function<void ()>)> hook) {$/;"	f	namespace:memory
size_to_idx	core/memory.cc	/^small_pool::size_to_idx(unsigned size) {$/;"	f	class:memory::small_pool
small_pool	core/memory.cc	/^class small_pool {$/;"	c	namespace:memory	file:
small_pool_array	core/memory.cc	/^class small_pool_array {$/;"	c	namespace:memory	file:
small_pools	core/memory.cc	/^    small_pool_array small_pools;$/;"	m	struct:memory::cpu_pages	file:
span_bytes	core/memory.cc	/^    size_t span_bytes() const { return _span_size * page_size; }$/;"	f	class:memory::small_pool	file:
span_size	core/memory.cc	/^    uint32_t span_size; \/\/ in pages, if we're the head or the tail$/;"	m	struct:memory::page	file:
stats	core/memory.cc	/^statistics stats() {$/;"	f	namespace:memory
to_page	core/memory.cc	/^    page* to_page(void* p) {$/;"	f	struct:memory::cpu_pages
translate	core/memory.cc	/^cpu_pages::translate(const void* addr, size_t size) {$/;"	f	class:memory::cpu_pages
translate	core/memory.cc	/^translate(const void* addr, size_t size) {$/;"	f	namespace:memory
trim	core/memory.cc	/^    struct trim {$/;"	s	struct:memory::cpu_pages	file:
trim_free_list	core/memory.cc	/^small_pool::trim_free_list() {$/;"	f	class:memory::small_pool
u	core/memory.cc	/^        u() {$/;"	f	union:memory::small_pool_array::u
u	core/memory.cc	/^    union u {$/;"	u	class:memory::small_pool_array	file:
unlink	core/memory.cc	/^cpu_pages::unlink(page_list& list, page* span) {$/;"	f	class:memory::cpu_pages
virt_to_phys_map	core/memory.cc	/^    alignas(cache_line_size) std::vector<physical_address> virt_to_phys_map;$/;"	m	struct:memory::cpu_pages	file:
waste	core/memory.cc	/^float small_pool::waste() {$/;"	f	class:memory::small_pool
xcpu_freelist	core/memory.cc	/^    alignas(cache_line_size) std::atomic<cross_cpu_free_item*> xcpu_freelist;$/;"	m	struct:memory::cpu_pages	file:
~pla	core/memory.cc	/^        ~pla() {$/;"	f	union:memory::cpu_pages::pla
~reclaimer	core/memory.cc	/^reclaimer::~reclaimer() {$/;"	f	class:memory::reclaimer
~small_pool	core/memory.cc	/^small_pool::~small_pool() {$/;"	f	class:memory::small_pool
~u	core/memory.cc	/^        ~u() {$/;"	f	union:memory::small_pool_array::u
MEMORY_HH_	core/memory.hh	23;"	d
_align	core/memory.hh	/^    size_t _align;$/;"	m	class:with_alignment
_cross_cpu_frees	core/memory.hh	/^    uint64_t _cross_cpu_frees;$/;"	m	class:memory::statistics
_frees	core/memory.hh	/^    uint64_t _frees;$/;"	m	class:memory::statistics
_mallocs	core/memory.hh	/^    uint64_t _mallocs;$/;"	m	class:memory::statistics
_reclaim	core/memory.hh	/^    std::function<void ()> _reclaim;$/;"	m	class:memory::reclaimer
addr	core/memory.hh	/^    physical_address addr = 0;$/;"	m	struct:memory::translation
aligned_allocator	core/memory.hh	/^class aligned_allocator {$/;"	c
alignment	core/memory.hh	/^    size_t alignment() const { return _align; }$/;"	f	class:with_alignment
allocate	core/memory.hh	/^    T* allocate(size_t n) const {$/;"	f	class:aligned_allocator
cross_cpu_frees	core/memory.hh	/^    uint64_t cross_cpu_frees() const { return _cross_cpu_frees; }$/;"	f	class:memory::statistics
deallocate	core/memory.hh	/^    void deallocate(T* ptr) const {$/;"	f	class:aligned_allocator
do_reclaim	core/memory.hh	/^    void do_reclaim() { _reclaim(); }$/;"	f	class:memory::reclaimer
frees	core/memory.hh	/^    uint64_t frees() const { return _frees; }$/;"	f	class:memory::statistics
huge_page_size	core/memory.hh	/^static constexpr size_t huge_page_size = 512 * page_size; \/\/ 2M$/;"	m	namespace:memory
live_objects	core/memory.hh	/^    size_t live_objects() const { return mallocs() - frees(); }$/;"	f	class:memory::statistics
mallocs	core/memory.hh	/^    uint64_t mallocs() const { return _mallocs; }$/;"	f	class:memory::statistics
memory	core/memory.hh	/^namespace memory {$/;"	n
operator !=	core/memory.hh	/^    bool operator!=(const aligned_allocator& x) const {$/;"	f	class:aligned_allocator
operator ==	core/memory.hh	/^    bool operator==(const aligned_allocator& x) const {$/;"	f	class:aligned_allocator
page_bits	core/memory.hh	/^static constexpr size_t page_bits = 12;$/;"	m	namespace:memory
page_size	core/memory.hh	/^static constexpr size_t page_size = 1 << page_bits;       \/\/ 4K$/;"	m	namespace:memory
reclaimer	core/memory.hh	/^class reclaimer {$/;"	c	namespace:memory
size	core/memory.hh	/^    size_t size = 0;$/;"	m	struct:memory::translation
statistics	core/memory.hh	/^    statistics(uint64_t mallocs, uint64_t frees, uint64_t cross_cpu_frees)$/;"	f	class:memory::statistics
statistics	core/memory.hh	/^class statistics {$/;"	c	namespace:memory
translation	core/memory.hh	/^    translation(physical_address a, size_t s) : addr(a), size(s) {}$/;"	f	struct:memory::translation
translation	core/memory.hh	/^struct translation {$/;"	s	namespace:memory
with_alignment	core/memory.hh	/^    with_alignment(size_t align) : _align(align) {}$/;"	f	class:with_alignment
with_alignment	core/memory.hh	/^class with_alignment {$/;"	c
join	core/posix.cc	/^void posix_thread::join() {$/;"	f	class:posix_thread
mmap_anonymous	core/posix.cc	/^mmap_area mmap_anonymous(void* addr, size_t length, int prot, int flags) {$/;"	f
operator ()	core/posix.cc	/^void mmap_deleter::operator()(void* ptr) const {$/;"	f	class:mmap_deleter
pin_this_thread	core/posix.cc	/^void pin_this_thread(unsigned cpu_id) {$/;"	f
posix_thread	core/posix.cc	/^posix_thread::posix_thread(attr a, std::function<void ()> func)$/;"	f	class:posix_thread
posix_thread	core/posix.cc	/^posix_thread::posix_thread(posix_thread&& x)$/;"	f	class:posix_thread
posix_thread	core/posix.cc	/^posix_thread::posix_thread(std::function<void ()> func)$/;"	f	class:posix_thread
start_routine	core/posix.cc	/^void* posix_thread::start_routine(void* arg) {$/;"	f	class:posix_thread
temporary	core/posix.cc	/^file_desc::temporary(sstring directory) {$/;"	f	class:file_desc
~posix_thread	core/posix.cc	/^posix_thread::~posix_thread() {$/;"	f	class:posix_thread
FILE_DESC_HH_	core/posix.hh	23;"	d
_fd	core/posix.hh	/^    int _fd;$/;"	m	class:file_desc
_func	core/posix.hh	/^    std::unique_ptr<std::function<void ()>> _func;$/;"	m	class:posix_thread
_pthread	core/posix.hh	/^    pthread_t _pthread;$/;"	m	class:posix_thread
_size	core/posix.hh	/^    size_t _size;$/;"	m	struct:mmap_deleter
_stack	core/posix.hh	/^    mmap_area _stack;$/;"	m	class:posix_thread
_stack_size	core/posix.hh	/^        stack_size _stack_size;$/;"	m	class:posix_thread::attr
_valid	core/posix.hh	/^    bool _valid = true;$/;"	m	class:posix_thread
accept	core/posix.hh	/^    file_desc accept(sockaddr& sa, socklen_t& sl, int flags = 0) {$/;"	f	class:file_desc
attr	core/posix.hh	/^        attr(A... a) {$/;"	f	class:posix_thread::attr
attr	core/posix.hh	/^    class attr {$/;"	c	class:posix_thread
bind	core/posix.hh	/^    void bind(sockaddr& sa, socklen_t sl) {$/;"	f	class:file_desc
close	core/posix.hh	/^    void close() {$/;"	f	class:file_desc
connect	core/posix.hh	/^    void connect(sockaddr& sa, socklen_t sl) {$/;"	f	class:file_desc
dup	core/posix.hh	/^    file_desc dup() const {$/;"	f	class:file_desc
epoll_create	core/posix.hh	/^    static file_desc epoll_create(int flags = 0) {$/;"	f	class:file_desc
eventfd	core/posix.hh	/^    static file_desc eventfd(unsigned initval, int flags) {$/;"	f	class:file_desc
file_desc	core/posix.hh	/^    file_desc(file_desc&& x) : _fd(x._fd) { x._fd = -1; }$/;"	f	class:file_desc
file_desc	core/posix.hh	/^    file_desc(int fd) : _fd(fd) {}$/;"	f	class:file_desc
file_desc	core/posix.hh	/^class file_desc {$/;"	c
get	core/posix.hh	/^    int get() const { return _fd; }$/;"	f	class:file_desc
get_address	core/posix.hh	/^    socket_address get_address() {$/;"	f	class:file_desc
getsockopt	core/posix.hh	/^    int getsockopt(int level, int optname, X&& data) {$/;"	f	class:file_desc
getsockopt	core/posix.hh	/^    int getsockopt(int level, int optname, char* data, socklen_t len) {$/;"	f	class:file_desc
ioctl	core/posix.hh	/^    int ioctl(int request) {$/;"	f	class:file_desc
ioctl	core/posix.hh	/^    int ioctl(int request, X& data) {$/;"	f	class:file_desc
ioctl	core/posix.hh	/^    int ioctl(int request, X&& data) {$/;"	f	class:file_desc
ioctl	core/posix.hh	/^    int ioctl(int request, int value) {$/;"	f	class:file_desc
ioctl	core/posix.hh	/^    int ioctl(int request, unsigned int value) {$/;"	f	class:file_desc
listen	core/posix.hh	/^    void listen(int backlog) {$/;"	f	class:file_desc
make_empty_sigset_mask	core/posix.hh	/^sigset_t make_empty_sigset_mask() {$/;"	f
make_full_sigset_mask	core/posix.hh	/^sigset_t make_full_sigset_mask() {$/;"	f
make_sigset_mask	core/posix.hh	/^sigset_t make_sigset_mask(int signo) {$/;"	f
map	core/posix.hh	/^    mmap_area map(size_t size, unsigned prot, unsigned flags, size_t offset,$/;"	f	class:file_desc
map_private_ro	core/posix.hh	/^    mmap_area map_private_ro(size_t size, size_t offset) {$/;"	f	class:file_desc
map_private_rw	core/posix.hh	/^    mmap_area map_private_rw(size_t size, size_t offset) {$/;"	f	class:file_desc
map_shared_ro	core/posix.hh	/^    mmap_area map_shared_ro(size_t size, size_t offset) {$/;"	f	class:file_desc
map_shared_rw	core/posix.hh	/^    mmap_area map_shared_rw(size_t size, size_t offset) {$/;"	f	class:file_desc
mmap_deleter	core/posix.hh	/^struct mmap_deleter {$/;"	s
open	core/posix.hh	/^    static file_desc open(sstring name, int flags, mode_t mode = 0) {$/;"	f	class:file_desc
operator =	core/posix.hh	/^    file_desc& operator=(file_desc&& x) {$/;"	f	class:file_desc
posix_thread	core/posix.hh	/^class posix_thread {$/;"	c
pread	core/posix.hh	/^    size_t pread(void* buf, size_t len, off_t off) {$/;"	f	class:file_desc
read	core/posix.hh	/^    boost::optional<size_t> read(void* buffer, size_t len) {$/;"	f	class:file_desc
recv	core/posix.hh	/^    boost::optional<ssize_t> recv(void* buffer, size_t len, int flags) {$/;"	f	class:file_desc
recvmsg	core/posix.hh	/^    boost::optional<size_t> recvmsg(msghdr* mh, int flags) {$/;"	f	class:file_desc
send	core/posix.hh	/^    boost::optional<size_t> send(const void* buffer, size_t len, int flags) {        $/;"	f	class:file_desc
sendmsg	core/posix.hh	/^    boost::optional<size_t> sendmsg(const msghdr* msg, int flags) {$/;"	f	class:file_desc
sendto	core/posix.hh	/^    boost::optional<size_t> sendto(socket_address& addr, const void* buf, size_t len, int flags) {$/;"	f	class:file_desc
set	core/posix.hh	/^        void set() {}$/;"	f	class:posix_thread::attr
set	core/posix.hh	/^        void set(A a, Rest... rest) {$/;"	f	class:posix_thread::attr
set	core/posix.hh	/^        void set(stack_size ss) { _stack_size = ss; }$/;"	f	class:posix_thread::attr
setsockopt	core/posix.hh	/^    int setsockopt(int level, int optname, X&& data) {$/;"	f	class:file_desc
setsockopt	core/posix.hh	/^    int setsockopt(int level, int optname, const char* data) {$/;"	f	class:file_desc
shutdown	core/posix.hh	/^    void shutdown(int how) {$/;"	f	class:file_desc
size	core/posix.hh	/^        struct stack_size { size_t size = 0; };$/;"	m	struct:posix_thread::attr::stack_size
size	core/posix.hh	/^    size_t size() {$/;"	f	class:file_desc
socket	core/posix.hh	/^    static file_desc socket(int family, int type, int protocol = 0) {$/;"	f	class:file_desc
stack_size	core/posix.hh	/^        struct stack_size { size_t size = 0; };$/;"	s	class:posix_thread::attr
throw_kernel_error	core/posix.hh	/^void throw_kernel_error(T r) {$/;"	f
throw_system_error_on	core/posix.hh	/^void throw_system_error_on(bool condition) {$/;"	f
timerfd_create	core/posix.hh	/^    static file_desc timerfd_create(int clockid, int flags) {$/;"	f	class:file_desc
timerfd_settime	core/posix.hh	/^    void timerfd_settime(int flags, const itimerspec& its) {$/;"	f	class:file_desc
truncate	core/posix.hh	/^    void truncate(size_t size) {$/;"	f	class:file_desc
write	core/posix.hh	/^    boost::optional<size_t> write(const void* buf, size_t len) {$/;"	f	class:file_desc
writev	core/posix.hh	/^    boost::optional<size_t> writev(const iovec *iov, int iovcnt) {$/;"	f	class:file_desc
~file_desc	core/posix.hh	/^    ~file_desc() { if (_fd != -1) { ::close(_fd); } }$/;"	f	class:file_desc
PREFETCH_HH_	core/prefetch.hh	23;"	d
cacheline_size	core/prefetch.hh	/^static constexpr size_t  cacheline_size = 64;$/;"	v
prefetch	core/prefetch.hh	/^void prefetch(Iterator begin, Iterator end) {$/;"	f
prefetch	core/prefetch.hh	/^void prefetch(T* ptr) {$/;"	f
prefetch	core/prefetch.hh	/^void prefetch(void* ptr) {$/;"	f
prefetch_n	core/prefetch.hh	/^void prefetch_n(Iterator begin, Iterator end) {$/;"	f
prefetch_n	core/prefetch.hh	/^void prefetch_n(T** pptr) {$/;"	f
prefetcher	core/prefetch.hh	/^    prefetcher(uintptr_t ptr) {$/;"	f	struct:prefetcher
prefetcher	core/prefetch.hh	/^    prefetcher(uintptr_t ptr) {}$/;"	f	struct:prefetcher
prefetcher	core/prefetch.hh	/^struct prefetcher {$/;"	s
prefetcher	core/prefetch.hh	/^struct prefetcher<0, RW, LOC> {$/;"	s
prefetchw	core/prefetch.hh	/^void prefetchw(T* ptr) {$/;"	f
prefetchw	core/prefetch.hh	/^void prefetchw(void* ptr) {$/;"	f
prefetchw_n	core/prefetch.hh	/^void prefetchw_n(Iterator begin, Iterator end) {$/;"	f
prefetchw_n	core/prefetch.hh	/^void prefetchw_n(T** pptr) {$/;"	f
PRINT_HH_	core/print.hh	23;"	d
apply_format	core/print.hh	/^apply_format(boost::format& fmt) {$/;"	f
apply_format	core/print.hh	/^apply_format(boost::format& fmt, A0&& a0, Arest&&... arest) {$/;"	f
format_separated	core/print.hh	/^format_separated(Iterator b, Iterator e, const char* sep = ", ") {$/;"	f
fprint	core/print.hh	/^fprint(std::ostream& os, boost::format& fmt, A&&... a) {$/;"	f
fprint	core/print.hh	/^fprint(std::ostream& os, const char* fmt, A&&... a) {$/;"	f
log	core/print.hh	/^log(A&&... a) {$/;"	f
operator <<	core/print.hh	/^operator<<(std::ostream& os, usecfmt_wrapper<std::chrono::time_point<Clock, std::chrono::duration<Rep, Period>>> tp) {$/;"	f
print	core/print.hh	/^print(boost::format& fmt, A&&... a) {$/;"	f
print	core/print.hh	/^print(const char* fmt, A&&... a) {$/;"	f
sprint	core/print.hh	/^sprint(const char* fmt, A&&... a) {$/;"	f
usecfmt	core/print.hh	/^usecfmt(TimePoint tp) {$/;"	f
usecfmt_wrapper	core/print.hh	/^struct usecfmt_wrapper {$/;"	s
val	core/print.hh	/^    TimePoint val;$/;"	m	struct:usecfmt_wrapper
QUEUE_HH_	core/queue.hh	23;"	d
_max	core/queue.hh	/^    size_t _max;$/;"	m	class:queue
_not_empty	core/queue.hh	/^    std::experimental::optional<promise<>> _not_empty;$/;"	m	class:queue
_not_full	core/queue.hh	/^    std::experimental::optional<promise<>> _not_full;$/;"	m	class:queue
_q	core/queue.hh	/^    std::queue<T, circular_buffer<T>> _q;$/;"	m	class:queue
abort	core/queue.hh	/^    void abort(std::exception_ptr ex) {$/;"	f	class:queue
consume	core/queue.hh	/^bool queue<T>::consume(Func&& func) {$/;"	f	class:queue
empty	core/queue.hh	/^bool queue<T>::empty() const {$/;"	f	class:queue
full	core/queue.hh	/^bool queue<T>::full() const {$/;"	f	class:queue
kj_not_empty	core/queue.hh	/^kj::Promise<void> queue<T>::kj_not_empty() {$/;"	f	class:queue
kj_not_full	core/queue.hh	/^kj::Promise<void> queue<T>::kj_not_full() {$/;"	f	class:queue
kj_pop_eventually	core/queue.hh	/^kj::Promise<T> queue<T>::kj_pop_eventually() {$/;"	f	class:queue
kj_push_eventually	core/queue.hh	/^kj::Promise<void> queue<T>::kj_push_eventually(T&& data) {$/;"	f	class:queue
not_empty	core/queue.hh	/^future<> queue<T>::not_empty() {$/;"	f	class:queue
not_full	core/queue.hh	/^future<> queue<T>::not_full() {$/;"	f	class:queue
notify_not_empty	core/queue.hh	/^void queue<T>::notify_not_empty() {$/;"	f	class:queue
notify_not_full	core/queue.hh	/^void queue<T>::notify_not_full() {$/;"	f	class:queue
pop	core/queue.hh	/^T queue<T>::pop() {$/;"	f	class:queue
pop_eventually	core/queue.hh	/^future<T> queue<T>::pop_eventually() {$/;"	f	class:queue
push	core/queue.hh	/^bool queue<T>::push(T&& data) {$/;"	f	class:queue
push_eventually	core/queue.hh	/^future<> queue<T>::push_eventually(T&& data) {$/;"	f	class:queue
queue	core/queue.hh	/^class queue {$/;"	c
queue	core/queue.hh	/^queue<T>::queue(size_t size)$/;"	f	class:queue
size	core/queue.hh	/^	size_t size() const { return _q.size(); }$/;"	f	class:queue
RAGEL_HH_	core/ragel.hh	23;"	d
_block_end	core/ragel.hh	/^    const char* _block_end;$/;"	m	class:sstring_builder::guard
_builder	core/ragel.hh	/^    sstring_builder _builder;$/;"	m	class:ragel_parser_base
_builder	core/ragel.hh	/^    sstring_builder& _builder;$/;"	m	class:sstring_builder::guard
_fsm_act	core/ragel.hh	/^    int _fsm_act;$/;"	m	class:ragel_parser_base
_fsm_cs	core/ragel.hh	/^    int _fsm_cs;$/;"	m	class:ragel_parser_base
_fsm_stack	core/ragel.hh	/^    std::unique_ptr<int[]> _fsm_stack = nullptr;$/;"	m	class:ragel_parser_base
_fsm_stack_size	core/ragel.hh	/^    int _fsm_stack_size = 0;$/;"	m	class:ragel_parser_base
_fsm_te	core/ragel.hh	/^    char* _fsm_te;$/;"	m	class:ragel_parser_base
_fsm_top	core/ragel.hh	/^    int _fsm_top;$/;"	m	class:ragel_parser_base
_fsm_ts	core/ragel.hh	/^    char* _fsm_ts;$/;"	m	class:ragel_parser_base
_start	core/ragel.hh	/^    const char* _start = nullptr;$/;"	m	class:sstring_builder
_value	core/ragel.hh	/^    sstring _value;$/;"	m	class:sstring_builder
get	core/ragel.hh	/^    sstring get() && {$/;"	f	class:sstring_builder
get_str	core/ragel.hh	/^    sstring get_str() {$/;"	f	class:ragel_parser_base
guard	core/ragel.hh	/^    guard(sstring_builder& builder, const char* block_start, const char* block_end)$/;"	f	class:sstring_builder::guard
guard	core/ragel.hh	/^class sstring_builder::guard {$/;"	c	class:sstring_builder
init_base	core/ragel.hh	/^    void init_base() {$/;"	f	class:ragel_parser_base
mark_end	core/ragel.hh	/^    void mark_end(const char* p) {$/;"	f	class:sstring_builder::guard
mark_start	core/ragel.hh	/^    void mark_start(const char* p) {$/;"	f	class:sstring_builder::guard
operator ()	core/ragel.hh	/^    future<unconsumed_remainder> operator()(temporary_buffer<char> buf) {$/;"	f	class:ragel_parser_base
postpop	core/ragel.hh	/^    void postpop() {}$/;"	f	class:ragel_parser_base
prepush	core/ragel.hh	/^    void prepush() {$/;"	f	class:ragel_parser_base
ragel_parser_base	core/ragel.hh	/^class ragel_parser_base {$/;"	c
reset	core/ragel.hh	/^    void reset() {$/;"	f	class:sstring_builder
sstring_builder	core/ragel.hh	/^class sstring_builder {$/;"	c
~guard	core/ragel.hh	/^    ~guard() {$/;"	f	class:sstring_builder::guard
_granularity	core/reactor.cc	/^constexpr std::chrono::milliseconds lowres_clock::_granularity;$/;"	m	class:lowres_clock	file:
_needed	core/reactor.cc	/^    bool _needed = false;$/;"	m	class:reactor_notifier_osv	file:
_p	core/reactor.cc	/^    poller* _p;$/;"	m	class:reactor::poller::registration_task	file:
_p	core/reactor.cc	/^    std::unique_ptr<pollfn> _p;$/;"	m	class:reactor::poller::deregistration_task	file:
_poller	core/reactor.cc	/^    osv::newpoll::poller *_poller = nullptr;$/;"	m	class:reactor_notifier_osv	file:
_pr	core/reactor.cc	/^    promise<> _pr;$/;"	m	class:reactor_notifier_osv	file:
_qs	core/reactor.cc	/^smp_message_queue** smp::_qs;$/;"	m	class:smp	file:
_read	core/reactor.cc	/^    readable_eventfd _read;$/;"	m	class:reactor_notifier_epoll	file:
_threads	core/reactor.cc	/^std::vector<smp::thread_adaptor> smp::_threads;$/;"	m	class:smp	file:
_tmain	core/reactor.cc	/^std::thread::id smp::_tmain;$/;"	m	class:smp	file:
_write	core/reactor.cc	/^    writeable_eventfd _write;$/;"	m	class:reactor_notifier_epoll	file:
abort_fd	core/reactor.cc	/^void reactor_backend_epoll::abort_fd(pollable_fd_state& pfd, std::exception_ptr ex,$/;"	f	class:reactor_backend_epoll
abort_reader	core/reactor.cc	/^void reactor_backend_epoll::abort_reader(pollable_fd_state& fd, std::exception_ptr ex) {$/;"	f	class:reactor_backend_epoll
abort_writer	core/reactor.cc	/^void reactor_backend_epoll::abort_writer(pollable_fd_state& fd, std::exception_ptr ex) {$/;"	f	class:reactor_backend_epoll
action	core/reactor.cc	/^void reactor::signals::action(int signo, siginfo_t* siginfo, void* ignore) {$/;"	f	class:reactor::signals
add_timer	core/reactor.cc	/^void reactor::add_timer(timer<>* tmr) {$/;"	f	class:reactor
add_timer	core/reactor.cc	/^void reactor::add_timer(timer<lowres_clock>* tmr) {$/;"	f	class:reactor
allocate	core/reactor.cc	/^blockdev_file_impl::allocate(uint64_t position, uint64_t length) {$/;"	f	class:blockdev_file_impl
allocate	core/reactor.cc	/^posix_file_impl::allocate(uint64_t position, uint64_t length) {$/;"	f	class:posix_file_impl
allocate_reactor	core/reactor.cc	/^void smp::allocate_reactor() {$/;"	f	class:smp
cancel	core/reactor.cc	/^    void cancel() {$/;"	f	class:reactor::poller::registration_task
cleanup	core/reactor.cc	/^void smp::cleanup() {$/;"	f	class:smp
collectd_registrations	core/reactor.cc	/^struct reactor::collectd_registrations {$/;"	s	class:reactor	file:
complete	core/reactor.cc	/^void syscall_work_queue::complete() {$/;"	f	class:syscall_work_queue
complete_epoll_event	core/reactor.cc	/^void reactor_backend_epoll::complete_epoll_event(pollable_fd_state& pfd, promise<> pollable_fd_state::*pr,$/;"	f	class:reactor_backend_epoll
configure	core/reactor.cc	/^void reactor::configure(boost::program_options::variables_map vm) {$/;"	f	class:reactor
configure	core/reactor.cc	/^void smp::configure(boost::program_options::variables_map configuration)$/;"	f	class:smp
connect	core/reactor.cc	/^future<connected_socket> connect(socket_address sa) {$/;"	f
connect	core/reactor.cc	/^reactor::connect(socket_address sa) {$/;"	f	class:reactor
count	core/reactor.cc	/^unsigned smp::count = 1;$/;"	m	class:smp	file:
cpuset_wrapper	core/reactor.cc	/^struct cpuset_wrapper {$/;"	s	file:
create	core/reactor.cc	/^network_stack_registry::create(options opts) {$/;"	f	class:network_stack_registry
create	core/reactor.cc	/^network_stack_registry::create(sstring name, options opts) {$/;"	f	class:network_stack_registry
default_stack	core/reactor.cc	/^sstring network_stack_registry::default_stack() {$/;"	f	class:network_stack_registry
del_timer	core/reactor.cc	/^void reactor::del_timer(timer<>* tmr) {$/;"	f	class:reactor
del_timer	core/reactor.cc	/^void reactor::del_timer(timer<lowres_clock>* tmr) {$/;"	f	class:reactor
deregistration_task	core/reactor.cc	/^    explicit deregistration_task(std::unique_ptr<pollfn>&& p) : _p(std::move(p)) {}$/;"	f	class:reactor::poller::deregistration_task
deregistration_task	core/reactor.cc	/^class reactor::poller::deregistration_task : public task {$/;"	c	class:reactor::poller	file:
discard	core/reactor.cc	/^blockdev_file_impl::discard(uint64_t offset, uint64_t length) {$/;"	f	class:blockdev_file_impl
discard	core/reactor.cc	/^posix_file_impl::discard(uint64_t offset, uint64_t length) {$/;"	f	class:posix_file_impl
do_register	core/reactor.cc	/^reactor::poller::do_register() {$/;"	f	class:reactor::poller
dpdk_thread_adaptor	core/reactor.cc	/^int dpdk_thread_adaptor(void* f)$/;"	f
enable	core/reactor.cc	/^    void enable(osv::newpoll::poller &poller) {$/;"	f	class:reactor_notifier_osv
enable_timer	core/reactor.cc	/^reactor_backend_osv::enable_timer(clock_type::time_point when) {$/;"	f	class:reactor_backend_osv
enable_timer	core/reactor.cc	/^void reactor::enable_timer(clock_type::time_point when)$/;"	f	class:reactor
engine_exit	core/reactor.cc	/^void engine_exit(std::exception_ptr eptr) {$/;"	f
error	core/reactor.cc	/^    int error;$/;"	m	struct:syscall_result	file:
error	core/reactor.cc	/^    int error;$/;"	m	struct:syscall_result_extra	file:
exit	core/reactor.cc	/^void reactor::exit(int ret) {$/;"	f	class:reactor
extra	core/reactor.cc	/^    Extra extra;$/;"	m	struct:syscall_result_extra	file:
file_type	core/reactor.cc	/^reactor::file_type(sstring name) {$/;"	f	class:reactor
flush	core/reactor.cc	/^posix_file_impl::flush(void) {$/;"	f	class:posix_file_impl
flush_pending_aio	core/reactor.cc	/^reactor::flush_pending_aio() {$/;"	f	class:reactor
flush_request_batch	core/reactor.cc	/^void smp_message_queue::flush_request_batch() {$/;"	f	class:smp_message_queue
flush_response_batch	core/reactor.cc	/^void smp_message_queue::flush_response_batch() {$/;"	f	class:smp_message_queue
forget	core/reactor.cc	/^reactor_backend_osv::forget(pollable_fd_state& fd) {$/;"	f	class:reactor_backend_osv
forget	core/reactor.cc	/^void reactor_backend_epoll::forget(pollable_fd_state& fd) {$/;"	f	class:reactor_backend_epoll
future_avail_count	core/reactor.cc	/^__thread size_t future_avail_count = 0;$/;"	v
get_epoll_future	core/reactor.cc	/^future<> reactor_backend_epoll::get_epoll_future(pollable_fd_state& pfd,$/;"	f	class:reactor_backend_epoll
get_options_description	core/reactor.cc	/^reactor::get_options_description() {$/;"	f	class:reactor
get_options_description	core/reactor.cc	/^smp::get_options_description()$/;"	f	class:smp
handle_signal	core/reactor.cc	/^reactor::signals::handle_signal(int signo, std::function<void ()>&& handler) {$/;"	f	class:reactor::signals
handle_signal_once	core/reactor.cc	/^reactor::signals::handle_signal_once(int signo, std::function<void ()>&& handler) {$/;"	f	class:reactor::signals
join_all	core/reactor.cc	/^void smp::join_all()$/;"	f	class:smp
kj_allocate	core/reactor.cc	/^blockdev_file_impl::kj_allocate(uint64_t position, uint64_t length) {$/;"	f	class:blockdev_file_impl
kj_allocate	core/reactor.cc	/^posix_file_impl::kj_allocate(uint64_t position, uint64_t length) {$/;"	f	class:posix_file_impl
kj_complete_epoll_event	core/reactor.cc	/^void reactor_backend_epoll::kj_complete_epoll_event(pollable_fd_state& pfd, kj::Own<kj::PromiseFulfiller<void>>& pr,$/;"	f	class:reactor_backend_epoll
kj_connect	core/reactor.cc	/^kj::Promise<connected_socket> kj_connect(socket_address sa) {$/;"	f
kj_connect	core/reactor.cc	/^reactor::kj_connect(socket_address sa) {$/;"	f	class:reactor
kj_discard	core/reactor.cc	/^blockdev_file_impl::kj_discard(uint64_t offset, uint64_t length) {$/;"	f	class:blockdev_file_impl
kj_discard	core/reactor.cc	/^posix_file_impl::kj_discard(uint64_t offset, uint64_t length) {$/;"	f	class:posix_file_impl
kj_file_type	core/reactor.cc	/^reactor::kj_file_type(sstring name) {$/;"	f	class:reactor
kj_flush	core/reactor.cc	/^posix_file_impl::kj_flush(void) {    $/;"	f	class:posix_file_impl
kj_get_epoll_future	core/reactor.cc	/^kj::Promise<void> reactor_backend_epoll::kj_get_epoll_future(pollable_fd_state& pfd,$/;"	f	class:reactor_backend_epoll
kj_notified	core/reactor.cc	/^kj::Promise<void> reactor_backend_epoll::kj_notified(reactor_notifier *n) {$/;"	f	class:reactor_backend_epoll
kj_notified	core/reactor.cc	/^reactor_backend_osv::kj_notified(reactor_notifier *notifier) {$/;"	f	class:reactor_backend_osv
kj_open_directory	core/reactor.cc	/^reactor::kj_open_directory(sstring name) {$/;"	f	class:reactor
kj_open_file_dma	core/reactor.cc	/^reactor::kj_open_file_dma(sstring name, open_flags flags) {$/;"	f	class:reactor
kj_posix_connect	core/reactor.cc	/^reactor::kj_posix_connect(socket_address sa, socket_address local) {$/;"	f	class:reactor
kj_read_dma	core/reactor.cc	/^posix_file_impl::kj_read_dma(uint64_t pos, std::vector<iovec> iov) {$/;"	f	class:posix_file_impl
kj_read_dma	core/reactor.cc	/^posix_file_impl::kj_read_dma(uint64_t pos, void* buffer, size_t len) {$/;"	f	class:posix_file_impl
kj_readable	core/reactor.cc	/^kj::Promise<void> reactor_backend_epoll::kj_readable(pollable_fd_state& fd) {$/;"	f	class:reactor_backend_epoll
kj_readable	core/reactor.cc	/^reactor_backend_osv::kj_readable(pollable_fd_state& fd) {$/;"	f	class:reactor_backend_osv
kj_size	core/reactor.cc	/^blockdev_file_impl::kj_size(void) {$/;"	f	class:blockdev_file_impl
kj_size	core/reactor.cc	/^posix_file_impl::kj_size(void) {$/;"	f	class:posix_file_impl
kj_stat	core/reactor.cc	/^posix_file_impl::kj_stat(void) {$/;"	f	class:posix_file_impl
kj_truncate	core/reactor.cc	/^blockdev_file_impl::kj_truncate(uint64_t length) {$/;"	f	class:blockdev_file_impl
kj_truncate	core/reactor.cc	/^posix_file_impl::kj_truncate(uint64_t length) {$/;"	f	class:posix_file_impl
kj_wait_and_process	core/reactor.cc	/^reactor_backend_epoll::kj_wait_and_process() {    $/;"	f	class:reactor_backend_epoll
kj_wait_and_process	core/reactor.cc	/^reactor_backend_osv::kj_wait_and_process() {$/;"	f	class:reactor_backend_osv
kj_write_dma	core/reactor.cc	/^posix_file_impl::kj_write_dma(uint64_t pos, const void* buffer, size_t len) {$/;"	f	class:posix_file_impl
kj_write_dma	core/reactor.cc	/^posix_file_impl::kj_write_dma(uint64_t pos, std::vector<iovec> iov) {$/;"	f	class:posix_file_impl
kj_writeable	core/reactor.cc	/^kj::Promise<void> reactor_backend_epoll::kj_writeable(pollable_fd_state& fd) {$/;"	f	class:reactor_backend_epoll
kj_writeable	core/reactor.cc	/^reactor_backend_osv::kj_writeable(pollable_fd_state& fd) {$/;"	f	class:reactor_backend_osv
list	core/reactor.cc	/^std::vector<sstring> network_stack_registry::list() {$/;"	f	class:network_stack_registry
list_directory	core/reactor.cc	/^posix_file_impl::list_directory(std::function<future<> (directory_entry de)> next) {$/;"	f	class:posix_file_impl
listen	core/reactor.cc	/^reactor::listen(socket_address sa, listen_options opt) {$/;"	f	class:reactor
listen	core/reactor.cc	/^server_socket listen(socket_address sa) {$/;"	f
listen	core/reactor.cc	/^server_socket listen(socket_address sa, listen_options opts) {$/;"	f
local_engine	core/reactor.cc	/^__thread reactor* local_engine;$/;"	v
lowres_clock	core/reactor.cc	/^lowres_clock::lowres_clock() {$/;"	f	class:lowres_clock
make_directory	core/reactor.cc	/^future<> make_directory(sstring name) {$/;"	f
make_directory	core/reactor.cc	/^reactor::make_directory(sstring name) {$/;"	f	class:reactor
make_reactor_notifier	core/reactor.cc	/^reactor_backend_epoll::make_reactor_notifier() {$/;"	f	class:reactor_backend_epoll
make_reactor_notifier	core/reactor.cc	/^reactor_backend_osv::make_reactor_notifier() {$/;"	f	class:reactor_backend_osv
move_pending	core/reactor.cc	/^void smp_message_queue::move_pending() {$/;"	f	class:smp_message_queue
moved	core/reactor.cc	/^    void moved(poller* p) {$/;"	f	class:reactor::poller::registration_task
notified	core/reactor.cc	/^future<> reactor_backend_epoll::notified(reactor_notifier *n) {$/;"	f	class:reactor_backend_epoll
notified	core/reactor.cc	/^reactor_backend_osv::notified(reactor_notifier *notifier) {$/;"	f	class:reactor_backend_osv
open_directory	core/reactor.cc	/^future<file> open_directory(sstring name) {$/;"	f
open_directory	core/reactor.cc	/^reactor::open_directory(sstring name) {$/;"	f	class:reactor
open_file_dma	core/reactor.cc	/^future<file> open_file_dma(sstring name, open_flags flags) {$/;"	f
open_file_dma	core/reactor.cc	/^reactor::open_file_dma(sstring name, open_flags flags) {$/;"	f	class:reactor
operator =	core/reactor.cc	/^reactor::poller::operator=(poller&& x) {$/;"	f	class:reactor::poller
operator ==	core/reactor.cc	/^bool operator==(const ::sockaddr_in a, const ::sockaddr_in b) {$/;"	f
pin	core/reactor.cc	/^void smp::pin(unsigned cpu_id) {$/;"	f	class:smp
poll_once	core/reactor.cc	/^reactor::poll_once() {$/;"	f	class:reactor
poll_signal	core/reactor.cc	/^bool reactor::signals::poll_signal() {$/;"	f	class:reactor::signals
poller	core/reactor.cc	/^reactor::poller::poller(poller&& x)$/;"	f	class:reactor::poller
posix_connect	core/reactor.cc	/^reactor::posix_connect(socket_address sa, socket_address local) {$/;"	f	class:reactor
posix_listen	core/reactor.cc	/^reactor::posix_listen(socket_address sa, listen_options opts) {$/;"	f	class:reactor
posix_reuseport_detect	core/reactor.cc	/^reactor::posix_reuseport_detect() {$/;"	f	class:reactor
process_completions	core/reactor.cc	/^size_t smp_message_queue::process_completions() {$/;"	f	class:smp_message_queue
process_incoming	core/reactor.cc	/^size_t smp_message_queue::process_incoming() {$/;"	f	class:smp_message_queue
process_io	core/reactor.cc	/^bool reactor::process_io()$/;"	f	class:reactor
process_queue	core/reactor.cc	/^size_t smp_message_queue::process_queue(lf_queue& q, Func process) {$/;"	f	class:smp_message_queue
queue_timer	core/reactor.cc	/^bool reactor::queue_timer(timer<>* tmr) {$/;"	f	class:reactor
queue_timer	core/reactor.cc	/^bool reactor::queue_timer(timer<lowres_clock>* tmr) {$/;"	f	class:reactor
reactor	core/reactor.cc	/^reactor::reactor()$/;"	f	class:reactor
reactor_backend_epoll	core/reactor.cc	/^reactor_backend_epoll::reactor_backend_epoll()$/;"	f	class:reactor_backend_epoll
reactor_backend_osv	core/reactor.cc	/^reactor_backend_osv::reactor_backend_osv() {$/;"	f	class:reactor_backend_osv
reactor_notifier_epoll	core/reactor.cc	/^    reactor_notifier_epoll()$/;"	f	class:reactor_notifier_epoll
reactor_notifier_epoll	core/reactor.cc	/^class reactor_notifier_epoll : public reactor_notifier {$/;"	c	file:
reactor_notifier_osv	core/reactor.cc	/^class reactor_notifier_osv :$/;"	c	file:
read_dma	core/reactor.cc	/^posix_file_impl::read_dma(uint64_t pos, std::vector<iovec> iov) {$/;"	f	class:posix_file_impl
read_dma	core/reactor.cc	/^posix_file_impl::read_dma(uint64_t pos, void* buffer, size_t len) {$/;"	f	class:posix_file_impl
read_side	core/reactor.cc	/^readable_eventfd writeable_eventfd::read_side() {$/;"	f	class:writeable_eventfd
readable	core/reactor.cc	/^future<> reactor_backend_epoll::readable(pollable_fd_state& fd) {$/;"	f	class:reactor_backend_epoll
readable	core/reactor.cc	/^reactor_backend_osv::readable(pollable_fd_state& fd) {$/;"	f	class:reactor_backend_osv
register_collectd_metrics	core/reactor.cc	/^reactor::register_collectd_metrics() {$/;"	f	class:reactor
register_poller	core/reactor.cc	/^void reactor::register_poller(pollfn* p) {$/;"	f	class:reactor
register_stack	core/reactor.cc	/^void network_stack_registry::register_stack(sstring name,$/;"	f	class:network_stack_registry
registration_task	core/reactor.cc	/^    explicit registration_task(poller* p) : _p(p) {}$/;"	f	class:reactor::poller::registration_task
registration_task	core/reactor.cc	/^class reactor::poller::registration_task : public task {$/;"	c	class:reactor::poller	file:
regs	core/reactor.cc	/^    scollectd::registrations regs;$/;"	m	struct:reactor::collectd_registrations	file:
remove_file	core/reactor.cc	/^future<> remove_file(sstring pathname) {$/;"	f
remove_file	core/reactor.cc	/^reactor::remove_file(sstring pathname) {$/;"	f	class:reactor
replace_poller	core/reactor.cc	/^void reactor::replace_poller(pollfn* old, pollfn* neww) {$/;"	f	class:reactor
report_failed_future	core/reactor.cc	/^void report_failed_future(std::exception_ptr exp) {$/;"	f
respond	core/reactor.cc	/^void smp_message_queue::respond(work_item* item) {$/;"	f	class:smp_message_queue
result	core/reactor.cc	/^    T result;$/;"	m	struct:syscall_result	file:
result	core/reactor.cc	/^    int result;$/;"	m	struct:syscall_result_extra	file:
run	core/reactor.cc	/^int reactor::run(uint maxTurnCount) {$/;"	f	class:reactor
run_exit_tasks	core/reactor.cc	/^future<> reactor::run_exit_tasks() {$/;"	f	class:reactor
run_tasks	core/reactor.cc	/^void reactor::run_tasks(circular_buffer<std::unique_ptr<task>>& tasks, size_t quota) {$/;"	f	class:reactor
schedule	core/reactor.cc	/^void schedule(std::unique_ptr<task> t) {$/;"	f
set_timer	core/reactor.cc	/^void reactor::set_timer(sched::timer &tmr, s64 t) {$/;"	f	class:reactor
signal	core/reactor.cc	/^void writeable_eventfd::signal(size_t count) {$/;"	f	class:writeable_eventfd
signal_handler	core/reactor.cc	/^reactor::signals::signal_handler::signal_handler(int signo, std::function<void ()>&& handler)$/;"	f	class:reactor::signals::signal_handler
signals	core/reactor.cc	/^reactor::signals::signals() : _pending_signals(0) {$/;"	f	class:reactor::signals
size	core/reactor.cc	/^blockdev_file_impl::size(void) {$/;"	f	class:blockdev_file_impl
size	core/reactor.cc	/^posix_file_impl::size(void) {$/;"	f	class:posix_file_impl
smp_message_queue	core/reactor.cc	/^smp_message_queue::smp_message_queue()$/;"	f	class:smp_message_queue
start	core/reactor.cc	/^void smp_message_queue::start(unsigned cpuid) {$/;"	f	class:smp_message_queue
start_all_queues	core/reactor.cc	/^void smp::start_all_queues()$/;"	f	class:smp
stat	core/reactor.cc	/^posix_file_impl::stat(void) {$/;"	f	class:posix_file_impl
stat_to_entry_type	core/reactor.cc	/^directory_entry_type stat_to_entry_type(__mode_t type) {$/;"	f
stop	core/reactor.cc	/^void reactor::stop() {$/;"	f	class:reactor
submit_io	core/reactor.cc	/^reactor::submit_io(Func prepare_io) {$/;"	f	class:reactor
submit_io_read	core/reactor.cc	/^reactor::submit_io_read(Func prepare_io) {$/;"	f	class:reactor
submit_io_write	core/reactor.cc	/^reactor::submit_io_write(Func prepare_io) {$/;"	f	class:reactor
submit_item	core/reactor.cc	/^void smp_message_queue::submit_item(smp_message_queue::work_item* item) {$/;"	f	class:smp_message_queue
submit_item	core/reactor.cc	/^void syscall_work_queue::submit_item(syscall_work_queue::work_item* item) {$/;"	f	class:syscall_work_queue
syscall_result	core/reactor.cc	/^struct syscall_result {$/;"	s	file:
syscall_result_extra	core/reactor.cc	/^struct syscall_result_extra {$/;"	s	file:
syscall_work_queue	core/reactor.cc	/^syscall_work_queue::syscall_work_queue()$/;"	f	class:syscall_work_queue
task_quota	core/reactor.cc	/^__thread size_t task_quota = 0;$/;"	v
thread_pool	core/reactor.cc	/^thread_pool::thread_pool() : _worker_thread([this] { work(); }), _notify(pthread_self()) {$/;"	f	class:thread_pool
throw_if_error	core/reactor.cc	/^    void throw_if_error() {$/;"	f	struct:syscall_result
throw_if_error	core/reactor.cc	/^    void throw_if_error() {$/;"	f	struct:syscall_result_extra
timer_thread_func	core/reactor.cc	/^void reactor::timer_thread_func() {$/;"	f	class:reactor
to_timespec	core/reactor.cc	/^timespec to_timespec(clock_type::time_point t) {$/;"	f
truncate	core/reactor.cc	/^blockdev_file_impl::truncate(uint64_t length) {$/;"	f	class:blockdev_file_impl
truncate	core/reactor.cc	/^posix_file_impl::truncate(uint64_t length) {$/;"	f	class:posix_file_impl
try_create_eventfd	core/reactor.cc	/^file_desc readable_eventfd::try_create_eventfd(size_t initial) {$/;"	f	class:readable_eventfd
try_create_eventfd	core/reactor.cc	/^file_desc writeable_eventfd::try_create_eventfd(size_t initial) {$/;"	f	class:writeable_eventfd
unregister_poller	core/reactor.cc	/^void reactor::unregister_poller(pollfn* p) {$/;"	f	class:reactor
update	core/reactor.cc	/^void lowres_clock::update() {$/;"	f	class:lowres_clock
validate	core/reactor.cc	/^void validate(boost::any& v,$/;"	f
value	core/reactor.cc	/^    resource::cpuset value;$/;"	m	struct:cpuset_wrapper	file:
wait	core/reactor.cc	/^future<size_t> readable_eventfd::wait() {$/;"	f	class:readable_eventfd
wait_and_process	core/reactor.cc	/^reactor_backend_epoll::wait_and_process() {$/;"	f	class:reactor_backend_epoll
wait_and_process	core/reactor.cc	/^reactor_backend_osv::wait_and_process() {$/;"	f	class:reactor_backend_osv
work	core/reactor.cc	/^void thread_pool::work() {$/;"	f	class:thread_pool
wrap_syscall	core/reactor.cc	/^wrap_syscall(T result) {$/;"	f
wrap_syscall	core/reactor.cc	/^wrap_syscall(int result, const Extra& extra) {$/;"	f
write_dma	core/reactor.cc	/^posix_file_impl::write_dma(uint64_t pos, const void* buffer, size_t len) {$/;"	f	class:posix_file_impl
write_dma	core/reactor.cc	/^posix_file_impl::write_dma(uint64_t pos, std::vector<iovec> iov) {$/;"	f	class:posix_file_impl
write_side	core/reactor.cc	/^writeable_eventfd readable_eventfd::write_side() {$/;"	f	class:readable_eventfd
writeable	core/reactor.cc	/^future<> reactor_backend_epoll::writeable(pollable_fd_state& fd) {$/;"	f	class:reactor_backend_epoll
writeable	core/reactor.cc	/^reactor_backend_osv::writeable(pollable_fd_state& fd) {$/;"	f	class:reactor_backend_osv
~poller	core/reactor.cc	/^reactor::poller::~poller() {$/;"	f	class:reactor::poller
~reactor_notifier_osv	core/reactor.cc	/^    virtual ~reactor_notifier_osv() {$/;"	f	class:reactor_notifier_osv
~signals	core/reactor.cc	/^reactor::signals::~signals() {$/;"	f	class:reactor::signals
~thread_pool	core/reactor.cc	/^thread_pool::~thread_pool() {$/;"	f	class:thread_pool
REACTOR_HH_	core/reactor.hh	23;"	d
_aio_reads	core/reactor.hh	/^    uint64_t _aio_reads = 0;$/;"	m	class:reactor
_aio_threaded_fallbacks	core/reactor.hh	/^    uint64_t _aio_threaded_fallbacks = 0;$/;"	m	class:thread_pool
_aio_writes	core/reactor.hh	/^    uint64_t _aio_writes = 0;$/;"	m	class:reactor
_at_destroy_tasks	core/reactor.hh	/^    circular_buffer<std::unique_ptr<task>> _at_destroy_tasks;$/;"	m	class:reactor
_backend	core/reactor.hh	/^    reactor_backend_epoll _backend;$/;"	m	class:reactor
_backend	core/reactor.hh	/^    reactor_backend_osv _backend;$/;"	m	class:reactor
_collectd_regs	core/reactor.hh	/^    std::vector<scollectd::registration> _collectd_regs;$/;"	m	class:smp_message_queue
_completed	core/reactor.hh	/^    lf_queue _completed;$/;"	m	class:smp_message_queue
_completed	core/reactor.hh	/^    lf_queue _completed;$/;"	m	class:syscall_work_queue
_completed_fifo	core/reactor.hh	/^    std::vector<work_item*> _completed_fifo;$/;"	m	class:smp_message_queue
_cpu_started	core/reactor.hh	/^    semaphore _cpu_started;$/;"	m	class:reactor
_csi	core/reactor.hh	/^    std::unique_ptr<connected_socket_impl> _csi;$/;"	m	class:connected_socket
_default	core/reactor.hh	/^    static sstring& _default() {$/;"	f	class:network_stack_registry
_engine_thread	core/reactor.hh	/^    sched::thread *_engine_thread;$/;"	m	class:reactor
_epoll_poller	core/reactor.hh	/^    std::experimental::optional<poller> _epoll_poller;$/;"	m	class:reactor
_epollfd	core/reactor.hh	/^    file_desc _epollfd;$/;"	m	class:reactor_backend_epoll
_ex	core/reactor.hh	/^        std::exception_ptr _ex; \/\/ if !_result$/;"	m	struct:smp_message_queue::async_work_item
_exit_future	core/reactor.hh	/^    future<> _exit_future;$/;"	m	class:reactor
_exit_promise	core/reactor.hh	/^    promise<> _exit_promise;$/;"	m	class:reactor
_expired_lowres_timers	core/reactor.hh	/^    seastar::timer_set<timer<lowres_clock>, &timer<lowres_clock>::_link>::timer_list_t _expired_lowres_timers;$/;"	m	class:reactor
_expired_timers	core/reactor.hh	/^    seastar::timer_set<timer<>, &timer<>::_link>::timer_list_t _expired_timers;$/;"	m	class:reactor
_fd	core/reactor.hh	/^    file_desc _fd;$/;"	m	class:writeable_eventfd
_fd	core/reactor.hh	/^    pollable_fd _fd;$/;"	m	class:readable_eventfd
_fsyncs	core/reactor.hh	/^    uint64_t _fsyncs = 0;$/;"	m	class:reactor
_func	core/reactor.hh	/^        Func _func;$/;"	m	struct:smp_message_queue::async_work_item
_func	core/reactor.hh	/^        Func _func;$/;"	m	struct:syscall_work_queue::work_item_returning
_handle_sigint	core/reactor.hh	/^    bool _handle_sigint = true;$/;"	m	class:reactor
_handler	core/reactor.hh	/^            std::function<void ()> _handler;$/;"	m	struct:reactor::signals::signal_handler
_id	core/reactor.hh	/^    unsigned _id = 0;$/;"	m	class:reactor
_io_context	core/reactor.hh	/^    io_context_t _io_context;$/;"	m	class:reactor
_io_context_available	core/reactor.hh	/^    semaphore _io_context_available;$/;"	m	class:reactor
_load	core/reactor.hh	/^    double _load = 0;$/;"	m	class:reactor
_loads	core/reactor.hh	/^    circular_buffer<double> _loads;$/;"	m	class:reactor
_lowres_clock	core/reactor.hh	/^    std::unique_ptr<lowres_clock> _lowres_clock;$/;"	m	class:reactor
_lowres_next_timeout	core/reactor.hh	/^    lowres_clock::time_point _lowres_next_timeout;$/;"	m	class:reactor
_lowres_timers	core/reactor.hh	/^    seastar::timer_set<timer<lowres_clock>, &timer<lowres_clock>::_link> _lowres_timers;$/;"	m	class:reactor
_map	core/reactor.hh	/^            std::function<future<std::unique_ptr<network_stack>> (options opts)>>& _map() {$/;"	f	class:network_stack_registry
_network_stack	core/reactor.hh	/^    std::unique_ptr<network_stack> _network_stack;$/;"	m	class:reactor
_network_stack_ready_promise	core/reactor.hh	/^    promise<std::unique_ptr<network_stack>> _network_stack_ready_promise;$/;"	m	class:reactor
_notify	core/reactor.hh	/^    pthread_t _notify;$/;"	m	class:thread_pool
_now	core/reactor.hh	/^    static std::atomic<rep> _now [[gnu::aligned(64)]];$/;"	m	class:lowres_clock
_pending_aio	core/reactor.hh	/^    std::vector<struct ::iocb> _pending_aio;$/;"	m	class:reactor
_pending_signals	core/reactor.hh	/^        std::atomic<uint64_t> _pending_signals;$/;"	m	class:reactor::signals
_pending_tasks	core/reactor.hh	/^    circular_buffer<std::unique_ptr<task>> _pending_tasks;$/;"	m	class:reactor
_poller	core/reactor.hh	/^    osv::newpoll::poller _poller;$/;"	m	class:reactor_backend_osv
_pollers	core/reactor.hh	/^    std::vector<pollfn*> _pollers;$/;"	m	class:reactor
_pollfn	core/reactor.hh	/^        std::unique_ptr<pollfn> _pollfn;$/;"	m	class:reactor::poller
_promise	core/reactor.hh	/^        promise<T> _promise;$/;"	m	struct:syscall_work_queue::work_item_returning
_promise	core/reactor.hh	/^        typename futurator::promise_type _promise; \/\/ used on local side$/;"	m	struct:smp_message_queue::async_work_item
_qs	core/reactor.hh	/^    static smp_message_queue** _qs;$/;"	m	class:smp
_queue_has_room	core/reactor.hh	/^    semaphore _queue_has_room = { queue_length };$/;"	m	class:syscall_work_queue
_registration_task	core/reactor.hh	/^        registration_task* _registration_task;$/;"	m	class:reactor::poller
_result	core/reactor.hh	/^        boost::optional<T> _result;$/;"	m	struct:syscall_work_queue::work_item_returning
_return	core/reactor.hh	/^    int _return = 0;$/;"	m	class:reactor
_reuseport	core/reactor.hh	/^    const bool _reuseport;$/;"	m	class:reactor
_s	core/reactor.hh	/^    std::unique_ptr<pollable_fd_state> _s;$/;"	m	class:pollable_fd
_signal_handlers	core/reactor.hh	/^        std::unordered_map<int, signal_handler> _signal_handlers;$/;"	m	class:reactor::signals
_signals	core/reactor.hh	/^    signals _signals;$/;"	m	class:reactor
_ssi	core/reactor.hh	/^    std::unique_ptr<server_socket_impl> _ssi;$/;"	m	class:server_socket
_start_eventfd	core/reactor.hh	/^    writeable_eventfd _start_eventfd;$/;"	m	class:syscall_work_queue
_start_promise	core/reactor.hh	/^    promise<> _start_promise;$/;"	m	class:reactor
_stopped	core/reactor.hh	/^    bool _stopped = false;$/;"	m	class:reactor
_stopped	core/reactor.hh	/^    std::atomic<bool> _stopped = { false };$/;"	m	class:thread_pool
_task_quota	core/reactor.hh	/^    size_t _task_quota;$/;"	m	class:reactor
_tasks_processed	core/reactor.hh	/^    uint64_t _tasks_processed = 0;$/;"	m	class:reactor
_thread_pool	core/reactor.hh	/^    thread_pool _thread_pool;$/;"	m	class:reactor
_threads	core/reactor.hh	/^    static std::vector<thread_adaptor> _threads;$/;"	m	class:smp
_timer	core/reactor.hh	/^    timer<> _timer [[gnu::aligned(64)]];$/;"	m	class:lowres_clock
_timer	core/reactor.hh	/^    timer_t _timer;$/;"	m	class:reactor
_timer_cond	core/reactor.hh	/^    condvar _timer_cond;$/;"	m	class:reactor
_timer_due	core/reactor.hh	/^    s64 _timer_due = 0;$/;"	m	class:reactor
_timer_mutex	core/reactor.hh	/^    mutable mutex _timer_mutex;$/;"	m	class:reactor
_timer_promise	core/reactor.hh	/^    promise<> _timer_promise;$/;"	m	class:reactor_backend_osv
_timer_thread	core/reactor.hh	/^    sched::thread _timer_thread;$/;"	m	class:reactor
_timers	core/reactor.hh	/^    seastar::timer_set<timer<>, &timer<>::_link> _timers;$/;"	m	class:reactor
_tmain	core/reactor.hh	/^    static std::thread::id _tmain;$/;"	m	class:smp
_tx	core/reactor.hh	/^    } _tx;$/;"	m	class:smp_message_queue	typeref:union:smp_message_queue::tx_side
_worker_thread	core/reactor.hh	/^    posix_thread _worker_thread;$/;"	m	class:thread_pool
a	core/reactor.hh	/^        } a;$/;"	m	union:smp_message_queue::tx_side	typeref:struct:smp_message_queue::tx_side::aa
aa	core/reactor.hh	/^        struct aa {$/;"	s	union:smp_message_queue::tx_side
abort_accept	core/reactor.hh	/^    void abort_accept() {$/;"	f	class:server_socket
abort_reader	core/reactor.hh	/^	void abort_reader(pollable_fd_state& fd, std::exception_ptr ex) {$/;"	f	class:reactor
abort_reader	core/reactor.hh	/^pollable_fd::abort_reader(std::exception_ptr ex) {$/;"	f	class:pollable_fd
abort_writer	core/reactor.hh	/^    void abort_writer(pollable_fd_state& fd, std::exception_ptr ex) {$/;"	f	class:reactor
abort_writer	core/reactor.hh	/^pollable_fd::abort_writer(std::exception_ptr ex) {$/;"	f	class:pollable_fd
accept	core/reactor.hh	/^    future<connected_socket, socket_address> accept() {$/;"	f	class:server_socket
accept	core/reactor.hh	/^future<pollable_fd, socket_address> pollable_fd::accept() {$/;"	f	class:pollable_fd
accept	core/reactor.hh	/^reactor::accept(pollable_fd_state& listenfd) {$/;"	f	class:reactor
add_task	core/reactor.hh	/^    void add_task(std::unique_ptr<task>&& t) { _pending_tasks.push_back(std::move(t)); }$/;"	f	class:reactor
all_cpus	core/reactor.hh	/^    static boost::integer_range<unsigned> all_cpus() {$/;"	f	class:smp
allocate_aligned_buffer	core/reactor.hh	/^std::unique_ptr<CharType[], free_deleter> allocate_aligned_buffer(size_t size, size_t align) {$/;"	f
arm	core/reactor.hh	/^void timer<Clock>::arm(duration delta) {$/;"	f	class:timer
arm	core/reactor.hh	/^void timer<Clock>::arm(time_point until, std::experimental::optional<duration> period) {$/;"	f	class:timer
arm_periodic	core/reactor.hh	/^void timer<Clock>::arm_periodic(duration delta) {$/;"	f	class:timer
arm_state	core/reactor.hh	/^void timer<Clock>::arm_state(time_point until, std::experimental::optional<duration> period) {$/;"	f	class:timer
async_work_item	core/reactor.hh	/^        async_work_item(Func&& func) : _func(std::move(func)) {}$/;"	f	struct:smp_message_queue::async_work_item
async_work_item	core/reactor.hh	/^    struct async_work_item : work_item {$/;"	s	class:smp_message_queue
at_destroy	core/reactor.hh	/^    void at_destroy(Func&& func) {$/;"	f	class:reactor
at_exit	core/reactor.hh	/^    void at_exit(Func&& func) {$/;"	f	class:reactor
batch_size	core/reactor.hh	/^    static constexpr size_t batch_size = 16;$/;"	m	class:smp_message_queue
cancel	core/reactor.hh	/^bool timer<Clock>::cancel() {$/;"	f	class:timer
close	core/reactor.hh	/^    void close() { _s.reset(); }$/;"	f	class:pollable_fd
complete_timers	core/reactor.hh	/^void reactor::complete_timers(T& timers, E& expired_timers, EnableFunc&& enable_fn) {$/;"	f	class:reactor
connected_socket	core/reactor.hh	/^    connected_socket() {};$/;"	f	class:connected_socket
connected_socket	core/reactor.hh	/^    explicit connected_socket(std::unique_ptr<connected_socket_impl> csi)$/;"	f	class:connected_socket
connected_socket	core/reactor.hh	/^class connected_socket {$/;"	c
connected_socket_impl	core/reactor.hh	/^class connected_socket_impl {$/;"	c
count	core/reactor.hh	/^    static unsigned count;$/;"	m	class:smp
cpu_id	core/reactor.hh	/^    unsigned cpu_id() const { return _id; }$/;"	f	class:reactor
create	core/reactor.hh	/^    create = O_CREAT,$/;"	m	class:open_flags
cs	core/reactor.hh	/^    connected_socket& operator=(connected_socket&& cs) = default;$/;"	m	class:connected_socket
cs	core/reactor.hh	/^    connected_socket(connected_socket&& cs) = default;$/;"	m	class:connected_socket
duration	core/reactor.hh	/^    typedef std::chrono::duration<rep, period> duration;$/;"	t	class:lowres_clock
engine	core/reactor.hh	/^inline reactor& engine() {$/;"	f
events	core/reactor.hh	/^        int events = 0;$/;"	m	struct:pollable_fd_state::speculation
events_epoll	core/reactor.hh	/^    int events_epoll = 0;     \/\/ installed in epoll$/;"	m	class:pollable_fd_state
events_known	core/reactor.hh	/^    int events_known = 0;     \/\/ returned from epoll$/;"	m	class:pollable_fd_state
events_requested	core/reactor.hh	/^    int events_requested = 0; \/\/ wanted by pollin\/pollout promises$/;"	m	class:pollable_fd_state
exclusive	core/reactor.hh	/^    exclusive = O_EXCL,$/;"	m	class:open_flags
fd	core/reactor.hh	/^    file_desc fd;$/;"	m	class:pollable_fd_state
forget	core/reactor.hh	/^    void forget(pollable_fd_state& fd) {$/;"	f	class:reactor
free_deleter	core/reactor.hh	/^struct free_deleter {$/;"	s
get_fd	core/reactor.hh	/^    int get_fd() const { return _s->fd.get(); }$/;"	f	class:pollable_fd
get_file_desc	core/reactor.hh	/^    file_desc& get_file_desc() const { return _s->fd; }$/;"	f	class:pollable_fd
get_future	core/reactor.hh	/^        future<T> get_future() { return _promise.get_future(); }$/;"	f	struct:syscall_work_queue::work_item_returning
get_future	core/reactor.hh	/^        future_type get_future() { return _promise.get_future(); }$/;"	f	struct:smp_message_queue::async_work_item
get_read_fd	core/reactor.hh	/^    int get_read_fd() { return _fd.get(); }$/;"	f	class:writeable_eventfd
get_timeout	core/reactor.hh	/^typename timer<Clock>::time_point timer<Clock>::get_timeout() {$/;"	f	class:timer
get_write_fd	core/reactor.hh	/^    int get_write_fd() { return _fd.get_fd(); }$/;"	f	class:readable_eventfd
hash	core/reactor.hh	/^struct hash<::sockaddr_in> {$/;"	s	namespace:std
init	core/reactor.hh	/^        void init() { new (&a) aa; }$/;"	f	union:smp_message_queue::tx_side
initialize	core/reactor.hh	/^    virtual future<> initialize() {$/;"	f	class:network_stack
input	core/reactor.hh	/^connected_socket::input() {$/;"	f	class:connected_socket
inter_thread_wq	core/reactor.hh	/^    syscall_work_queue inter_thread_wq;$/;"	m	class:thread_pool
iovec_len	core/reactor.hh	/^size_t iovec_len(const iovec* begin, size_t len)$/;"	f
iovec_len	core/reactor.hh	/^size_t iovec_len(const std::vector<iovec>& iov)$/;"	f
kj_accept	core/reactor.hh	/^    virtual kj::Promise<std::pair<connected_socket, socket_address>> kj_accept(){$/;"	f	class:server_socket
kj_accept	core/reactor.hh	/^kj::Promise<std::pair<pollable_fd, socket_address>> pollable_fd::kj_accept() {$/;"	f	class:pollable_fd
kj_accept	core/reactor.hh	/^reactor::kj_accept(pollable_fd_state& listenfd) {        $/;"	f	class:reactor
kj_notified	core/reactor.hh	/^    kj::Promise<void> kj_notified(reactor_notifier *n) {$/;"	f	class:reactor
kj_pollin	core/reactor.hh	/^    kj::Own<kj::PromiseFulfiller<void>> kj_pollin;$/;"	m	class:pollable_fd_state
kj_pollout	core/reactor.hh	/^    kj::Own<kj::PromiseFulfiller<void>> kj_pollout;$/;"	m	class:pollable_fd_state
kj_read_some	core/reactor.hh	/^kj::Promise<size_t> pollable_fd::kj_read_some(char* buffer, size_t size) {$/;"	f	class:pollable_fd
kj_read_some	core/reactor.hh	/^kj::Promise<size_t> pollable_fd::kj_read_some(const std::vector<iovec>& iov) {$/;"	f	class:pollable_fd
kj_read_some	core/reactor.hh	/^kj::Promise<size_t> pollable_fd::kj_read_some(uint8_t* buffer, size_t size) {$/;"	f	class:pollable_fd
kj_read_some	core/reactor.hh	/^reactor::kj_read_some(pollable_fd_state& fd, const std::vector<iovec>& iov) {    $/;"	f	class:reactor
kj_read_some	core/reactor.hh	/^reactor::kj_read_some(pollable_fd_state& fd, void* buffer, size_t len) {        $/;"	f	class:reactor
kj_readable	core/reactor.hh	/^    kj::Promise<void> kj_readable(pollable_fd_state& fd) {$/;"	f	class:reactor
kj_readable	core/reactor.hh	/^kj::Promise<void> pollable_fd::kj_readable() {$/;"	f	class:pollable_fd
kj_recvmsg	core/reactor.hh	/^kj::Promise<size_t> pollable_fd::kj_recvmsg(struct msghdr *msg) {$/;"	f	class:pollable_fd
kj_sendmsg	core/reactor.hh	/^kj::Promise<size_t> pollable_fd::kj_sendmsg(struct msghdr* msg) {$/;"	f	class:pollable_fd
kj_sendto	core/reactor.hh	/^kj::Promise<size_t> pollable_fd::kj_sendto(socket_address addr, const void* buf, size_t len) {$/;"	f	class:pollable_fd
kj_start_epoll	core/reactor.hh	/^    void kj_start_epoll() {$/;"	f	class:reactor
kj_submit	core/reactor.hh	/^    kj::Promise<T> kj_submit(Func func) {$/;"	f	class:syscall_work_queue
kj_wait_and_process	core/reactor.hh	/^    bool kj_wait_and_process() {$/;"	f	class:reactor
kj_write_all	core/reactor.hh	/^kj::Promise<void> pollable_fd::kj_write_all(const char* buffer, size_t size) {$/;"	f	class:pollable_fd
kj_write_all	core/reactor.hh	/^kj::Promise<void> pollable_fd::kj_write_all(const uint8_t* buffer, size_t size) {$/;"	f	class:pollable_fd
kj_write_all	core/reactor.hh	/^kj::Promise<void> pollable_fd::kj_write_all(net::packet& p) {$/;"	f	class:pollable_fd
kj_write_all	core/reactor.hh	/^reactor::kj_write_all(pollable_fd_state& fd, const void* buffer, size_t len) {$/;"	f	class:reactor
kj_write_all_part	core/reactor.hh	/^reactor::kj_write_all_part(pollable_fd_state& fd, const void* buffer, size_t len, size_t completed) {$/;"	f	class:reactor
kj_write_some	core/reactor.hh	/^kj::Promise<size_t> pollable_fd::kj_write_some(net::packet& p) {$/;"	f	class:pollable_fd
kj_write_some	core/reactor.hh	/^reactor::kj_write_some(pollable_fd_state& fd, const void* buffer, size_t len) {$/;"	f	class:reactor
kj_writeable	core/reactor.hh	/^    kj::Promise<void> kj_writeable(pollable_fd_state& fd) {$/;"	f	class:reactor
kj_writeable	core/reactor.hh	/^kj::Promise<void> pollable_fd::kj_writeable() {$/;"	f	class:pollable_fd
lowres_clock	core/reactor.hh	/^class lowres_clock {$/;"	c
main_thread	core/reactor.hh	/^    static bool main_thread() { return std::this_thread::get_id() == _tmain; }$/;"	f	class:smp
make_pollfn	core/reactor.hh	/^reactor::make_pollfn(Func&& func) {$/;"	f	class:reactor
make_reactor_notifier	core/reactor.hh	/^    std::unique_ptr<reactor_notifier> make_reactor_notifier() {$/;"	f	class:reactor
max_aio	core/reactor.hh	/^    static constexpr size_t max_aio = 128;$/;"	m	class:reactor
net	core/reactor.hh	/^    network_stack& net() { return *_network_stack; }$/;"	f	class:reactor
network_stack	core/reactor.hh	/^class network_stack {$/;"	c
network_stack_registrator	core/reactor.hh	/^    explicit network_stack_registrator(sstring name,$/;"	f	class:network_stack_registrator
network_stack_registrator	core/reactor.hh	/^class network_stack_registrator {$/;"	c
network_stack_registry	core/reactor.hh	/^class network_stack_registry {$/;"	c
notified	core/reactor.hh	/^    future<> notified(reactor_notifier *n) {$/;"	f	class:reactor
now	core/reactor.hh	/^    static time_point now() {$/;"	f	class:lowres_clock
open_flags	core/reactor.hh	/^enum class open_flags {$/;"	c
operation_count	core/reactor.hh	/^    uint64_t operation_count() const { return _aio_threaded_fallbacks; }$/;"	f	class:thread_pool
operator ()	core/reactor.hh	/^    size_t operator()(::sockaddr_in a) const {$/;"	f	struct:std::hash
operator ()	core/reactor.hh	/^    void operator()(void* p) { ::free(p); }$/;"	f	struct:free_deleter
operator |	core/reactor.hh	/^inline open_flags operator|(open_flags a, open_flags b) {$/;"	f
options_description	core/reactor.hh	/^    static boost::program_options::options_description& options_description() {$/;"	f	class:network_stack_registry
output	core/reactor.hh	/^connected_socket::output() {$/;"	f	class:connected_socket
override	core/reactor.hh	/^    virtual bool kj_wait_and_process() override;$/;"	m	class:reactor_backend_epoll
override	core/reactor.hh	/^    virtual bool kj_wait_and_process() override;$/;"	m	class:reactor_backend_osv
override	core/reactor.hh	/^    virtual bool wait_and_process() override;$/;"	m	class:reactor_backend_epoll
override	core/reactor.hh	/^    virtual bool wait_and_process() override;$/;"	m	class:reactor_backend_osv
override	core/reactor.hh	/^    virtual future<> notified(reactor_notifier *n) override;$/;"	m	class:reactor_backend_epoll
override	core/reactor.hh	/^    virtual future<> notified(reactor_notifier *n) override;$/;"	m	class:reactor_backend_osv
override	core/reactor.hh	/^    virtual future<> readable(pollable_fd_state& fd) override;$/;"	m	class:reactor_backend_epoll
override	core/reactor.hh	/^    virtual future<> readable(pollable_fd_state& fd) override;$/;"	m	class:reactor_backend_osv
override	core/reactor.hh	/^    virtual future<> writeable(pollable_fd_state& fd) override;$/;"	m	class:reactor_backend_epoll
override	core/reactor.hh	/^    virtual future<> writeable(pollable_fd_state& fd) override;$/;"	m	class:reactor_backend_osv
override	core/reactor.hh	/^    virtual kj::Promise<void> kj_notified(reactor_notifier *n) override;$/;"	m	class:reactor_backend_epoll
override	core/reactor.hh	/^    virtual kj::Promise<void> kj_notified(reactor_notifier *n) override;$/;"	m	class:reactor_backend_osv
override	core/reactor.hh	/^    virtual kj::Promise<void> kj_readable(pollable_fd_state& fd) override;$/;"	m	class:reactor_backend_epoll
override	core/reactor.hh	/^    virtual kj::Promise<void> kj_readable(pollable_fd_state& fd) override;$/;"	m	class:reactor_backend_osv
override	core/reactor.hh	/^    virtual kj::Promise<void> kj_writeable(pollable_fd_state& fd) override;$/;"	m	class:reactor_backend_epoll
override	core/reactor.hh	/^    virtual kj::Promise<void> kj_writeable(pollable_fd_state& fd) override;$/;"	m	class:reactor_backend_osv
override	core/reactor.hh	/^    virtual std::unique_ptr<reactor_notifier> make_reactor_notifier() override;$/;"	m	class:reactor_backend_epoll
override	core/reactor.hh	/^    virtual std::unique_ptr<reactor_notifier> make_reactor_notifier() override;$/;"	m	class:reactor_backend_osv
override	core/reactor.hh	/^    virtual void forget(pollable_fd_state& fd) override;$/;"	m	class:reactor_backend_epoll
override	core/reactor.hh	/^    virtual void forget(pollable_fd_state& fd) override;$/;"	m	class:reactor_backend_osv
pending_fifo	core/reactor.hh	/^            std::deque<work_item*> pending_fifo;$/;"	m	struct:smp_message_queue::tx_side::aa
period	core/reactor.hh	/^    typedef std::ratio<1, 1000> period;$/;"	t	class:lowres_clock
poll_queues	core/reactor.hh	/^    static bool poll_queues() {$/;"	f	class:smp
pollable_fd	core/reactor.hh	/^    pollable_fd(file_desc fd, speculation speculate = speculation())$/;"	f	class:pollable_fd
pollable_fd	core/reactor.hh	/^class pollable_fd {$/;"	c
pollable_fd_state	core/reactor.hh	/^    explicit pollable_fd_state(file_desc fd, speculation speculate = speculation())$/;"	f	class:pollable_fd_state
pollable_fd_state	core/reactor.hh	/^class pollable_fd_state {$/;"	c
poller	core/reactor.hh	/^        explicit poller(Func&& poll_and_check_more_work)$/;"	f	class:reactor::poller
poller	core/reactor.hh	/^    class poller {$/;"	c	class:reactor
pollfn	core/reactor.hh	/^    struct pollfn {$/;"	s	class:reactor
pollin	core/reactor.hh	/^    promise<> pollin;$/;"	m	class:pollable_fd_state
pollout	core/reactor.hh	/^    promise<> pollout;$/;"	m	class:pollable_fd_state
posix_reuseport_available	core/reactor.hh	/^    bool posix_reuseport_available() const { return _reuseport; }$/;"	f	class:reactor
prefetch_cnt	core/reactor.hh	/^    static constexpr size_t prefetch_cnt = 2;$/;"	m	class:smp_message_queue
queue_length	core/reactor.hh	/^    static constexpr size_t queue_length = 128;$/;"	m	class:smp_message_queue
queue_length	core/reactor.hh	/^    static constexpr size_t queue_length = 128;$/;"	m	class:syscall_work_queue
reactor	core/reactor.hh	/^class reactor : public kj::EventLoop {$/;"	c
reactor_backend	core/reactor.hh	/^class reactor_backend {$/;"	c
reactor_backend_epoll	core/reactor.hh	/^class reactor_backend_epoll : public reactor_backend {$/;"	c
reactor_backend_osv	core/reactor.hh	/^class reactor_backend_osv : public reactor_backend {$/;"	c
reactor_notifier	core/reactor.hh	/^class reactor_notifier {$/;"	c
read_some	core/reactor.hh	/^future<size_t> pollable_fd::read_some(char* buffer, size_t size) {$/;"	f	class:pollable_fd
read_some	core/reactor.hh	/^future<size_t> pollable_fd::read_some(const std::vector<iovec>& iov) {$/;"	f	class:pollable_fd
read_some	core/reactor.hh	/^future<size_t> pollable_fd::read_some(uint8_t* buffer, size_t size) {$/;"	f	class:pollable_fd
read_some	core/reactor.hh	/^reactor::read_some(pollable_fd_state& fd, const std::vector<iovec>& iov) {$/;"	f	class:reactor
read_some	core/reactor.hh	/^reactor::read_some(pollable_fd_state& fd, void* buffer, size_t len) {$/;"	f	class:reactor
readable	core/reactor.hh	/^    future<> readable(pollable_fd_state& fd) {$/;"	f	class:reactor
readable	core/reactor.hh	/^future<> pollable_fd::readable() {$/;"	f	class:pollable_fd
readable_eventfd	core/reactor.hh	/^    explicit readable_eventfd(file_desc&& fd) : _fd(std::move(fd)) {}$/;"	f	class:readable_eventfd
readable_eventfd	core/reactor.hh	/^    explicit readable_eventfd(size_t initial = 0) : _fd(try_create_eventfd(initial)) {}$/;"	f	class:readable_eventfd
readable_eventfd	core/reactor.hh	/^class readable_eventfd {$/;"	c
readd_periodic	core/reactor.hh	/^void timer<Clock>::readd_periodic() {$/;"	f	class:timer
rearm	core/reactor.hh	/^void timer<Clock>::rearm(time_point until, std::experimental::optional<duration> period) {$/;"	f	class:timer
recvmsg	core/reactor.hh	/^future<size_t> pollable_fd::recvmsg(struct msghdr *msg) {$/;"	f	class:pollable_fd
rep	core/reactor.hh	/^    typedef int64_t rep;$/;"	t	class:lowres_clock
ro	core/reactor.hh	/^    ro = O_RDONLY,$/;"	m	class:open_flags
rw	core/reactor.hh	/^    rw = O_RDWR,$/;"	m	class:open_flags
scollectd	core/reactor.hh	/^namespace scollectd { class registration; }$/;"	n
sendmsg	core/reactor.hh	/^future<size_t> pollable_fd::sendmsg(struct msghdr* msg) {$/;"	f	class:pollable_fd
sendto	core/reactor.hh	/^future<size_t> pollable_fd::sendto(socket_address addr, const void* buf, size_t len) {$/;"	f	class:pollable_fd
server_socket	core/reactor.hh	/^    explicit server_socket(std::unique_ptr<server_socket_impl> ssi)$/;"	f	class:server_socket
server_socket	core/reactor.hh	/^class server_socket {$/;"	c
server_socket_impl	core/reactor.hh	/^class server_socket_impl {$/;"	c
set_callback	core/reactor.hh	/^void timer<Clock>::set_callback(callback_t&& callback) {$/;"	f	class:timer
shutdown	core/reactor.hh	/^    void shutdown(int how) { _s->fd.shutdown(how); }$/;"	f	class:pollable_fd
shutdown_input	core/reactor.hh	/^connected_socket::shutdown_input() {$/;"	f	class:connected_socket
shutdown_output	core/reactor.hh	/^connected_socket::shutdown_output() {$/;"	f	class:connected_socket
signal_handler	core/reactor.hh	/^        struct signal_handler {$/;"	s	class:reactor::signals
signals	core/reactor.hh	/^    class signals {$/;"	c	class:reactor
smp	core/reactor.hh	/^class smp {$/;"	c
smp_message_queue	core/reactor.hh	/^class smp_message_queue {$/;"	c
speculate_epoll	core/reactor.hh	/^    void speculate_epoll(int events) { events_known |= events; }$/;"	f	class:pollable_fd_state
speculation	core/reactor.hh	/^        explicit speculation(int epoll_events_guessed = 0) : events(epoll_events_guessed) {}$/;"	f	struct:pollable_fd_state::speculation
speculation	core/reactor.hh	/^    struct speculation {$/;"	s	class:pollable_fd_state
start_epoll	core/reactor.hh	/^    void start_epoll() {        $/;"	f	class:reactor
std	core/reactor.hh	/^namespace std {$/;"	n
submit	core/reactor.hh	/^    future<T> submit(Func func) { std::cout << "thread_pool not yet implemented on osv\\n"; abort(); }$/;"	f	class:thread_pool
submit	core/reactor.hh	/^    future<T> submit(Func func) {$/;"	f	class:syscall_work_queue
submit	core/reactor.hh	/^    future<T> submit(Func func) {return inter_thread_wq.submit<T>(std::move(func));}$/;"	f	class:thread_pool
submit	core/reactor.hh	/^    futurize_t<std::result_of_t<Func()>> submit(Func&& func) {$/;"	f	class:smp_message_queue
submit_to	core/reactor.hh	/^    static futurize_t<std::result_of_t<Func()>> submit_to(unsigned t, Func&& func) {$/;"	f	class:smp
syscall_work_queue	core/reactor.hh	/^class syscall_work_queue {$/;"	c
thread_pool	core/reactor.hh	/^class thread_pool {$/;"	c
time_point	core/reactor.hh	/^    typedef std::chrono::time_point<lowres_clock, duration> time_point;$/;"	t	class:lowres_clock
timer	core/reactor.hh	/^timer<Clock>::timer(callback_t&& callback) : _callback(std::move(callback)) {$/;"	f	class:timer
truncate	core/reactor.hh	/^    truncate = O_TRUNC,$/;"	m	class:open_flags
tx_side	core/reactor.hh	/^        tx_side() {}$/;"	f	union:smp_message_queue::tx_side
tx_side	core/reactor.hh	/^    union tx_side {$/;"	u	class:smp_message_queue
wait_and_process	core/reactor.hh	/^    bool wait_and_process() {$/;"	f	class:reactor
when_started	core/reactor.hh	/^    future<> when_started() { return _start_promise.get_future(); }$/;"	f	class:reactor
wo	core/reactor.hh	/^    wo = O_WRONLY,$/;"	m	class:open_flags
work_item	core/reactor.hh	/^    struct work_item {$/;"	s	class:smp_message_queue
work_item	core/reactor.hh	/^    struct work_item {$/;"	s	class:syscall_work_queue
work_item_returning	core/reactor.hh	/^        work_item_returning(Func&& func) : _func(std::move(func)) {}$/;"	f	struct:syscall_work_queue::work_item_returning
work_item_returning	core/reactor.hh	/^    struct work_item_returning :  work_item {$/;"	s	class:syscall_work_queue
write_all	core/reactor.hh	/^future<> pollable_fd::write_all(const char* buffer, size_t size) {$/;"	f	class:pollable_fd
write_all	core/reactor.hh	/^future<> pollable_fd::write_all(const uint8_t* buffer, size_t size) {$/;"	f	class:pollable_fd
write_all	core/reactor.hh	/^future<> pollable_fd::write_all(net::packet& p) {$/;"	f	class:pollable_fd
write_all	core/reactor.hh	/^reactor::write_all(pollable_fd_state& fd, const void* buffer, size_t len) {$/;"	f	class:reactor
write_all_part	core/reactor.hh	/^reactor::write_all_part(pollable_fd_state& fd, const void* buffer, size_t len, size_t completed) {$/;"	f	class:reactor
write_some	core/reactor.hh	/^future<size_t> pollable_fd::write_some(net::packet& p) {$/;"	f	class:pollable_fd
write_some	core/reactor.hh	/^reactor::write_some(pollable_fd_state& fd, const void* buffer, size_t len) {$/;"	f	class:reactor
writeable	core/reactor.hh	/^    future<> writeable(pollable_fd_state& fd) {$/;"	f	class:reactor
writeable	core/reactor.hh	/^future<> pollable_fd::writeable() {$/;"	f	class:pollable_fd
writeable_eventfd	core/reactor.hh	/^    explicit writeable_eventfd(file_desc&& fd) : _fd(std::move(fd)) {}$/;"	f	class:writeable_eventfd
writeable_eventfd	core/reactor.hh	/^    explicit writeable_eventfd(size_t initial = 0) : _fd(try_create_eventfd(initial)) {}$/;"	f	class:writeable_eventfd
writeable_eventfd	core/reactor.hh	/^class writeable_eventfd {$/;"	c
~connected_socket_impl	core/reactor.hh	/^    virtual ~connected_socket_impl() {}$/;"	f	class:connected_socket_impl
~network_stack	core/reactor.hh	/^    virtual ~network_stack() {}$/;"	f	class:network_stack
~pollable_fd_state	core/reactor.hh	/^pollable_fd_state::~pollable_fd_state() {$/;"	f	class:pollable_fd_state
~pollfn	core/reactor.hh	/^        virtual ~pollfn() {}$/;"	f	struct:reactor::pollfn
~reactor	core/reactor.hh	/^    ~reactor() {$/;"	f	class:reactor
~reactor_backend	core/reactor.hh	/^    virtual ~reactor_backend() {};$/;"	f	class:reactor_backend
~reactor_notifier	core/reactor.hh	/^    virtual ~reactor_notifier() {}$/;"	f	class:reactor_notifier
~server_socket_impl	core/reactor.hh	/^    virtual ~server_socket_impl() {}$/;"	f	class:server_socket_impl
~timer	core/reactor.hh	/^timer<Clock>::~timer() {$/;"	f	class:timer
~tx_side	core/reactor.hh	/^        ~tx_side() {}$/;"	f	union:smp_message_queue::tx_side
~work_item	core/reactor.hh	/^        virtual ~work_item() {}$/;"	f	struct:smp_message_queue::work_item
~work_item	core/reactor.hh	/^        virtual ~work_item() {}$/;"	f	struct:syscall_work_queue::work_item
alloc_from_node	core/resource.cc	/^static size_t alloc_from_node(cpu& this_cpu, hwloc_obj_t node, std::unordered_map<hwloc_obj_t, size_t>& used_mem, size_t alloc) {$/;"	f	namespace:resource
allocate	core/resource.cc	/^std::vector<cpu> allocate(configuration c) {$/;"	f	namespace:resource
cpuid_to_cpuset	core/resource.cc	/^cpu_set_t cpuid_to_cpuset(unsigned cpuid) {$/;"	f
div_roundup	core/resource.cc	/^size_t div_roundup(size_t num, size_t denom) {$/;"	f	namespace:resource
find_memory_depth	core/resource.cc	/^static unsigned find_memory_depth(hwloc_topology_t& topology) {$/;"	f	namespace:resource
nr_processing_units	core/resource.cc	/^unsigned nr_processing_units() {$/;"	f	namespace:resource
resource	core/resource.cc	/^namespace resource {$/;"	n	file:
RESOURCE_HH_	core/resource.hh	23;"	d
bytes	core/resource.hh	/^    size_t bytes;$/;"	m	struct:resource::memory
configuration	core/resource.hh	/^struct configuration {$/;"	s	namespace:resource
cpu	core/resource.hh	/^struct cpu {$/;"	s	namespace:resource
cpu_id	core/resource.hh	/^    unsigned cpu_id;$/;"	m	struct:resource::cpu
cpu_set	core/resource.hh	/^    optional<cpuset> cpu_set;$/;"	m	struct:resource::configuration
cpus	core/resource.hh	/^    optional<size_t> cpus;$/;"	m	struct:resource::configuration
mem	core/resource.hh	/^    std::vector<memory> mem;$/;"	m	struct:resource::cpu
memory	core/resource.hh	/^struct memory {$/;"	s	namespace:resource
nodeid	core/resource.hh	/^    unsigned nodeid;$/;"	m	struct:resource::memory
reserve_memory	core/resource.hh	/^    optional<size_t> reserve_memory;  \/\/ if total_memory not specified$/;"	m	struct:resource::configuration
resource	core/resource.hh	/^namespace resource {$/;"	n
total_memory	core/resource.hh	/^    optional<size_t> total_memory;$/;"	m	struct:resource::configuration
CORE_RWLOCK_HH_	core/rwlock.hh	23;"	d
_sem	core/rwlock.hh	/^    semaphore _sem;$/;"	m	class:rwlock
max_ops	core/rwlock.hh	/^    static const size_t max_ops = std::numeric_limits<size_t>::max();$/;"	m	class:rwlock
read_lock	core/rwlock.hh	/^    future<> read_lock() {$/;"	f	class:rwlock
read_unlock	core/rwlock.hh	/^    void read_unlock() {$/;"	f	class:rwlock
rwlock	core/rwlock.hh	/^    rwlock()$/;"	f	class:rwlock
rwlock	core/rwlock.hh	/^class rwlock {$/;"	c
try_read_lock	core/rwlock.hh	/^    bool try_read_lock() {$/;"	f	class:rwlock
try_write_lock	core/rwlock.hh	/^    bool try_write_lock() {$/;"	f	class:rwlock
write_lock	core/rwlock.hh	/^    future<> write_lock() {$/;"	f	class:rwlock
write_unlock	core/rwlock.hh	/^    void write_unlock() {$/;"	f	class:rwlock
SCATTERED_MESSAGE_HH	core/scattered_message.hh	23;"	d
append	core/scattered_message.hh	/^    void append(basic_sstring<char_type, size_type, max_size> s) {$/;"	f	class:scattered_message
append	core/scattered_message.hh	/^    void append(const basic_sstring<char_type, size_type, max_size>& s, Callback callback) {$/;"	f	class:scattered_message
append_static	core/scattered_message.hh	/^    void append_static(const basic_sstring<char_type, size_type, max_size>& s) {$/;"	f	class:scattered_message
append_static	core/scattered_message.hh	/^    void append_static(const char_type* buf, size_t size) {$/;"	f	class:scattered_message
append_static	core/scattered_message.hh	/^    void append_static(const char_type* s) {$/;"	f	class:scattered_message
append_static	core/scattered_message.hh	/^    void append_static(const std::experimental::string_view& s) {$/;"	f	class:scattered_message
on_delete	core/scattered_message.hh	/^    void on_delete(Callback callback) {$/;"	f	class:scattered_message
operator bool	core/scattered_message.hh	/^    operator bool() const {$/;"	f	class:scattered_message
release	core/scattered_message.hh	/^    packet release() && {$/;"	f	class:scattered_message
reserve	core/scattered_message.hh	/^    void reserve(int n_frags) {$/;"	f	class:scattered_message
scattered_message	core/scattered_message.hh	/^    scattered_message() {}$/;"	f	class:scattered_message
scattered_message	core/scattered_message.hh	/^class scattered_message {$/;"	c
size	core/scattered_message.hh	/^    size_t size() {$/;"	f	class:scattered_message
Encryption	core/scollectd.cc	/^        Encryption = 0x0210, \/\/	Encryption (AES-256\/OFB$/;"	m	class:scollectd::impl::part_type	file:
Host	core/scollectd.cc	/^            Host = 0x0000, \/\/ The name of the host to associate with subsequent data values$/;"	m	class:scollectd::impl::part_type	file:
Interval	core/scollectd.cc	/^        Interval = 0x0007, \/\/ Interval Numeric Interval used to set the "step" when creating new RRDs unless rrdtool plugin forces StepSize. Also used to detect values that have timed out.$/;"	m	class:scollectd::impl::part_type	file:
IntervalHr	core/scollectd.cc	/^        IntervalHr = 0x0009, \/\/	Interval (high resolution) 	Numeric 	The interval in which subsequent data values are collected. The interval is given in 230 seconds. New in Version 5.0.$/;"	m	class:scollectd::impl::part_type	file:
Message	core/scollectd.cc	/^        Message = 0x0100, \/\/ Message (notifications) String$/;"	m	class:scollectd::impl::part_type	file:
Plugin	core/scollectd.cc	/^        Plugin = 0x0002, \/\/ Plugin String The plugin name to associate with subsequent data values, e.g. "cpu"$/;"	m	class:scollectd::impl::part_type	file:
PluginInst	core/scollectd.cc	/^        PluginInst = 0x0003, \/\/ Plugin instance String 	The plugin instance name to associate with subsequent data values, e.g. "1"$/;"	m	class:scollectd::impl::part_type	file:
Severity	core/scollectd.cc	/^        Severity = 0x0101, \/\/ Severity 	Numeric$/;"	m	class:scollectd::impl::part_type	file:
Signature	core/scollectd.cc	/^        Signature = 0x0200, \/\/ Signature (HMAC-SHA-256) 	other (todo)$/;"	m	class:scollectd::impl::part_type	file:
Time	core/scollectd.cc	/^        Time = 0x0001, \/\/ Time 	Numeric The timestamp to associate with subsequent data values, unix time format (seconds since epoch)$/;"	m	class:scollectd::impl::part_type	file:
TimeHr	core/scollectd.cc	/^        TimeHr = 0x0008, \/\/ Time (high resolution) 	Numeric The timestamp to associate with subsequent data values. Time is defined in 230 seconds since epoch. New in Version 5.0.$/;"	m	class:scollectd::impl::part_type	file:
Type	core/scollectd.cc	/^        Type = 0x0004, \/\/ Type String The type name to associate with subsequent data values, e.g. "cpu"$/;"	m	class:scollectd::impl::part_type	file:
TypeInst	core/scollectd.cc	/^        TypeInst = 0x0005, \/\/ Type instance 	String 	The type instance name to associate with subsequent data values, e.g. "idle"$/;"	m	class:scollectd::impl::part_type	file:
Values	core/scollectd.cc	/^        Values = 0x0006, \/\/	Values 	other 	Data values, see above$/;"	m	class:scollectd::impl::part_type	file:
_addr	core/scollectd.cc	/^    ipv4_addr _addr = default_addr;$/;"	m	class:scollectd::impl	file:
_avg	core/scollectd.cc	/^    double _avg = 0;$/;"	m	class:scollectd::impl	file:
_buf	core/scollectd.cc	/^        buffer_type _buf;$/;"	m	struct:scollectd::impl::cpwriter	file:
_bytes	core/scollectd.cc	/^    uint64_t _bytes = 0;$/;"	m	class:scollectd::impl	file:
_cache	core/scollectd.cc	/^        std::unordered_map<uint16_t, sstring> _cache;$/;"	m	struct:scollectd::impl::cpwriter	file:
_chan	core/scollectd.cc	/^    net::udp_channel _chan;$/;"	m	class:scollectd::impl	file:
_host	core/scollectd.cc	/^    sstring _host = "localhost";$/;"	m	class:scollectd::impl	file:
_millis	core/scollectd.cc	/^    uint64_t _millis = 0;$/;"	m	class:scollectd::impl	file:
_num_packets	core/scollectd.cc	/^    uint64_t _num_packets = 0;$/;"	m	class:scollectd::impl	file:
_overflow	core/scollectd.cc	/^        bool _overflow = false;$/;"	m	struct:scollectd::impl::cpwriter	file:
_period	core/scollectd.cc	/^    clock_type::duration _period = default_period;$/;"	m	class:scollectd::impl	file:
_pos	core/scollectd.cc	/^        mark_type _pos;$/;"	m	struct:scollectd::impl::cpwriter	file:
_regs	core/scollectd.cc	/^    registrations _regs;$/;"	m	class:scollectd::impl	file:
_timer	core/scollectd.cc	/^    timer<> _timer;$/;"	m	class:scollectd::impl	file:
_values	core/scollectd.cc	/^    value_list_map _values;$/;"	m	class:scollectd::impl	file:
add_polled	core/scollectd.cc	/^    void add_polled(const type_instance_id & id,$/;"	f	class:scollectd::impl
add_polled	core/scollectd.cc	/^void add_polled(const type_instance_id & id,$/;"	f	namespace:scollectd
arm	core/scollectd.cc	/^    void arm() {$/;"	f	class:scollectd::impl	file:
buffer_type	core/scollectd.cc	/^        typedef std::array<char, payload_size> buffer_type;$/;"	t	struct:scollectd::impl::cpwriter	file:
check	core/scollectd.cc	/^        cpwriter& check(size_t sz) {$/;"	f	struct:scollectd::impl::cpwriter
clear	core/scollectd.cc	/^        void clear() {$/;"	f	struct:scollectd::impl::cpwriter
collectd_hres_duration	core/scollectd.cc	/^    typedef std::chrono::duration<uint64_t, std::ratio<1, 0x40000000>> collectd_hres_duration;$/;"	t	class:scollectd::impl	file:
configure	core/scollectd.cc	/^void configure(const boost::program_options::variables_map & opts) {$/;"	f	namespace:scollectd
const_mark_type	core/scollectd.cc	/^        typedef buffer_type::const_iterator const_mark_type;$/;"	t	struct:scollectd::impl::cpwriter	file:
cpwriter	core/scollectd.cc	/^        cpwriter()$/;"	f	struct:scollectd::impl::cpwriter
cpwriter	core/scollectd.cc	/^    struct cpwriter {$/;"	s	class:scollectd::impl	file:
data	core/scollectd.cc	/^        char * data() {$/;"	f	struct:scollectd::impl::cpwriter
data	core/scollectd.cc	/^        const char * data() const {$/;"	f	struct:scollectd::impl::cpwriter
empty	core/scollectd.cc	/^        bool empty() const {$/;"	f	struct:scollectd::impl::cpwriter
get_collectd_ids	core/scollectd.cc	/^std::vector<scollectd::type_instance_id> get_collectd_ids() {$/;"	f	namespace:scollectd
get_collectd_types	core/scollectd.cc	/^std::vector<data_type> get_collectd_types($/;"	f	namespace:scollectd
get_collectd_value	core/scollectd.cc	/^std::vector<collectd_value> get_collectd_value($/;"	f	namespace:scollectd
get_impl	core/scollectd.cc	/^impl & get_impl() {$/;"	f	namespace:scollectd
get_instance_ids	core/scollectd.cc	/^    std::vector<type_instance_id> get_instance_ids() {$/;"	f	class:scollectd::impl
get_options_description	core/scollectd.cc	/^boost::program_options::options_description get_options_description() {$/;"	f	namespace:scollectd
get_values	core/scollectd.cc	/^    shared_ptr<value_list> get_values(const type_instance_id & id) {$/;"	f	class:scollectd::impl
impl	core/scollectd.cc	/^class impl {$/;"	c	namespace:scollectd	file:
kj_configure	core/scollectd.cc	/^void kj_configure(const boost::program_options::variables_map & opts, kj::WaitScope& waitScope) {$/;"	f	namespace:scollectd
kj_send_metric	core/scollectd.cc	/^    kj::Promise<void> kj_send_metric(const type_instance_id & id,$/;"	f	class:scollectd::impl
kj_send_metric	core/scollectd.cc	/^kj::Promise<void> kj_send_metric(const type_instance_id & id,$/;"	f	namespace:scollectd
kj_send_notification	core/scollectd.cc	/^    kj::Promise<void> kj_send_notification(const type_instance_id & id,$/;"	f	class:scollectd::impl
kj_send_notification	core/scollectd.cc	/^kj::Promise<void> kj_send_notification(const type_instance_id & id,$/;"	f	namespace:scollectd
kj_start	core/scollectd.cc	/^    kj::Promise<void> kj_start(const std::string & host, const ipv4_addr & addr,$/;"	f	class:scollectd::impl
mark	core/scollectd.cc	/^        mark_type mark() const {$/;"	f	struct:scollectd::impl::cpwriter
mark_type	core/scollectd.cc	/^        typedef buffer_type::iterator mark_type;$/;"	t	struct:scollectd::impl::cpwriter	file:
operator !	core/scollectd.cc	/^        bool operator!() const {$/;"	f	struct:scollectd::impl::cpwriter
operator <	core/scollectd.cc	/^bool scollectd::type_instance_id::operator<($/;"	f	class:scollectd::type_instance_id
operator ==	core/scollectd.cc	/^bool scollectd::type_instance_id::operator==($/;"	f	class:scollectd::type_instance_id
operator bool	core/scollectd.cc	/^        explicit operator bool() const {$/;"	f	struct:scollectd::impl::cpwriter
overflow	core/scollectd.cc	/^        bool overflow() const {$/;"	f	struct:scollectd::impl::cpwriter
part_type	core/scollectd.cc	/^    enum class part_type$/;"	c	class:scollectd::impl	file:
payload_size	core/scollectd.cc	/^    static const size_t payload_size = 1024;$/;"	m	class:scollectd::impl	file:
put	core/scollectd.cc	/^        cpwriter & put(const sstring & host, const type_instance_id & id) {$/;"	f	struct:scollectd::impl::cpwriter
put	core/scollectd.cc	/^        cpwriter & put(const sstring & host,$/;"	f	struct:scollectd::impl::cpwriter
put	core/scollectd.cc	/^        cpwriter & put(part_type type, const sstring & s) {$/;"	f	struct:scollectd::impl::cpwriter
put	core/scollectd.cc	/^        cpwriter & put(part_type type, const value_list & v) {$/;"	f	struct:scollectd::impl::cpwriter
put	core/scollectd.cc	/^        typename std::enable_if<std::is_integral<T>::value, cpwriter &>::type put($/;"	f	struct:scollectd::impl::cpwriter
put_cached	core/scollectd.cc	/^        cpwriter & put_cached(part_type type, const sstring & s) {$/;"	f	struct:scollectd::impl::cpwriter
remove_polled	core/scollectd.cc	/^    void remove_polled(const type_instance_id & id) {$/;"	f	class:scollectd::impl
remove_polled_metric	core/scollectd.cc	/^void remove_polled_metric(const type_instance_id & id) {$/;"	f	namespace:scollectd
reset	core/scollectd.cc	/^        void reset(mark_type m) {$/;"	f	struct:scollectd::impl::cpwriter
run	core/scollectd.cc	/^    void run() {$/;"	f	class:scollectd::impl	file:
scollectd	core/scollectd.cc	/^namespace scollectd {$/;"	n	file:
send_metric	core/scollectd.cc	/^    future<> send_metric(const type_instance_id & id,$/;"	f	class:scollectd::impl
send_metric	core/scollectd.cc	/^future<> send_metric(const type_instance_id & id,$/;"	f	namespace:scollectd
send_notification	core/scollectd.cc	/^    future<> send_notification(const type_instance_id & id,$/;"	f	class:scollectd::impl
send_notification	core/scollectd.cc	/^future<> send_notification(const type_instance_id & id,$/;"	f	namespace:scollectd
size	core/scollectd.cc	/^        size_t size() const {$/;"	f	struct:scollectd::impl::cpwriter
start	core/scollectd.cc	/^    void start(const sstring & host, const ipv4_addr & addr,$/;"	f	class:scollectd::impl
stop	core/scollectd.cc	/^    void stop() {$/;"	f	class:scollectd::impl
value_list_map	core/scollectd.cc	/^    typedef std::map<type_instance_id, shared_ptr<value_list> > value_list_map;$/;"	t	class:scollectd::impl	file:
value_list_pair	core/scollectd.cc	/^    typedef value_list_map::value_type value_list_pair;$/;"	t	class:scollectd::impl	file:
write	core/scollectd.cc	/^        cpwriter & write(_Iter s, _Iter e) {$/;"	f	struct:scollectd::impl::cpwriter
write	core/scollectd.cc	/^        cpwriter & write(const sstring & s) {$/;"	f	struct:scollectd::impl::cpwriter
write	core/scollectd.cc	/^        typename std::enable_if<std::is_integral<T>::value, cpwriter &>::type write($/;"	f	struct:scollectd::impl::cpwriter
ABSOLUTE	core/scollectd.hh	/^    ABSOLUTE, \/\/ unsigned int 64$/;"	m	class:scollectd::data_type
COUNTER	core/scollectd.hh	/^    COUNTER, \/\/ unsigned int 64$/;"	m	class:scollectd::data_type
DERIVE	core/scollectd.hh	/^    DERIVE, \/\/ signed int 64$/;"	m	class:scollectd::data_type
GAUGE	core/scollectd.hh	/^    GAUGE, \/\/ double$/;"	m	class:scollectd::data_type
SCOLLECTD_HH_	core/scollectd.hh	26;"	d
_id	core/scollectd.hh	/^    type_instance_id _id;$/;"	m	struct:scollectd::registration
_plugin	core/scollectd.hh	/^    plugin_id _plugin;$/;"	m	class:scollectd::type_instance_id
_plugin_instance	core/scollectd.hh	/^    plugin_instance_id _plugin_instance;$/;"	m	class:scollectd::type_instance_id
_t	core/scollectd.hh	/^    const stored_type _t;$/;"	m	class:scollectd::value
_type	core/scollectd.hh	/^    const data_type _type;$/;"	m	class:scollectd::value
_type	core/scollectd.hh	/^    type_id _type;$/;"	m	class:scollectd::type_instance_id
_type_instance	core/scollectd.hh	/^    scollectd::type_instance _type_instance;$/;"	m	class:scollectd::type_instance_id
_v	core/scollectd.hh	/^        const W & _v;$/;"	m	struct:scollectd::value::wrap
_values	core/scollectd.hh	/^    std::tuple < Args... > _values;$/;"	m	class:scollectd::values_impl
a	core/scollectd.hh	/^    values_impl(const values_impl<Args...>& a) = default;$/;"	m	class:scollectd::values_impl
a	core/scollectd.hh	/^    values_impl(values_impl<Args...>&& a) = default;$/;"	m	class:scollectd::values_impl
add_polled_metric	core/scollectd.hh	/^static type_instance_id add_polled_metric(const plugin_id & plugin,$/;"	f	namespace:scollectd
add_polled_metric	core/scollectd.hh	/^static type_instance_id add_polled_metric(const type_instance_id & id,$/;"	f	namespace:scollectd
bpack	core/scollectd.hh	/^    void bpack(_Iter s, _Iter e, uint64_t v) const {$/;"	f	class:scollectd::value
convert	core/scollectd.hh	/^    typename std::enable_if<std::is_floating_point<V>::value, uint64_t>::type convert($/;"	f	class:scollectd::value
convert	core/scollectd.hh	/^    typename std::enable_if<std::is_integral<V>::value, uint64_t>::type convert($/;"	f	class:scollectd::value
create_explicit_metric	core/scollectd.hh	/^static notify_function create_explicit_metric(const plugin_id & plugin,$/;"	f	namespace:scollectd
create_explicit_metric	core/scollectd.hh	/^static notify_function create_explicit_metric(const type_instance_id & id,$/;"	f	namespace:scollectd
data_type	core/scollectd.hh	/^enum class data_type : uint8_t {$/;"	c	namespace:scollectd
data_type_for	core/scollectd.hh	/^struct data_type_for<T,$/;"	s	namespace:scollectd
data_type_for	core/scollectd.hh	/^struct data_type_for<typed<T>> : public data_type_for<T> {$/;"	s	namespace:scollectd
do_unpack	core/scollectd.hh	/^    void do_unpack(const std::tuple<Args...>& t, const std::index_sequence<S...> &, _Op&& op) const {$/;"	f	class:scollectd::values_impl
empty	core/scollectd.hh	/^    bool empty() const {$/;"	f	class:scollectd::value_list
is_callable	core/scollectd.hh	/^struct is_callable<T,$/;"	s	namespace:scollectd
kj_create_explicit_metric	core/scollectd.hh	/^static notify_function kj_create_explicit_metric(const plugin_id & plugin,$/;"	f	namespace:scollectd
kj_create_explicit_metric	core/scollectd.hh	/^static notify_function kj_create_explicit_metric(const type_instance_id & id,$/;"	f	namespace:scollectd
kj_send_explicit_metric	core/scollectd.hh	/^static kj::Promise<void> kj_send_explicit_metric(const plugin_id & plugin,$/;"	f	namespace:scollectd
kj_send_explicit_metric	core/scollectd.hh	/^static kj::Promise<void> kj_send_explicit_metric(const type_instance_id & id,$/;"	f	namespace:scollectd
make_typed	core/scollectd.hh	/^static inline typed<T> make_typed(data_type type, T&& t) {$/;"	f	namespace:scollectd
notify_function	core/scollectd.hh	/^typedef std::function<void()> notify_function;$/;"	t	namespace:scollectd
num_values	core/scollectd.hh	/^    static const size_t num_values = sizeof...(Args);$/;"	m	class:scollectd::values_impl
operator ()	core/scollectd.hh	/^        const W & operator()() const {$/;"	f	struct:scollectd::value::wrap
operator ()	core/scollectd.hh	/^    uint64_t operator()() const {$/;"	f	class:scollectd::value
operator =	core/scollectd.hh	/^    registrations& operator=(const std::initializer_list<type_instance_id>& l) {$/;"	f	class:scollectd::registrations
operator =	core/scollectd.hh	/^    registrations& operator=(vector_type&& v) {$/;"	f	class:scollectd::registrations
operator data_type	core/scollectd.hh	/^    operator data_type() const {$/;"	f	class:scollectd::value
operator uint64_t	core/scollectd.hh	/^    operator uint64_t() const {$/;"	f	class:scollectd::value
plugin	core/scollectd.hh	/^    const plugin_id & plugin() const {$/;"	f	class:scollectd::type_instance_id
plugin_id	core/scollectd.hh	/^typedef sstring plugin_id;$/;"	t	namespace:scollectd
plugin_instance	core/scollectd.hh	/^    const plugin_instance_id & plugin_instance() const {$/;"	f	class:scollectd::type_instance_id
plugin_instance_id	core/scollectd.hh	/^typedef sstring plugin_instance_id;$/;"	t	namespace:scollectd
registration	core/scollectd.hh	/^    registration(const type_instance_id& id)$/;"	f	struct:scollectd::registration
registration	core/scollectd.hh	/^    registration(type_instance_id&& id)$/;"	f	struct:scollectd::registration
registration	core/scollectd.hh	/^struct registration {$/;"	s	namespace:scollectd
registrations	core/scollectd.hh	/^    registrations()$/;"	f	class:scollectd::registrations
registrations	core/scollectd.hh	/^    registrations(const std::initializer_list<type_instance_id>& l)$/;"	f	class:scollectd::registrations
registrations	core/scollectd.hh	/^    registrations(vector_type&& v) : vector_type(std::move(v))$/;"	f	class:scollectd::registrations
registrations	core/scollectd.hh	/^class registrations$/;"	c	namespace:scollectd
scollectd	core/scollectd.hh	/^namespace scollectd {$/;"	n
send_explicit_metric	core/scollectd.hh	/^static future<> send_explicit_metric(const plugin_id & plugin,$/;"	f	namespace:scollectd
send_explicit_metric	core/scollectd.hh	/^static future<> send_explicit_metric(const type_instance_id & id,$/;"	f	namespace:scollectd
stored_type	core/scollectd.hh	/^            value_type, wrap<value_type> >::type stored_type;$/;"	t	class:scollectd::value
type	core/scollectd.hh	/^    const type_id & type() const {$/;"	f	class:scollectd::type_instance_id
type	core/scollectd.hh	/^    data_type type() const {$/;"	f	class:scollectd::value
type	core/scollectd.hh	/^    data_type type;$/;"	m	struct:scollectd::typed
type_id	core/scollectd.hh	/^typedef sstring type_id;$/;"	t	namespace:scollectd
type_instance	core/scollectd.hh	/^    const scollectd::type_instance & type_instance() const {$/;"	f	class:scollectd::type_instance_id
type_instance	core/scollectd.hh	/^typedef sstring type_instance;$/;"	t	namespace:scollectd
type_instance_id	core/scollectd.hh	/^    type_instance_id(const plugin_id & p, const plugin_instance_id & pi,$/;"	f	class:scollectd::type_instance_id
type_instance_id	core/scollectd.hh	/^class type_instance_id {$/;"	c	namespace:scollectd
typed	core/scollectd.hh	/^    typed(data_type t, T && v)$/;"	f	struct:scollectd::typed
typed	core/scollectd.hh	/^struct typed {$/;"	s	namespace:scollectd
unpack	core/scollectd.hh	/^    void unpack(const std::tuple<Args...>& t, _Op&& op) const {$/;"	f	class:scollectd::values_impl
unregister	core/scollectd.hh	/^    void unregister() {$/;"	f	struct:scollectd::registration
value	core/scollectd.hh	/^    T value;$/;"	m	struct:scollectd::typed
value	core/scollectd.hh	/^    value(const typed<T> & args)$/;"	f	class:scollectd::value
value	core/scollectd.hh	/^    value(const value_type & t)$/;"	f	class:scollectd::value
value	core/scollectd.hh	/^    value(data_type type, const value_type & t)$/;"	f	class:scollectd::value
value	core/scollectd.hh	/^class value {$/;"	c	namespace:scollectd
value	core/scollectd.hh	/^class value<typed<T>> : public value<T> {$/;"	c	namespace:scollectd
value_list	core/scollectd.hh	/^class value_list {$/;"	c	namespace:scollectd
value_type	core/scollectd.hh	/^    typedef typename std::remove_reference<T>::type value_type;$/;"	t	class:scollectd::value
values_impl	core/scollectd.hh	/^    values_impl(Args&& ...args)$/;"	f	class:scollectd::values_impl
values_impl	core/scollectd.hh	/^class values_impl: public value_list {$/;"	c	namespace:scollectd
vector_type	core/scollectd.hh	/^    typedef std::vector<registration> vector_type;$/;"	t	class:scollectd::registrations
wrap	core/scollectd.hh	/^        wrap(const W & v)$/;"	f	struct:scollectd::value::wrap
wrap	core/scollectd.hh	/^    struct wrap {$/;"	s	class:scollectd::value
~registration	core/scollectd.hh	/^    ~registration() {$/;"	f	struct:scollectd::registration
~value_list	core/scollectd.hh	/^    virtual ~value_list() {}$/;"	f	class:scollectd::value_list
CORE_SCOLLECTD_API_HH_	core/scollectd_api.hh	6;"	d
_d	core/scollectd_api.hh	/^        double _d;$/;"	m	union:scollectd::collectd_value::__anon1
_i	core/scollectd_api.hh	/^        int64_t _i;$/;"	m	union:scollectd::collectd_value::__anon1
_type	core/scollectd_api.hh	/^    scollectd::data_type _type;$/;"	m	struct:scollectd::collectd_value
_ui	core/scollectd_api.hh	/^        uint64_t _ui;$/;"	m	union:scollectd::collectd_value::__anon1
c	core/scollectd_api.hh	/^    collectd_value& operator=(const collectd_value& c) = default;$/;"	m	struct:scollectd::collectd_value
collectd_value	core/scollectd_api.hh	/^    collectd_value()$/;"	f	struct:scollectd::collectd_value
collectd_value	core/scollectd_api.hh	/^    collectd_value(data_type t, uint64_t i)$/;"	f	struct:scollectd::collectd_value
collectd_value	core/scollectd_api.hh	/^struct collectd_value {$/;"	s	namespace:scollectd
operator +	core/scollectd_api.hh	/^    collectd_value operator+(const collectd_value& c) {$/;"	f	struct:scollectd::collectd_value
operator +=	core/scollectd_api.hh	/^    collectd_value& operator+=(const collectd_value& c) {$/;"	f	struct:scollectd::collectd_value
scollectd	core/scollectd_api.hh	/^namespace scollectd {$/;"	n
u	core/scollectd_api.hh	/^    } u;$/;"	m	struct:scollectd::collectd_value	typeref:union:scollectd::collectd_value::__anon1
CORE_SEMAPHORE_HH_	core/semaphore.hh	23;"	d
_count	core/semaphore.hh	/^    size_t _count;$/;"	m	class:semaphore
_wait_list	core/semaphore.hh	/^    circular_buffer<entry> _wait_list;$/;"	m	class:semaphore
broken	core/semaphore.hh	/^    void broken() { broken(broken_semaphore()); }$/;"	f	class:semaphore
broken	core/semaphore.hh	/^void semaphore::broken(const Exception& ex) {$/;"	f	class:semaphore
broken_semaphore	core/semaphore.hh	/^class broken_semaphore : public std::exception {$/;"	c
current	core/semaphore.hh	/^    size_t current() const { return _count; }$/;"	f	class:semaphore
entry	core/semaphore.hh	/^        entry(promise<>&& pr_, size_t nr_) : pr(std::move(pr_)), nr(nr_) {}$/;"	f	struct:semaphore::entry
entry	core/semaphore.hh	/^    struct entry {$/;"	s	class:semaphore
kj_wait	core/semaphore.hh	/^    kj::Promise<void> kj_wait(size_t nr = 1) {$/;"	f	class:semaphore
nr	core/semaphore.hh	/^        size_t nr;$/;"	m	struct:semaphore::entry
pr	core/semaphore.hh	/^        promise<> pr;$/;"	m	struct:semaphore::entry
semaphore	core/semaphore.hh	/^    semaphore(size_t count = 1) : _count(count) {}$/;"	f	class:semaphore
semaphore	core/semaphore.hh	/^class semaphore {$/;"	c
semaphore_timed_out	core/semaphore.hh	/^class semaphore_timed_out : public std::exception {$/;"	c
signal	core/semaphore.hh	/^    void signal(size_t nr = 1) {$/;"	f	class:semaphore
tr	core/semaphore.hh	/^        timer<> tr;$/;"	m	struct:semaphore::entry
try_wait	core/semaphore.hh	/^    bool try_wait(size_t nr = 1) {$/;"	f	class:semaphore
wait	core/semaphore.hh	/^    future<> wait(size_t nr = 1) {$/;"	f	class:semaphore
SHARED_PTR_HH_	core/shared_ptr.hh	23;"	d
_b	core/shared_ptr.hh	/^    mutable shared_ptr_count_base* _b = nullptr;$/;"	m	class:shared_ptr
_count	core/shared_ptr.hh	/^    shared_ptr_counter_type _count = 0;$/;"	m	class:enable_lw_shared_from_this
_count	core/shared_ptr.hh	/^    shared_ptr_counter_type _count = 0;$/;"	m	struct:shared_ptr_no_esft
_p	core/shared_ptr.hh	/^            , _p(x._p) {$/;"	f	class:shared_ptr
_p	core/shared_ptr.hh	/^    lw_shared_ptr(const lw_shared_ptr& x) noexcept : _p(x._p) {$/;"	f	class:lw_shared_ptr
_p	core/shared_ptr.hh	/^    lw_shared_ptr(lw_shared_ptr&& x) noexcept  : _p(x._p) {$/;"	f	class:lw_shared_ptr
_p	core/shared_ptr.hh	/^    lw_shared_ptr(shared_ptr_impl<T>* p) noexcept : _p(p) {$/;"	f	class:lw_shared_ptr
_p	core/shared_ptr.hh	/^    mutable T* _p = nullptr;$/;"	m	class:shared_ptr
_p	core/shared_ptr.hh	/^    mutable shared_ptr_impl<T>* _p = nullptr;$/;"	m	class:lw_shared_ptr
_p	core/shared_ptr.hh	/^    shared_ptr(shared_ptr_count_base* b, T* p) noexcept : _b(b), _p(p) {$/;"	f	class:shared_ptr
_value	core/shared_ptr.hh	/^    T _value;$/;"	m	struct:shared_ptr_no_esft
const_pointer_cast	core/shared_ptr.hh	/^const_pointer_cast(const shared_ptr<U>& p) {$/;"	f
count	core/shared_ptr.hh	/^    shared_ptr_counter_type count = 0;$/;"	m	struct:shared_ptr_count_base
data	core/shared_ptr.hh	/^    T data;$/;"	m	struct:shared_ptr_count_for
dynamic_pointer_cast	core/shared_ptr.hh	/^dynamic_pointer_cast(const shared_ptr<U>& p) {$/;"	f
enable_lw_shared_from_this	core/shared_ptr.hh	/^class enable_lw_shared_from_this {$/;"	c
enable_shared_from_this	core/shared_ptr.hh	/^class enable_shared_from_this : private shared_ptr_count_base {$/;"	c
hash	core/shared_ptr.hh	/^struct hash<::shared_ptr<T>> : private hash<T*> {$/;"	s	namespace:std
hash	core/shared_ptr.hh	/^struct hash<lw_shared_ptr<T>> : private hash<T*> {$/;"	s	namespace:std
lw_shared_ptr	core/shared_ptr.hh	/^    lw_shared_ptr(std::nullptr_t) noexcept : lw_shared_ptr() {}$/;"	f	class:lw_shared_ptr
lw_shared_ptr	core/shared_ptr.hh	/^class lw_shared_ptr {$/;"	c
make	core/shared_ptr.hh	/^    static shared_ptr<T> make(A&&... a) {$/;"	f	struct:shared_ptr_make_helper
make_lw_shared	core/shared_ptr.hh	/^lw_shared_ptr<T> make_lw_shared(A&&... a) {$/;"	f
make_lw_shared	core/shared_ptr.hh	/^lw_shared_ptr<T> make_lw_shared(T& a) {$/;"	f
make_lw_shared	core/shared_ptr.hh	/^lw_shared_ptr<T> make_lw_shared(T&& a) {$/;"	f
make_shared	core/shared_ptr.hh	/^make_shared(A&&... a) {$/;"	f
make_shared	core/shared_ptr.hh	/^make_shared(T&& a) {$/;"	f
noexcept	core/shared_ptr.hh	/^    lw_shared_ptr() noexcept = default;$/;"	m	class:lw_shared_ptr
noexcept	core/shared_ptr.hh	/^    shared_ptr() noexcept = default;$/;"	m	class:shared_ptr
operator !=	core/shared_ptr.hh	/^    bool operator!=(const lw_shared_ptr<const T>& x) const {$/;"	f	class:lw_shared_ptr
operator !=	core/shared_ptr.hh	/^    bool operator!=(const lw_shared_ptr<std::remove_const_t<T>>& x) const {$/;"	f	class:lw_shared_ptr
operator !=	core/shared_ptr.hh	/^operator!=(const shared_ptr<T>& x, const shared_ptr<U>& y) {$/;"	f
operator !=	core/shared_ptr.hh	/^operator!=(const shared_ptr<T>& x, std::nullptr_t) {$/;"	f
operator !=	core/shared_ptr.hh	/^operator!=(std::nullptr_t, const shared_ptr<T>& y) {$/;"	f
operator ()	core/shared_ptr.hh	/^    bool operator()(const shared_ptr<T>& i1, const shared_ptr<T>& i2) const {$/;"	f	struct:shared_ptr_equal_by_value
operator ()	core/shared_ptr.hh	/^    size_t operator()(const ::shared_ptr<T>& p) const {$/;"	f	struct:std::hash
operator ()	core/shared_ptr.hh	/^    size_t operator()(const lw_shared_ptr<T>& p) const {$/;"	f	struct:std::hash
operator ()	core/shared_ptr.hh	/^    size_t operator()(const shared_ptr<T>& p) const {$/;"	f	struct:shared_ptr_value_hash
operator <	core/shared_ptr.hh	/^operator<(const shared_ptr<T>& x, const shared_ptr<U>& y) {$/;"	f
operator <	core/shared_ptr.hh	/^operator<(const shared_ptr<T>& x, std::nullptr_t) {$/;"	f
operator <	core/shared_ptr.hh	/^operator<(std::nullptr_t, const shared_ptr<T>& y) {$/;"	f
operator <<	core/shared_ptr.hh	/^std::ostream& operator<<(std::ostream& out, const lw_shared_ptr<T>& p) {$/;"	f
operator <<	core/shared_ptr.hh	/^std::ostream& operator<<(std::ostream& out, const shared_ptr<T>& p) {$/;"	f
operator <=	core/shared_ptr.hh	/^operator<=(const shared_ptr<T>& x, const shared_ptr<U>& y) {$/;"	f
operator <=	core/shared_ptr.hh	/^operator<=(const shared_ptr<T>& x, std::nullptr_t) {$/;"	f
operator <=	core/shared_ptr.hh	/^operator<=(std::nullptr_t, const shared_ptr<T>& y) {$/;"	f
operator ==	core/shared_ptr.hh	/^    bool operator==(const lw_shared_ptr<const T>& x) const {$/;"	f	class:lw_shared_ptr
operator ==	core/shared_ptr.hh	/^    bool operator==(const lw_shared_ptr<std::remove_const_t<T>>& x) const {$/;"	f	class:lw_shared_ptr
operator ==	core/shared_ptr.hh	/^operator==(const shared_ptr<T>& x, const shared_ptr<U>& y) {$/;"	f
operator ==	core/shared_ptr.hh	/^operator==(const shared_ptr<T>& x, std::nullptr_t) {$/;"	f
operator ==	core/shared_ptr.hh	/^operator==(std::nullptr_t, const shared_ptr<T>& y) {$/;"	f
operator >	core/shared_ptr.hh	/^operator>(const shared_ptr<T>& x, const shared_ptr<U>& y) {$/;"	f
operator >	core/shared_ptr.hh	/^operator>(const shared_ptr<T>& x, std::nullptr_t) {$/;"	f
operator >	core/shared_ptr.hh	/^operator>(std::nullptr_t, const shared_ptr<T>& y) {$/;"	f
operator >=	core/shared_ptr.hh	/^operator>=(const shared_ptr<T>& x, const shared_ptr<U>& y) {$/;"	f
operator >=	core/shared_ptr.hh	/^operator>=(const shared_ptr<T>& x, std::nullptr_t) {$/;"	f
operator >=	core/shared_ptr.hh	/^operator>=(std::nullptr_t, const shared_ptr<T>& y) {$/;"	f
shared_from_this	core/shared_ptr.hh	/^enable_lw_shared_from_this<T>::shared_from_this() const {$/;"	f	class:enable_lw_shared_from_this
shared_from_this	core/shared_ptr.hh	/^enable_lw_shared_from_this<T>::shared_from_this() {$/;"	f	class:enable_lw_shared_from_this
shared_from_this	core/shared_ptr.hh	/^enable_shared_from_this<T>::shared_from_this() const {$/;"	f	class:enable_shared_from_this
shared_from_this	core/shared_ptr.hh	/^enable_shared_from_this<T>::shared_from_this() {$/;"	f	class:enable_shared_from_this
shared_ptr	core/shared_ptr.hh	/^    shared_ptr(std::nullptr_t) noexcept : shared_ptr() {}$/;"	f	class:shared_ptr
shared_ptr	core/shared_ptr.hh	/^class shared_ptr {$/;"	c
shared_ptr_count_base	core/shared_ptr.hh	/^struct shared_ptr_count_base {$/;"	s
shared_ptr_count_for	core/shared_ptr.hh	/^    shared_ptr_count_for(A&&... a) : data(std::forward<A>(a)...) {}$/;"	f	struct:shared_ptr_count_for
shared_ptr_count_for	core/shared_ptr.hh	/^struct shared_ptr_count_for : shared_ptr_count_base {$/;"	s
shared_ptr_equal_by_value	core/shared_ptr.hh	/^struct shared_ptr_equal_by_value {$/;"	s
shared_ptr_make_helper	core/shared_ptr.hh	/^struct shared_ptr_make_helper<T, false> {$/;"	s
shared_ptr_make_helper	core/shared_ptr.hh	/^struct shared_ptr_make_helper<T, true> {$/;"	s
shared_ptr_no_esft	core/shared_ptr.hh	/^    shared_ptr_no_esft(A&&... a) : _value(std::forward<A>(a)...) {}$/;"	f	struct:shared_ptr_no_esft
shared_ptr_no_esft	core/shared_ptr.hh	/^    shared_ptr_no_esft(T&& x) : _value(std::move(x)) {}$/;"	f	struct:shared_ptr_no_esft
shared_ptr_no_esft	core/shared_ptr.hh	/^    shared_ptr_no_esft(const T& x) : _value(x) {}$/;"	f	struct:shared_ptr_no_esft
shared_ptr_no_esft	core/shared_ptr.hh	/^struct shared_ptr_no_esft {$/;"	s
shared_ptr_value_hash	core/shared_ptr.hh	/^struct shared_ptr_value_hash {$/;"	s
static_cast	core/shared_ptr.hh	/^    explicit shared_ptr(enable_shared_from_this<std::remove_const_t<T>>* p) noexcept : _b(p), _p(static_cast<T*>(p)) {$/;"	f	class:shared_ptr
static_pointer_cast	core/shared_ptr.hh	/^static_pointer_cast(const shared_ptr<U>& p) {$/;"	f
std	core/shared_ptr.hh	/^namespace std {$/;"	n
to_internal_object	core/shared_ptr.hh	/^    T* to_internal_object() { return static_cast<T*>(this); }$/;"	f	class:enable_lw_shared_from_this
to_internal_object	core/shared_ptr.hh	/^    shared_ptr_no_esft* to_internal_object() { return this; }$/;"	f	struct:shared_ptr_no_esft
to_value	core/shared_ptr.hh	/^    T* to_value() { return &_value; }$/;"	f	struct:shared_ptr_no_esft
to_value	core/shared_ptr.hh	/^    T* to_value() { return static_cast<T*>(this); }$/;"	f	class:enable_lw_shared_from_this
~lw_shared_ptr	core/shared_ptr.hh	/^    ~lw_shared_ptr() {$/;"	f	class:lw_shared_ptr
~shared_ptr	core/shared_ptr.hh	/^    ~shared_ptr() {$/;"	f	class:shared_ptr
~shared_ptr_count_base	core/shared_ptr.hh	/^    virtual ~shared_ptr_count_base() {}$/;"	f	struct:shared_ptr_count_base
_counter	core/shared_ptr_debug_helper.hh	/^    long _counter = 0;$/;"	m	class:debug_shared_ptr_counter_type
_cpu	core/shared_ptr_debug_helper.hh	/^    std::thread::id _cpu = std::this_thread::get_id();$/;"	m	class:debug_shared_ptr_counter_type
check	core/shared_ptr_debug_helper.hh	/^    void check() const {$/;"	f	class:debug_shared_ptr_counter_type
debug_shared_ptr_counter_type	core/shared_ptr_debug_helper.hh	/^    debug_shared_ptr_counter_type(long x) : _counter(x) {}$/;"	f	class:debug_shared_ptr_counter_type
debug_shared_ptr_counter_type	core/shared_ptr_debug_helper.hh	/^class debug_shared_ptr_counter_type {$/;"	c
operator ++	core/shared_ptr_debug_helper.hh	/^    debug_shared_ptr_counter_type& operator++() {$/;"	f	class:debug_shared_ptr_counter_type
operator ++	core/shared_ptr_debug_helper.hh	/^    long operator++(int) {$/;"	f	class:debug_shared_ptr_counter_type
operator --	core/shared_ptr_debug_helper.hh	/^    debug_shared_ptr_counter_type& operator--() {$/;"	f	class:debug_shared_ptr_counter_type
operator --	core/shared_ptr_debug_helper.hh	/^    long operator--(int) {$/;"	f	class:debug_shared_ptr_counter_type
operator long	core/shared_ptr_debug_helper.hh	/^    operator long() const {$/;"	f	class:debug_shared_ptr_counter_type
SLAB_MAGIC_NUMBER	core/slab.hh	/^static constexpr uint16_t SLAB_MAGIC_NUMBER = 0x51AB; \/\/ meant to be 'SLAB' :-)$/;"	v
__SLAB_ALLOCATOR__	core/slab.hh	22;"	d
_available_slab_pages	core/slab.hh	/^    uint64_t _available_slab_pages;$/;"	m	class:slab_allocator
_erase_func	core/slab.hh	/^    std::function<void (Item& item_ref)> _erase_func;$/;"	m	class:slab_allocator
_free_objects	core/slab.hh	/^    std::vector<uintptr_t> _free_objects;$/;"	m	struct:slab_page_desc
_free_pages_link	core/slab.hh	/^    bi::list_member_hook<> _free_pages_link;$/;"	m	struct:slab_page_desc
_free_slab_pages	core/slab.hh	/^        &slab_page_desc::_free_pages_link>> _free_slab_pages;$/;"	m	class:slab_class
_index	core/slab.hh	/^    uint32_t _index; \/\/ index into slab page vector$/;"	m	struct:slab_page_desc
_lru	core/slab.hh	/^        &slab_item_base::_lru_link>> _lru;$/;"	m	class:slab_class
_lru_link	core/slab.hh	/^    bi::list_member_hook<> _lru_link;$/;"	m	class:slab_item_base
_lru_link	core/slab.hh	/^    bi::list_member_hook<> _lru_link;$/;"	m	struct:slab_page_desc
_magic	core/slab.hh	/^    uint16_t _magic;$/;"	m	struct:slab_page_desc
_max_object_size	core/slab.hh	/^    uint64_t _max_object_size;$/;"	m	class:slab_allocator
_reclaimed	core/slab.hh	/^    bool _reclaimed = false;$/;"	m	class:slab_allocator
_reclaimer	core/slab.hh	/^    memory::reclaimer *_reclaimer = nullptr;$/;"	m	class:slab_allocator
_refcnt	core/slab.hh	/^    uint32_t _refcnt;$/;"	m	struct:slab_page_desc
_registrations	core/slab.hh	/^    std::vector<scollectd::registration> _registrations;$/;"	m	class:slab_allocator
_size	core/slab.hh	/^    size_t _size; \/\/ size of objects$/;"	m	class:slab_class
_slab_class_id	core/slab.hh	/^    uint8_t _slab_class_id;$/;"	m	class:slab_class
_slab_class_id	core/slab.hh	/^    uint8_t _slab_class_id;$/;"	m	struct:slab_page_desc
_slab_class_sizes	core/slab.hh	/^    std::vector<size_t> _slab_class_sizes;$/;"	m	class:slab_allocator
_slab_classes	core/slab.hh	/^    std::vector<slab_class<Item>> _slab_classes;$/;"	m	class:slab_allocator
_slab_page	core/slab.hh	/^    void *_slab_page;$/;"	m	struct:slab_page_desc
_slab_page_desc_lru	core/slab.hh	/^        &slab_page_desc::_lru_link>> _slab_page_desc_lru;$/;"	m	class:slab_allocator
_slab_pages_vector	core/slab.hh	/^    std::vector<slab_page_desc*> _slab_pages_vector;$/;"	m	class:slab_allocator
_stats	core/slab.hh	/^    } _stats;$/;"	m	class:slab_allocator	typeref:struct:slab_allocator::collectd_stats
allocate_object	core/slab.hh	/^    void* allocate_object() {$/;"	f	struct:slab_page_desc
allocs	core/slab.hh	/^        uint64_t allocs;$/;"	m	struct:slab_allocator::collectd_stats
can_allocate_page	core/slab.hh	/^    inline bool can_allocate_page(slab_class<Item>& sc) {$/;"	f	class:slab_allocator
class_size	core/slab.hh	/^    size_t class_size(const size_t size) {$/;"	f	class:slab_allocator
collectd_stats	core/slab.hh	/^    struct collectd_stats {$/;"	s	class:slab_allocator
create	core/slab.hh	/^    Item *create(Args&&... args) {$/;"	f	class:slab_class
create	core/slab.hh	/^    Item* create(const size_t size, Args&&... args) {$/;"	f	class:slab_allocator
create_from_lru	core/slab.hh	/^    Item *create_from_lru(std::function<void (Item& item_ref)>& erase_func, Args&&... args) {$/;"	f	class:slab_class
create_from_new_page	core/slab.hh	/^    Item *create_from_new_page(uint64_t max_object_size, uint32_t slab_page_index,$/;"	f	class:slab_class
create_item	core/slab.hh	/^    Item* create_item(void *object, uint32_t slab_page_index, Args&&... args) {$/;"	f	class:slab_class
empty	core/slab.hh	/^    bool empty() const {$/;"	f	class:slab_class
empty	core/slab.hh	/^    bool empty() const {$/;"	f	struct:slab_page_desc
evict_lru_item	core/slab.hh	/^    std::pair<void *, uint32_t> evict_lru_item(std::function<void (Item& item_ref)>& erase_func) {$/;"	f	class:slab_class
evict_lru_slab_page	core/slab.hh	/^    void evict_lru_slab_page() {$/;"	f	class:slab_allocator
free	core/slab.hh	/^    void free(Item *item) {$/;"	f	class:slab_allocator
free_item	core/slab.hh	/^    void free_item(Item *item, slab_page_desc& desc) {$/;"	f	class:slab_class
free_object	core/slab.hh	/^    void free_object(void *object) {$/;"	f	struct:slab_page_desc
free_objects	core/slab.hh	/^    std::vector<uintptr_t>& free_objects() {$/;"	f	struct:slab_page_desc
frees	core/slab.hh	/^        uint64_t frees;$/;"	m	struct:slab_allocator::collectd_stats
get_slab_class	core/slab.hh	/^    slab_class<Item>* get_slab_class(const size_t size) {$/;"	f	class:slab_allocator
get_slab_class	core/slab.hh	/^    slab_class<Item>* get_slab_class(const uint8_t slab_class_id) {$/;"	f	class:slab_allocator
get_slab_page_desc	core/slab.hh	/^    inline slab_page_desc& get_slab_page_desc(Item *item)$/;"	f	class:slab_allocator
has_no_slab_pages	core/slab.hh	/^    bool has_no_slab_pages() const {$/;"	f	class:slab_class
index	core/slab.hh	/^    uint32_t index() const {$/;"	f	struct:slab_page_desc
initialize_slab_allocator	core/slab.hh	/^    void initialize_slab_allocator(double growth_factor, uint64_t limit) {$/;"	f	class:slab_allocator
insert_item_into_lru	core/slab.hh	/^    void insert_item_into_lru(Item *item) {$/;"	f	class:slab_class
lock_item	core/slab.hh	/^    void lock_item(Item *item) {$/;"	f	class:slab_allocator
magic	core/slab.hh	/^    uint16_t magic() const {$/;"	f	struct:slab_page_desc
print_slab_classes	core/slab.hh	/^    void print_slab_classes() {$/;"	f	class:slab_allocator
reclaim	core/slab.hh	/^    void reclaim() {$/;"	f	class:slab_allocator
refcnt	core/slab.hh	/^    uint32_t& refcnt() {$/;"	f	struct:slab_page_desc
register_collectd_metrics	core/slab.hh	/^    void register_collectd_metrics() {$/;"	f	class:slab_allocator
remove_desc_from_free_list	core/slab.hh	/^    void remove_desc_from_free_list(slab_page_desc& desc) {$/;"	f	class:slab_class
remove_item_from_lru	core/slab.hh	/^    void remove_item_from_lru(Item *item) {$/;"	f	class:slab_class
size	core/slab.hh	/^    size_t size() const {$/;"	f	class:slab_class
size	core/slab.hh	/^    size_t size() const {$/;"	f	struct:slab_page_desc
slab_allocator	core/slab.hh	/^    slab_allocator(double growth_factor, uint64_t limit, uint64_t max_object_size)$/;"	f	class:slab_allocator
slab_allocator	core/slab.hh	/^    slab_allocator(double growth_factor, uint64_t limit, uint64_t max_object_size,$/;"	f	class:slab_allocator
slab_allocator	core/slab.hh	/^class slab_allocator {$/;"	c
slab_class	core/slab.hh	/^    slab_class(size_t size, uint8_t slab_class_id)$/;"	f	class:slab_class
slab_class	core/slab.hh	/^class slab_class {$/;"	c
slab_class_id	core/slab.hh	/^    uint8_t slab_class_id() const {$/;"	f	struct:slab_page_desc
slab_item_base	core/slab.hh	/^class slab_item_base {$/;"	c
slab_page	core/slab.hh	/^    void* slab_page() const {$/;"	f	struct:slab_page_desc
slab_page_desc	core/slab.hh	/^    slab_page_desc(void *slab_page, size_t objects, size_t object_size, uint8_t slab_class_id, uint32_t index)$/;"	f	struct:slab_page_desc
slab_page_desc	core/slab.hh	/^struct slab_page_desc {$/;"	s
touch	core/slab.hh	/^    void touch(Item *item) {$/;"	f	class:slab_allocator
touch_item	core/slab.hh	/^    void touch_item(Item *item) {$/;"	f	class:slab_class
uintptr_t	core/slab.hh	/^typedef uint64_t uintptr_t;$/;"	t
unlock_item	core/slab.hh	/^    void unlock_item(Item *item) {$/;"	f	class:slab_allocator
~slab_allocator	core/slab.hh	/^    ~slab_allocator()$/;"	f	class:slab_allocator
~slab_class	core/slab.hh	/^    ~slab_class() {$/;"	f	class:slab_class
sleep	core/sleep.hh	/^future<> sleep(std::chrono::duration<Rep, Period> dur) {$/;"	f
SSTRING_HH_	core/sstring.hh	23;"	d
append	core/sstring.hh	/^    basic_sstring& append (const char_type* s, size_t n) {$/;"	f	class:basic_sstring
at	core/sstring.hh	/^    char_type& at(size_t pos) {$/;"	f	class:basic_sstring
at	core/sstring.hh	/^    const char_type& at(size_t pos) const {$/;"	f	class:basic_sstring
basic_sstring	core/sstring.hh	/^    basic_sstring(InputIterator first, InputIterator last)$/;"	f	class:basic_sstring
basic_sstring	core/sstring.hh	/^    basic_sstring(const basic_sstring& x) {$/;"	f	class:basic_sstring
basic_sstring	core/sstring.hh	/^    basic_sstring(const char* x) : basic_sstring(reinterpret_cast<const char_type*>(x), std::strlen(x)) {}$/;"	f	class:basic_sstring
basic_sstring	core/sstring.hh	/^    basic_sstring(const char_type* b, const char_type* e) : basic_sstring(b, e - b) {}$/;"	f	class:basic_sstring
basic_sstring	core/sstring.hh	/^    basic_sstring(const char_type* x, size_t size) {$/;"	f	class:basic_sstring
basic_sstring	core/sstring.hh	/^    basic_sstring(const std::basic_string<char_type>& s)$/;"	f	class:basic_sstring
basic_sstring	core/sstring.hh	/^    basic_sstring(initialized_later, size_t size) {$/;"	f	class:basic_sstring
basic_sstring	core/sstring.hh	/^    basic_sstring(size_t size, char_type x) : basic_sstring(initialized_later(), size) {$/;"	f	class:basic_sstring
basic_sstring	core/sstring.hh	/^    basic_sstring(std::basic_string<char_type>& x) : basic_sstring(x.c_str(), x.size()) {}$/;"	f	class:basic_sstring
basic_sstring	core/sstring.hh	/^    basic_sstring(std::initializer_list<char_type> x) : basic_sstring(x.begin(), x.end() - x.begin()) {}$/;"	f	class:basic_sstring
basic_sstring	core/sstring.hh	/^class basic_sstring {$/;"	c
begin	core/sstring.hh	/^    char_type* begin() { return str(); }$/;"	f	class:basic_sstring
begin	core/sstring.hh	/^    const char_type* begin() const { return str(); }$/;"	f	class:basic_sstring
c_str	core/sstring.hh	/^    const char_type* c_str() const {$/;"	f	class:basic_sstring
cbegin	core/sstring.hh	/^    const char_type* cbegin() const { return str(); }$/;"	f	class:basic_sstring
cend	core/sstring.hh	/^    const char_type* cend() const { return str() + size(); }$/;"	f	class:basic_sstring
contents	core/sstring.hh	/^    union contents {$/;"	u	class:basic_sstring
copy_str_to	core/sstring.hh	/^char* copy_str_to(char* dst) {$/;"	f
copy_str_to	core/sstring.hh	/^char* copy_str_to(char* dst, const Head& head, const Tail&... tail) {$/;"	f
end	core/sstring.hh	/^    char_type* end() { return str() + size(); }$/;"	f	class:basic_sstring
end	core/sstring.hh	/^    const char_type* end() const { return str() + size(); }$/;"	f	class:basic_sstring
erase	core/sstring.hh	/^    iterator erase(iterator first, iterator last) {$/;"	f	class:basic_sstring
external	core/sstring.hh	/^        } external;$/;"	m	union:basic_sstring::contents	typeref:struct:basic_sstring::contents::external_type
external_type	core/sstring.hh	/^        struct external_type {$/;"	s	union:basic_sstring::contents
hash	core/sstring.hh	/^struct hash<basic_sstring<char_type, size_type, max_size>> {$/;"	s	namespace:std
initialized_later	core/sstring.hh	/^    struct initialized_later {};$/;"	s	class:basic_sstring
insert	core/sstring.hh	/^    void insert(const_iterator p, InputIterator beg, InputIterator end) {$/;"	f	class:basic_sstring
internal	core/sstring.hh	/^        } internal;$/;"	m	union:basic_sstring::contents	typeref:struct:basic_sstring::contents::internal_type
internal_type	core/sstring.hh	/^        struct internal_type {$/;"	s	union:basic_sstring::contents
make_sstring	core/sstring.hh	/^static String make_sstring(Args&&... args)$/;"	f
npos	core/sstring.hh	/^    static constexpr size_type  npos = static_cast<size_type>(-1);$/;"	m	class:basic_sstring
npos	core/sstring.hh	/^constexpr Size basic_sstring<char_type, Size, max_size>::npos;$/;"	m	class:basic_sstring
operator !=	core/sstring.hh	/^    bool operator!=(const basic_sstring& x) const {$/;"	f	class:basic_sstring
operator ()	core/sstring.hh	/^    size_t operator()(const basic_sstring<char_type, size_type, max_size>& s) const {$/;"	f	struct:std::hash
operator +	core/sstring.hh	/^    basic_sstring operator+(const basic_sstring& x) const {$/;"	f	class:basic_sstring
operator +	core/sstring.hh	/^operator+(const char(&s)[N], const basic_sstring<char_type, size_type, Max>& t) {$/;"	f
operator +=	core/sstring.hh	/^    basic_sstring& operator+=(const basic_sstring& x) {$/;"	f	class:basic_sstring
operator <	core/sstring.hh	/^    bool operator<(const basic_sstring& x) const {$/;"	f	class:basic_sstring
operator <<	core/sstring.hh	/^operator<<(std::basic_ostream<char_type, char_traits>& os,$/;"	f
operator <<	core/sstring.hh	/^std::ostream& operator<<(std::ostream& os, const std::vector<T>& v) {$/;"	f
operator =	core/sstring.hh	/^    basic_sstring& operator=(const basic_sstring& x) {$/;"	f	class:basic_sstring
operator ==	core/sstring.hh	/^    bool operator==(const basic_sstring& x) const {$/;"	f	class:basic_sstring
operator >>	core/sstring.hh	/^operator>>(std::basic_istream<char_type, char_traits>& is,$/;"	f
operator []	core/sstring.hh	/^    char_type& operator[](size_type pos) {$/;"	f	class:basic_sstring
operator []	core/sstring.hh	/^    const char_type& operator[](size_type pos) const {$/;"	f	class:basic_sstring
operator std::basic_string<char_type>	core/sstring.hh	/^    operator std::basic_string<char_type>() const {$/;"	f	class:basic_sstring
operator std::experimental::basic_string_view<char_type>	core/sstring.hh	/^    operator std::experimental::basic_string_view<char_type>() const {$/;"	f	class:basic_sstring
pad	core/sstring.hh	/^            int8_t pad;$/;"	m	struct:basic_sstring::contents::external_type
release	core/sstring.hh	/^    temporary_buffer<char_type> release() && {$/;"	f	class:basic_sstring
replace	core/sstring.hh	/^    basic_sstring& replace (const_iterator i1, const_iterator i2,$/;"	f	class:basic_sstring
replace	core/sstring.hh	/^    basic_sstring& replace(size_type pos, size_type n1, const char_type* s,$/;"	f	class:basic_sstring
size	core/sstring.hh	/^            Size size;$/;"	m	struct:basic_sstring::contents::external_type
size	core/sstring.hh	/^            int8_t size;$/;"	m	struct:basic_sstring::contents::internal_type
std	core/sstring.hh	/^namespace std {$/;"	n
str	core/sstring.hh	/^            char_type str[max_size];$/;"	m	struct:basic_sstring::contents::internal_type
str	core/sstring.hh	/^            char_type* str;$/;"	m	struct:basic_sstring::contents::external_type
str	core/sstring.hh	/^    char_type* str() {$/;"	f	class:basic_sstring
str	core/sstring.hh	/^    const char_type* str() const {$/;"	f	class:basic_sstring
str_begin	core/sstring.hh	/^const char* str_begin(const char(&s)[N]) { return s; }$/;"	f
str_begin	core/sstring.hh	/^const char_type* str_begin(const basic_sstring<char_type, size_type, max_size>& s) { return s.begin(); }$/;"	f
str_end	core/sstring.hh	/^const char* str_end(const char(&s)[N]) { return str_begin(s) + str_len(s); }$/;"	f
str_end	core/sstring.hh	/^const char_type* str_end(const basic_sstring<char_type, size_type, max_size>& s) { return s.end(); }$/;"	f
str_len	core/sstring.hh	/^const size_t str_len(const First& first, const Second& second, const Tail&... tail) {$/;"	f
str_len	core/sstring.hh	/^size_t str_len(const char(&s)[N]) { return N - 1; }$/;"	f
str_len	core/sstring.hh	/^size_type str_len(const basic_sstring<char_type, size_type, max_size>& s) { return s.size(); }$/;"	f
substr	core/sstring.hh	/^    basic_sstring substr(size_t from, size_t len = npos)  const {$/;"	f	class:basic_sstring
to_sstring	core/sstring.hh	/^static string_type to_sstring(const temporary_buffer<char>& buf) {$/;"	f
to_sstring	core/sstring.hh	/^string_type to_sstring(const char* value, void* = nullptr) {$/;"	f
to_sstring	core/sstring.hh	/^string_type to_sstring(double value, void* = nullptr) {$/;"	f
to_sstring	core/sstring.hh	/^string_type to_sstring(float value, void* = nullptr) {$/;"	f
to_sstring	core/sstring.hh	/^string_type to_sstring(int value, void* = nullptr) {$/;"	f
to_sstring	core/sstring.hh	/^string_type to_sstring(long double value, void* = nullptr) {$/;"	f
to_sstring	core/sstring.hh	/^string_type to_sstring(long long value, void* = nullptr) {$/;"	f
to_sstring	core/sstring.hh	/^string_type to_sstring(long value, void* = nullptr) {$/;"	f
to_sstring	core/sstring.hh	/^string_type to_sstring(sstring value, void* = nullptr) {$/;"	f
to_sstring	core/sstring.hh	/^string_type to_sstring(unsigned long long value, void* = nullptr) {$/;"	f
to_sstring	core/sstring.hh	/^string_type to_sstring(unsigned long value, void* = nullptr) {$/;"	f
to_sstring	core/sstring.hh	/^string_type to_sstring(unsigned value, void* = nullptr) {$/;"	f
to_sstring_sprintf	core/sstring.hh	/^string_type to_sstring_sprintf(T value, const char* fmt) {$/;"	f
to_sstring_sprintf	core/sstring.hh	/^to_sstring_sprintf(T value, const char* fmt) {$/;"	f
u	core/sstring.hh	/^    } u;$/;"	m	class:basic_sstring	typeref:union:basic_sstring::contents
STREAM_HH_	core/stream.hh	23;"	d
_done	core/stream.hh	/^    promise<> _done;$/;"	m	class:stream
_next	core/stream.hh	/^    next_fn _next;$/;"	m	class:subscription
_ready	core/stream.hh	/^    promise<> _ready;$/;"	m	class:stream
_stream	core/stream.hh	/^    stream<T...>* _stream;$/;"	m	class:subscription
_sub	core/stream.hh	/^    subscription<T...>* _sub = nullptr;$/;"	m	class:stream
close	core/stream.hh	/^stream<T...>::close() {$/;"	f	class:stream
done	core/stream.hh	/^subscription<T...>::done() {$/;"	f	class:subscription
listen	core/stream.hh	/^stream<T...>::listen() {$/;"	f	class:stream
listen	core/stream.hh	/^stream<T...>::listen(next_fn next) {$/;"	f	class:stream
produce	core/stream.hh	/^stream<T...>::produce(T... data) {$/;"	f	class:stream
set_exception	core/stream.hh	/^stream<T...>::set_exception(E ex) {$/;"	f	class:stream
start	core/stream.hh	/^subscription<T...>::start(std::function<future<> (T...)> next) {$/;"	f	class:subscription
started	core/stream.hh	/^stream<T...>::started() {$/;"	f	class:stream
stream	core/stream.hh	/^class stream {$/;"	c
subscription	core/stream.hh	/^class subscription {$/;"	c
subscription	core/stream.hh	/^subscription<T...>::subscription(stream<T...>* s)$/;"	f	class:subscription
subscription	core/stream.hh	/^subscription<T...>::subscription(subscription&& x)$/;"	f	class:subscription
~stream	core/stream.hh	/^stream<T...>::~stream() {$/;"	f	class:stream
~subscription	core/stream.hh	/^subscription<T...>::~subscription() {$/;"	f	class:subscription
_func	core/task.hh	/^    Func _func;$/;"	m	class:final
final	core/task.hh	/^class lambda_task final : public task {$/;"	c
lambda_task	core/task.hh	/^    lambda_task(Func&& func) : _func(std::move(func)) {}$/;"	f	class:final
lambda_task	core/task.hh	/^    lambda_task(const Func& func) : _func(func) {}$/;"	f	class:final
make_task	core/task.hh	/^make_task(Func&& func) {$/;"	f
noexcept	core/task.hh	/^    virtual void run() noexcept = 0;$/;"	m	class:task
task	core/task.hh	/^class task {$/;"	c
TEMPORARY_BUFFER_HH_	core/temporary_buffer.hh	23;"	d
_buffer	core/temporary_buffer.hh	/^    CharType* _buffer;$/;"	m	class:temporary_buffer
_deleter	core/temporary_buffer.hh	/^    deleter _deleter;$/;"	m	class:temporary_buffer
_size	core/temporary_buffer.hh	/^    size_t _size;$/;"	m	class:temporary_buffer
aligned	core/temporary_buffer.hh	/^    static temporary_buffer aligned(size_t alignment, size_t size) {$/;"	f	class:temporary_buffer
begin	core/temporary_buffer.hh	/^    const CharType* begin() { return _buffer; }$/;"	f	class:temporary_buffer
empty	core/temporary_buffer.hh	/^    bool empty() const { return !size(); }$/;"	f	class:temporary_buffer
end	core/temporary_buffer.hh	/^    const CharType* end() { return _buffer + _size; }$/;"	f	class:temporary_buffer
get	core/temporary_buffer.hh	/^    const CharType* get() const { return _buffer; }$/;"	f	class:temporary_buffer
get_write	core/temporary_buffer.hh	/^    CharType* get_write() { return _buffer; }$/;"	f	class:temporary_buffer
operator =	core/temporary_buffer.hh	/^    temporary_buffer& operator=(temporary_buffer&& x) {$/;"	f	class:temporary_buffer
operator []	core/temporary_buffer.hh	/^    CharType operator[](size_t pos) const {$/;"	f	class:temporary_buffer
operator bool	core/temporary_buffer.hh	/^    operator bool() { return size(); }$/;"	f	class:temporary_buffer
prefix	core/temporary_buffer.hh	/^    temporary_buffer prefix(size_t size) && {$/;"	f	class:temporary_buffer
release	core/temporary_buffer.hh	/^    deleter release() {$/;"	f	class:temporary_buffer
share	core/temporary_buffer.hh	/^    temporary_buffer share() {$/;"	f	class:temporary_buffer
share	core/temporary_buffer.hh	/^    temporary_buffer share(size_t pos, size_t len) {$/;"	f	class:temporary_buffer
size	core/temporary_buffer.hh	/^    size_t size() const { return _size; }$/;"	f	class:temporary_buffer
temporary_buffer	core/temporary_buffer.hh	/^    explicit temporary_buffer(size_t size)$/;"	f	class:temporary_buffer
temporary_buffer	core/temporary_buffer.hh	/^    temporary_buffer()$/;"	f	class:temporary_buffer
temporary_buffer	core/temporary_buffer.hh	/^    temporary_buffer(CharType* buf, size_t size, deleter d)$/;"	f	class:temporary_buffer
temporary_buffer	core/temporary_buffer.hh	/^    temporary_buffer(temporary_buffer&& x) : _buffer(x._buffer), _size(x._size), _deleter(std::move(x._deleter)) {$/;"	f	class:temporary_buffer
temporary_buffer	core/temporary_buffer.hh	/^class temporary_buffer {$/;"	c
trim	core/temporary_buffer.hh	/^    void trim(size_t pos) {$/;"	f	class:temporary_buffer
trim_front	core/temporary_buffer.hh	/^    void trim_front(size_t pos) {        $/;"	f	class:temporary_buffer
g_current_context	core/thread.cc	/^thread_local jmp_buf_link* g_current_context;$/;"	m	namespace:seastar	file:
g_unthreaded_context	core/thread.cc	/^thread_local jmp_buf_link g_unthreaded_context;$/;"	m	namespace:seastar	file:
get	core/thread.cc	/^thread_context* get() {$/;"	f	namespace:seastar::thread_impl
init	core/thread.cc	/^void init() {$/;"	f	namespace:seastar::thread_impl
main	core/thread.cc	/^thread_context::main() {$/;"	f	class:seastar::thread_context
s_main	core/thread.cc	/^thread_context::s_main(unsigned int lo, unsigned int hi) {$/;"	f	class:seastar::thread_context
seastar	core/thread.cc	/^namespace seastar {$/;"	n	file:
setup	core/thread.cc	/^thread_context::setup() {$/;"	f	class:seastar::thread_context
switch_in	core/thread.cc	/^thread_context::switch_in() {$/;"	f	class:seastar::thread_context
switch_in	core/thread.cc	/^void switch_in(thread_context* to) {$/;"	f	namespace:seastar::thread_impl
switch_out	core/thread.cc	/^thread_context::switch_out() {$/;"	f	class:seastar::thread_context
switch_out	core/thread.cc	/^void switch_out(thread_context* from) {$/;"	f	namespace:seastar::thread_impl
thread_context	core/thread.cc	/^thread_context::thread_context(std::function<void ()> func)$/;"	f	class:seastar::thread_context
thread_impl	core/thread.cc	/^namespace thread_impl {$/;"	n	namespace:seastar	file:
_context	core/thread.hh	/^    jmp_buf_link _context;$/;"	m	class:seastar::thread_context
_context	core/thread.hh	/^    std::unique_ptr<thread_context> _context;$/;"	m	class:seastar::thread
_current	core/thread.hh	/^    static thread_local thread* _current;$/;"	m	class:seastar::thread
_done	core/thread.hh	/^    promise<> _done;$/;"	m	class:seastar::thread_context
_func	core/thread.hh	/^    std::function<void ()> _func;$/;"	m	class:seastar::thread_context
_joined	core/thread.hh	/^    bool _joined = false;$/;"	m	class:seastar::thread_context
_stack_size	core/thread.hh	/^    static constexpr size_t _stack_size = 128*1024;$/;"	m	class:seastar::thread_context
async	core/thread.hh	/^async(Func&& func, Args&&... args) {$/;"	f	namespace:seastar
jmp_buf_link	core/thread.hh	/^struct jmp_buf_link {$/;"	s	namespace:seastar
jmpbuf	core/thread.hh	/^    jmp_buf jmpbuf;$/;"	m	struct:seastar::jmp_buf_link
join	core/thread.hh	/^thread::join() {$/;"	f	class:seastar::thread
link	core/thread.hh	/^    jmp_buf_link* link;$/;"	m	struct:seastar::jmp_buf_link
noexcept	core/thread.hh	/^    thread& operator=(thread&& x) noexcept = default;$/;"	m	class:seastar::thread
noexcept	core/thread.hh	/^    thread(thread&& x) noexcept = default;$/;"	m	class:seastar::thread
seastar	core/thread.hh	/^namespace seastar {$/;"	n
thread	core/thread.hh	/^    thread_context* thread;$/;"	m	struct:seastar::jmp_buf_link
thread	core/thread.hh	/^class thread {$/;"	c	namespace:seastar
thread	core/thread.hh	/^thread::thread(Func func)$/;"	f	class:seastar::thread
thread_context	core/thread.hh	/^class thread_context {$/;"	c	namespace:seastar
thread_impl	core/thread.hh	/^namespace thread_impl {$/;"	n	namespace:seastar
~thread	core/thread.hh	/^    ~thread() { assert(!_context || _context->_joined); }$/;"	f	class:seastar::thread
__TIMER_SET_HH	core/timer-set.hh	15;"	d
_buckets	core/timer-set.hh	/^    std::array<timer_list_t, n_buckets> _buckets;$/;"	m	class:seastar::timer_set
_last	core/timer-set.hh	/^    timestamp_t _last;$/;"	m	class:seastar::timer_set
_next	core/timer-set.hh	/^    timestamp_t _next;$/;"	m	class:seastar::timer_set
_non_empty_buckets	core/timer-set.hh	/^    std::bitset<n_buckets> _non_empty_buckets;$/;"	m	class:seastar::timer_set
clear	core/timer-set.hh	/^    void clear()$/;"	f	class:seastar::timer_set
empty	core/timer-set.hh	/^    bool empty() const$/;"	f	class:seastar::timer_set
expire	core/timer-set.hh	/^    timer_list_t expire(time_point now)$/;"	f	class:seastar::timer_set
get_index	core/timer-set.hh	/^    int get_index(Timer& timer) const$/;"	f	class:seastar::timer_set
get_index	core/timer-set.hh	/^    int get_index(timestamp_t timestamp) const$/;"	f	class:seastar::timer_set
get_last_non_empty_bucket	core/timer-set.hh	/^    int get_last_non_empty_bucket() const$/;"	f	class:seastar::timer_set
get_next_timeout	core/timer-set.hh	/^    time_point get_next_timeout() const$/;"	f	class:seastar::timer_set
get_timestamp	core/timer-set.hh	/^    static timestamp_t get_timestamp(Timer& timer)$/;"	f	class:seastar::timer_set
get_timestamp	core/timer-set.hh	/^    static timestamp_t get_timestamp(time_point _time_point)$/;"	f	class:seastar::timer_set
insert	core/timer-set.hh	/^    bool insert(Timer& timer)$/;"	f	class:seastar::timer_set
max_timestamp	core/timer-set.hh	/^    static constexpr timestamp_t max_timestamp = std::numeric_limits<timestamp_t>::max();$/;"	m	class:seastar::timer_set
n_buckets	core/timer-set.hh	/^    static constexpr int n_buckets = timestamp_bits + 1;$/;"	m	class:seastar::timer_set
now	core/timer-set.hh	/^    time_point now() {$/;"	f	class:seastar::timer_set
remove	core/timer-set.hh	/^    void remove(Timer& timer)$/;"	f	class:seastar::timer_set
seastar	core/timer-set.hh	/^namespace seastar {$/;"	n
size	core/timer-set.hh	/^    size_t size() const$/;"	f	class:seastar::timer_set
timer_set	core/timer-set.hh	/^    timer_set()$/;"	f	class:seastar::timer_set
timer_set	core/timer-set.hh	/^class timer_set {$/;"	c	namespace:seastar
timestamp_bits	core/timer-set.hh	/^    static constexpr int timestamp_bits = std::numeric_limits<timestamp_t>::digits;$/;"	m	class:seastar::timer_set
~timer_set	core/timer-set.hh	/^    ~timer_set() {$/;"	f	class:seastar::timer_set
_armed	core/timer.hh	/^    bool _armed = false;$/;"	m	class:timer
_callback	core/timer.hh	/^    callback_t _callback;$/;"	m	class:timer
_expired	core/timer.hh	/^            _armed(t._armed), _queued(t._queued), _expired(t._expired) {$/;"	f	class:timer
_expired	core/timer.hh	/^    bool _expired = false;$/;"	m	class:timer
_expiry	core/timer.hh	/^    time_point _expiry;$/;"	m	class:timer
_period	core/timer.hh	/^    std::experimental::optional<duration> _period;$/;"	m	class:timer
_queued	core/timer.hh	/^    bool _queued = false;$/;"	m	class:timer
armed	core/timer.hh	/^    bool armed() const { return _armed; }$/;"	f	class:timer
clock	core/timer.hh	/^    typedef Clock clock;$/;"	t	class:timer
duration	core/timer.hh	/^    typedef typename Clock::duration duration;$/;"	t	class:timer
time_point	core/timer.hh	/^    typedef typename Clock::time_point time_point;$/;"	t	class:timer
timer	core/timer.hh	/^class timer {$/;"	c
TRANSFER_HH_	core/transfer.hh	23;"	d
transfer_pass1	core/transfer.hh	/^transfer_pass1(Alloc& a, T* from, T* to,$/;"	f
transfer_pass2	core/transfer.hh	/^transfer_pass2(Alloc& a, T* from, T* to,$/;"	f
operator =	core/unaligned.hh	/^    unaligned& operator=(const T& x) { raw = x; return *this; }$/;"	f	struct:unaligned
operator T	core/unaligned.hh	/^    operator T() const { return raw; }$/;"	f	struct:unaligned
raw	core/unaligned.hh	/^    T raw;$/;"	m	struct:unaligned
unaligned	core/unaligned.hh	/^    unaligned(T x) : raw(x) {}$/;"	f	struct:unaligned
unaligned	core/unaligned.hh	/^struct unaligned {$/;"	s
unaligned_cast	core/unaligned.hh	/^inline auto unaligned_cast(F* p) {$/;"	f
unaligned_cast	core/unaligned.hh	/^inline auto unaligned_cast(const F* p) {$/;"	f
GB	core/units.hh	/^static constexpr size_t GB = 1 << 30;$/;"	v
KB	core/units.hh	/^static constexpr size_t KB = 1 << 10;$/;"	v
MB	core/units.hh	/^static constexpr size_t MB = 1 << 20;$/;"	v
UNITS_HH_	core/units.hh	23;"	d
VECTOR_DATA_SINK_HH_	core/vector-data-sink.hh	23;"	d
_v	core/vector-data-sink.hh	/^    vector_type& _v;$/;"	m	class:final
final	core/vector-data-sink.hh	/^class vector_data_sink final : public data_sink_impl {$/;"	c
vector_data_sink	core/vector-data-sink.hh	/^    vector_data_sink(vector_type& v) : _v(v) {}$/;"	f	class:final
VLA_HH_	core/vla.hh	23;"	d
make_struct_with_vla	core/vla.hh	/^make_struct_with_vla(E S::*last, size_t nr) {$/;"	f
_evtchn	core/xen/evtchn.cc	/^    pollable_fd _evtchn;$/;"	m	class:xen::userspace_evtchn	file:
_instance	core/xen/evtchn.cc	/^evtchn *evtchn::_instance = nullptr;$/;"	m	class:xen::evtchn	file:
_notified	core/xen/evtchn.cc	/^    std::unique_ptr<reactor_notifier> _notified;$/;"	m	class:xen::kernel_evtchn	file:
bind	core/xen/evtchn.cc	/^port kernel_evtchn::bind() {$/;"	f	class:xen::kernel_evtchn
bind	core/xen/evtchn.cc	/^port userspace_evtchn::bind()$/;"	f	class:xen::userspace_evtchn
instance	core/xen/evtchn.cc	/^evtchn *evtchn::instance()$/;"	f	class:xen::evtchn
instance	core/xen/evtchn.cc	/^evtchn *evtchn::instance(bool userspace, unsigned otherend)$/;"	f	class:xen::evtchn
kernel_evtchn	core/xen/evtchn.cc	/^    kernel_evtchn(unsigned otherend)$/;"	f	class:xen::kernel_evtchn
kernel_evtchn	core/xen/evtchn.cc	/^class kernel_evtchn: public evtchn {$/;"	c	namespace:xen	file:
make_ready	core/xen/evtchn.cc	/^void kernel_evtchn::make_ready(void *arg) {$/;"	f	class:xen::kernel_evtchn
make_ready_port	core/xen/evtchn.cc	/^void evtchn::make_ready_port(int port) {$/;"	f	class:xen::evtchn
notify	core/xen/evtchn.cc	/^void kernel_evtchn::notify(int port) {$/;"	f	class:xen::kernel_evtchn
notify	core/xen/evtchn.cc	/^void port::notify() {$/;"	f	class:xen::port
notify	core/xen/evtchn.cc	/^void userspace_evtchn::notify(int port)$/;"	f	class:xen::userspace_evtchn
operator =	core/xen/evtchn.cc	/^port& port::operator=(port&& other) {$/;"	f	class:xen::port
override	core/xen/evtchn.cc	/^    virtual port bind() override;$/;"	m	class:xen::kernel_evtchn	file:
override	core/xen/evtchn.cc	/^    virtual port bind() override;$/;"	m	class:xen::userspace_evtchn	file:
override	core/xen/evtchn.cc	/^    virtual void notify(int port) override;$/;"	m	class:xen::kernel_evtchn	file:
override	core/xen/evtchn.cc	/^    virtual void notify(int port) override;$/;"	m	class:xen::userspace_evtchn	file:
override	core/xen/evtchn.cc	/^    virtual void umask(int *port, unsigned count) override;$/;"	m	class:xen::userspace_evtchn	file:
pending	core/xen/evtchn.cc	/^future<> port::pending() {$/;"	f	class:xen::port
port	core/xen/evtchn.cc	/^port::port(int p)$/;"	f	class:xen::port
port	core/xen/evtchn.cc	/^port::port(port&& other)$/;"	f	class:xen::port
port_deleted	core/xen/evtchn.cc	/^void evtchn::port_deleted(int prt, port* obj) {$/;"	f	class:xen::evtchn
port_moved	core/xen/evtchn.cc	/^void evtchn::port_moved(int prt, port* old, port* now) {$/;"	f	class:xen::evtchn
ports	core/xen/evtchn.cc	/^    int ports[2];$/;"	m	class:xen::userspace_evtchn	file:
process_interrupts	core/xen/evtchn.cc	/^void kernel_evtchn::process_interrupts(int port) {$/;"	f	class:xen::kernel_evtchn
umask	core/xen/evtchn.cc	/^void port::umask() {$/;"	f	class:xen::port
umask	core/xen/evtchn.cc	/^void userspace_evtchn::umask(int *port, unsigned count)$/;"	f	class:xen::userspace_evtchn
userspace_evtchn	core/xen/evtchn.cc	/^class userspace_evtchn: public evtchn {$/;"	c	namespace:xen	file:
userspace_evtchn	core/xen/evtchn.cc	/^userspace_evtchn::userspace_evtchn(unsigned otherend)$/;"	f	class:xen::userspace_evtchn
xen	core/xen/evtchn.cc	/^namespace xen {$/;"	n	file:
~port	core/xen/evtchn.cc	/^port::~port() {$/;"	f	class:xen::port
_XEN_EVTCHN_HH	core/xen/evtchn.hh	19;"	d
_evtchn	core/xen/evtchn.hh	/^    evtchn *_evtchn;$/;"	m	class:xen::port
_instance	core/xen/evtchn.hh	/^    static evtchn *_instance;$/;"	m	class:xen::evtchn
_otherend	core/xen/evtchn.hh	/^    unsigned _otherend;$/;"	m	class:xen::evtchn
_port	core/xen/evtchn.hh	/^    int _port = -1;$/;"	m	class:xen::port
_ports	core/xen/evtchn.hh	/^    std::unordered_multimap<int, port*> _ports;$/;"	m	class:xen::evtchn
_sem	core/xen/evtchn.hh	/^    semaphore _sem;$/;"	m	class:xen::port
bind	core/xen/evtchn.hh	/^    port bind(int p) { return port(p); };$/;"	f	class:xen::evtchn
evtchn	core/xen/evtchn.hh	/^    evtchn(unsigned otherend) : _otherend(otherend) {}$/;"	f	class:xen::evtchn
evtchn	core/xen/evtchn.hh	/^class evtchn {$/;"	c	namespace:xen
number	core/xen/evtchn.hh	/^    int number() const { return _port; }$/;"	f	class:xen::port
port	core/xen/evtchn.hh	/^class port {$/;"	c	namespace:xen
umask	core/xen/evtchn.hh	/^    virtual void umask(int *port, unsigned count) {};$/;"	f	class:xen::evtchn
xen	core/xen/evtchn.hh	/^namespace xen {$/;"	n
_gntalloc	core/xen/gntalloc.cc	/^    file_desc _gntalloc;$/;"	m	class:xen::userspace_gntalloc	file:
_gntmap	core/xen/gntalloc.cc	/^    mmap_area _gntmap;$/;"	m	class:xen::userspace_gntalloc	file:
_head	core/xen/gntalloc.cc	/^    uint32_t _head;$/;"	m	class:xen::kernel_grant_head	file:
_instance	core/xen/gntalloc.cc	/^gntalloc *gntalloc::_instance = nullptr;$/;"	m	class:xen::gntalloc	file:
_ref_head	core/xen/gntalloc.cc	/^    std::atomic<int> _ref_head = { 0 };$/;"	m	class:xen::userspace_grant_head	file:
_refs	core/xen/gntalloc.cc	/^    std::vector<gntref> _refs;$/;"	m	class:xen::userspace_grant_head	file:
_rx_grants	core/xen/gntalloc.cc	/^    static constexpr int _rx_grants = 256;$/;"	m	class:xen::kernel_gntalloc	file:
_tx_grants	core/xen/gntalloc.cc	/^    static constexpr int _tx_grants = 256;$/;"	m	class:xen::kernel_gntalloc	file:
alloc_ref	core/xen/gntalloc.cc	/^gntref kernel_gntalloc::alloc_ref() {$/;"	f	class:xen::kernel_gntalloc
alloc_ref	core/xen/gntalloc.cc	/^gntref userspace_gntalloc::alloc_ref() {$/;"	f	class:xen::userspace_gntalloc
alloc_ref	core/xen/gntalloc.cc	/^grant_head *kernel_gntalloc::alloc_ref(unsigned nr_ents) {$/;"	f	class:xen::kernel_gntalloc
alloc_ref	core/xen/gntalloc.cc	/^grant_head *userspace_gntalloc::alloc_ref(unsigned nr_ents) {$/;"	f	class:xen::userspace_gntalloc
free_ref	core/xen/gntalloc.cc	/^void kernel_grant_head::free_ref(gntref& ref) {$/;"	f	class:xen::kernel_grant_head
free_ref	core/xen/gntalloc.cc	/^void userspace_grant_head::free_ref(gntref& ref) {$/;"	f	class:xen::userspace_grant_head
get_gref	core/xen/gntalloc.cc	/^userspace_gntalloc::get_gref(unsigned nr_ents)$/;"	f	class:xen::userspace_gntalloc
instance	core/xen/gntalloc.cc	/^gntalloc *gntalloc::instance() {$/;"	f	class:xen::gntalloc
instance	core/xen/gntalloc.cc	/^gntalloc *gntalloc::instance(bool userspace, unsigned otherend) {$/;"	f	class:xen::gntalloc
invalid_ref	core/xen/gntalloc.cc	/^gntref invalid_ref;$/;"	m	namespace:xen	file:
kernel_gntalloc	core/xen/gntalloc.cc	/^    kernel_gntalloc(unsigned otherend) : gntalloc(otherend) {}$/;"	f	class:xen::kernel_gntalloc
kernel_gntalloc	core/xen/gntalloc.cc	/^class kernel_gntalloc : public gntalloc {$/;"	c	namespace:xen	file:
kernel_grant_head	core/xen/gntalloc.cc	/^    kernel_grant_head(uint32_t head) : _head(head) {}$/;"	f	class:xen::kernel_grant_head
kernel_grant_head	core/xen/gntalloc.cc	/^class kernel_grant_head : public grant_head {$/;"	c	namespace:xen	file:
new_frame	core/xen/gntalloc.cc	/^void *kernel_gntalloc::new_frame() {$/;"	f	class:xen::kernel_gntalloc
new_ref	core/xen/gntalloc.cc	/^gntref kernel_grant_head::new_ref() {$/;"	f	class:xen::kernel_grant_head
new_ref	core/xen/gntalloc.cc	/^gntref kernel_grant_head::new_ref(void *addr, size_t size) {$/;"	f	class:xen::kernel_grant_head
new_ref	core/xen/gntalloc.cc	/^gntref userspace_grant_head::new_ref() {$/;"	f	class:xen::userspace_grant_head
new_ref	core/xen/gntalloc.cc	/^gntref userspace_grant_head::new_ref(void *addr, size_t size) {$/;"	f	class:xen::userspace_grant_head
override	core/xen/gntalloc.cc	/^    virtual gntref alloc_ref() override;$/;"	m	class:xen::kernel_gntalloc	file:
override	core/xen/gntalloc.cc	/^    virtual gntref alloc_ref() override;$/;"	m	class:xen::userspace_gntalloc	file:
override	core/xen/gntalloc.cc	/^    virtual gntref new_ref() override;$/;"	m	class:xen::kernel_grant_head	file:
override	core/xen/gntalloc.cc	/^    virtual gntref new_ref() override;$/;"	m	class:xen::userspace_grant_head	file:
override	core/xen/gntalloc.cc	/^    virtual gntref new_ref(void *addr, size_t size) override;$/;"	m	class:xen::kernel_grant_head	file:
override	core/xen/gntalloc.cc	/^    virtual gntref new_ref(void *addr, size_t size) override;$/;"	m	class:xen::userspace_grant_head	file:
override	core/xen/gntalloc.cc	/^    virtual grant_head *alloc_ref(unsigned refs) override;$/;"	m	class:xen::kernel_gntalloc	file:
override	core/xen/gntalloc.cc	/^    virtual grant_head *alloc_ref(unsigned refs) override;$/;"	m	class:xen::userspace_gntalloc	file:
rx_head	core/xen/gntalloc.cc	/^    uint32_t tx_head, rx_head;$/;"	m	class:xen::kernel_gntalloc	file:
tx_head	core/xen/gntalloc.cc	/^    uint32_t tx_head, rx_head;$/;"	m	class:xen::kernel_gntalloc	file:
userspace_gntalloc	core/xen/gntalloc.cc	/^class userspace_gntalloc : public gntalloc {$/;"	c	namespace:xen	file:
userspace_gntalloc	core/xen/gntalloc.cc	/^userspace_gntalloc::userspace_gntalloc(unsigned otherend)$/;"	f	class:xen::userspace_gntalloc
userspace_grant_head	core/xen/gntalloc.cc	/^    userspace_grant_head(std::vector<gntref> v) : _refs(v) {}$/;"	f	class:xen::userspace_grant_head
userspace_grant_head	core/xen/gntalloc.cc	/^class userspace_grant_head : public grant_head {$/;"	c	namespace:xen	file:
virt_to_mfn	core/xen/gntalloc.cc	/^virt_to_mfn(void *virt) {$/;"	f	namespace:xen
xen	core/xen/gntalloc.cc	/^namespace xen {$/;"	n	file:
_XEN_GNTALLOC_HH	core/xen/gntalloc.hh	19;"	d
_id	core/xen/gntalloc.hh	/^    unsigned _id = 0;$/;"	m	class:xen::grant_head
_instance	core/xen/gntalloc.hh	/^    static gntalloc *_instance;$/;"	m	class:xen::gntalloc
_otherend	core/xen/gntalloc.hh	/^    unsigned _otherend;$/;"	m	class:xen::gntalloc
gntalloc	core/xen/gntalloc.hh	/^    gntalloc(unsigned otherend) : _otherend(otherend) {}$/;"	f	class:xen::gntalloc
gntalloc	core/xen/gntalloc.hh	/^class gntalloc {$/;"	c	namespace:xen
gntref	core/xen/gntalloc.hh	/^    gntref() : xen_id(-1), page(nullptr) {}$/;"	f	class:xen::gntref
gntref	core/xen/gntalloc.hh	/^    gntref(int id, void *page) : xen_id(id), page(page) {}$/;"	f	class:xen::gntref
gntref	core/xen/gntalloc.hh	/^class gntref {$/;"	c	namespace:xen
grant_head	core/xen/gntalloc.hh	/^class grant_head {$/;"	c	namespace:xen
operator =	core/xen/gntalloc.hh	/^    gntref& operator=(const gntref &a) { xen_id = a.xen_id; page = a.page; return *this; }$/;"	f	class:xen::gntref
operator ==	core/xen/gntalloc.hh	/^    bool operator==(const gntref &a) { return (xen_id == a.xen_id) && (page == a.page); }$/;"	f	class:xen::gntref
operator bool	core/xen/gntalloc.hh	/^    operator bool() const { return xen_id != -1 && page != nullptr; }$/;"	f	class:xen::gntref
page	core/xen/gntalloc.hh	/^    void* page;$/;"	m	class:xen::gntref
xen	core/xen/gntalloc.hh	/^namespace xen {$/;"	n
xen_id	core/xen/gntalloc.hh	/^    int xen_id;$/;"	m	class:xen::gntref
_XEN_HH	core/xen/osv_xen.hh	19;"	d
_instance	core/xen/xenstore.cc	/^xenstore *xenstore::_instance = nullptr;$/;"	m	class:xenstore	file:
end_transaction	core/xen/xenstore.cc	/^void xenstore::end_transaction(xs_transaction_t t)$/;"	f	class:xenstore
instance	core/xen/xenstore.cc	/^xenstore *xenstore::instance() {$/;"	f	class:xenstore
ls	core/xen/xenstore.cc	/^std::list<std::string> xenstore::ls(std::string path, xenstore_transaction &t)$/;"	f	class:xenstore
read	core/xen/xenstore.cc	/^std::string xenstore::read(std::string path, xenstore_transaction &t)$/;"	f	class:xenstore
remove	core/xen/xenstore.cc	/^void xenstore::remove(std::string path, xenstore_transaction &t)$/;"	f	class:xenstore
start_transaction	core/xen/xenstore.cc	/^xs_transaction_t xenstore::start_transaction()$/;"	f	class:xenstore
write	core/xen/xenstore.cc	/^void xenstore::write(std::string path, std::string value, xenstore_transaction &t)$/;"	f	class:xenstore
xenstore	core/xen/xenstore.cc	/^xenstore::xenstore()$/;"	f	class:xenstore
~xenstore	core/xen/xenstore.cc	/^xenstore::~xenstore()$/;"	f	class:xenstore
XENSTORE_HH_	core/xen/xenstore.hh	23;"	d
_h	core/xen/xenstore.hh	/^    struct xs_handle *_h;$/;"	m	class:xenstore	typeref:struct:xenstore::xs_handle
_instance	core/xen/xenstore.hh	/^    static xenstore *_instance;$/;"	m	class:xenstore
_t	core/xen/xenstore.hh	/^        xs_transaction_t _t = 0;$/;"	m	class:xenstore::xenstore_transaction
_x	core/xen/xenstore.hh	/^        xenstore *_x;$/;"	m	class:xenstore::xenstore_transaction
_xs_null	core/xen/xenstore.hh	/^    static xenstore_transaction _xs_null; \/\/ having it here simplify forward decls$/;"	m	class:xenstore
read	core/xen/xenstore.hh	/^    T read(std::string path, xenstore_transaction &t = _xs_null) { return boost::lexical_cast<T>(read(path, t)); }$/;"	f	class:xenstore
read_or_default	core/xen/xenstore.hh	/^    T read_or_default(std::string path, T deflt = T(), xenstore_transaction &t = _xs_null) {$/;"	f	class:xenstore
t	core/xen/xenstore.hh	/^        xs_transaction_t t() { return _t; }$/;"	f	class:xenstore::xenstore_transaction
write	core/xen/xenstore.hh	/^    void write(std::string path, T val, xenstore_transaction &t = _xs_null) { return write(path, std::to_string(val), t); }$/;"	f	class:xenstore
xenstore	core/xen/xenstore.hh	/^class xenstore {$/;"	c
xenstore_transaction	core/xen/xenstore.hh	/^        explicit xenstore_transaction() {}$/;"	f	class:xenstore::xenstore_transaction
xenstore_transaction	core/xen/xenstore.hh	/^        explicit xenstore_transaction(xenstore *x) : _x(x)$/;"	f	class:xenstore::xenstore_transaction
xenstore_transaction	core/xen/xenstore.hh	/^    class xenstore_transaction {$/;"	c	class:xenstore
~xenstore_transaction	core/xen/xenstore.hh	/^        ~xenstore_transaction() { if (_t) { _x->end_transaction(_t);  } }$/;"	f	class:xenstore::xenstore_transaction
DEFAULT_DIR	http/api_docs.cc	/^const sstring api_registry_builder::DEFAULT_DIR = ".";$/;"	m	class:httpd::api_registry_builder	file:
DEFAULT_PATH	http/api_docs.cc	/^const sstring api_registry_builder::DEFAULT_PATH = "\/api-doc";$/;"	m	class:httpd::api_registry_builder	file:
httpd	http/api_docs.cc	/^namespace httpd {$/;"	n	file:
API_DOCS_HH_	http/api_docs.hh	23;"	d
DEFAULT_DIR	http/api_docs.hh	/^    static const sstring DEFAULT_DIR;$/;"	m	class:httpd::api_registry_builder
DEFAULT_PATH	http/api_docs.hh	/^    static const sstring DEFAULT_PATH;$/;"	m	class:httpd::api_registry_builder
_base_path	http/api_docs.hh	/^    sstring _base_path;$/;"	m	class:httpd::api_registry
_base_path	http/api_docs.hh	/^    sstring _base_path;$/;"	m	class:httpd::api_registry_builder
_docs	http/api_docs.hh	/^    api_docs _docs;$/;"	m	class:httpd::api_registry
_file_directory	http/api_docs.hh	/^    sstring _file_directory;$/;"	m	class:httpd::api_registry
_file_directory	http/api_docs.hh	/^    sstring _file_directory;$/;"	m	class:httpd::api_registry_builder
_routes	http/api_docs.hh	/^    routes& _routes;$/;"	m	class:httpd::api_registry
apiVersion	http/api_docs.hh	/^    json::json_element<std::string> apiVersion;$/;"	m	struct:httpd::api_docs
api_doc	http/api_docs.hh	/^    api_doc() {$/;"	f	struct:httpd::api_doc
api_doc	http/api_docs.hh	/^    api_doc(const api_doc & e) {$/;"	f	struct:httpd::api_doc
api_doc	http/api_docs.hh	/^struct api_doc : public json::json_base {$/;"	s	namespace:httpd
api_docs	http/api_docs.hh	/^    api_docs() {$/;"	f	struct:httpd::api_docs
api_docs	http/api_docs.hh	/^    api_docs(const api_docs & e) {$/;"	f	struct:httpd::api_docs
api_docs	http/api_docs.hh	/^struct api_docs : public json::json_base {$/;"	s	namespace:httpd
api_registry	http/api_docs.hh	/^    api_registry(routes& routes, const sstring& file_directory,$/;"	f	class:httpd::api_registry
api_registry	http/api_docs.hh	/^class api_registry : public handler_base {$/;"	c	namespace:httpd
api_registry_builder	http/api_docs.hh	/^    api_registry_builder(const sstring& file_directory = DEFAULT_DIR,$/;"	f	class:httpd::api_registry_builder
api_registry_builder	http/api_docs.hh	/^class api_registry_builder {$/;"	c	namespace:httpd
apis	http/api_docs.hh	/^    json::json_list<api_doc> apis;$/;"	m	struct:httpd::api_docs
description	http/api_docs.hh	/^    json::json_element<std::string> description;$/;"	m	struct:httpd::api_doc
httpd	http/api_docs.hh	/^namespace httpd {$/;"	n
operator =	http/api_docs.hh	/^    api_doc& operator=(const T& e) {$/;"	f	struct:httpd::api_doc
operator =	http/api_docs.hh	/^    api_doc& operator=(const api_doc& e) {$/;"	f	struct:httpd::api_doc
operator =	http/api_docs.hh	/^    api_docs& operator=(const T& e) {$/;"	f	struct:httpd::api_docs
operator =	http/api_docs.hh	/^    api_docs& operator=(const api_docs& e) {$/;"	f	struct:httpd::api_docs
path	http/api_docs.hh	/^    json::json_element<std::string> path;$/;"	m	struct:httpd::api_doc
reg	http/api_docs.hh	/^    void reg(const sstring& api, const sstring& description,$/;"	f	class:httpd::api_registry
register_function	http/api_docs.hh	/^    void register_function(routes& r, const sstring& api,$/;"	f	class:httpd::api_registry_builder
register_params	http/api_docs.hh	/^    void register_params() {$/;"	f	struct:httpd::api_doc
register_params	http/api_docs.hh	/^    void register_params() {$/;"	f	struct:httpd::api_docs
set_api_doc	http/api_docs.hh	/^    void set_api_doc(routes& r) {$/;"	f	class:httpd::api_registry_builder
swaggerVersion	http/api_docs.hh	/^    json::json_element<std::string> swaggerVersion;$/;"	m	struct:httpd::api_docs
httpd	http/common.cc	/^namespace httpd {$/;"	n	file:
str2type	http/common.cc	/^operation_type str2type(const sstring& type) {$/;"	f	namespace:httpd
COMMON_HH_	http/common.hh	23;"	d
DELETE	http/common.hh	/^    GET, POST, PUT, DELETE, NUM_OPERATION$/;"	e	enum:httpd::operation_type
GET	http/common.hh	/^    GET, POST, PUT, DELETE, NUM_OPERATION$/;"	e	enum:httpd::operation_type
NUM_OPERATION	http/common.hh	/^    GET, POST, PUT, DELETE, NUM_OPERATION$/;"	e	enum:httpd::operation_type
POST	http/common.hh	/^    GET, POST, PUT, DELETE, NUM_OPERATION$/;"	e	enum:httpd::operation_type
PUT	http/common.hh	/^    GET, POST, PUT, DELETE, NUM_OPERATION$/;"	e	enum:httpd::operation_type
at	http/common.hh	/^    const sstring& at(const sstring& key) const {$/;"	f	class:httpd::parameters
clear	http/common.hh	/^    void clear() {$/;"	f	class:httpd::parameters
exists	http/common.hh	/^    bool exists(const sstring& key) const {$/;"	f	class:httpd::parameters
httpd	http/common.hh	/^namespace httpd {$/;"	n
operation_type	http/common.hh	/^enum operation_type {$/;"	g	namespace:httpd
operator []	http/common.hh	/^    sstring operator[](const sstring& key) const {$/;"	f	class:httpd::parameters
parameters	http/common.hh	/^class parameters {$/;"	c	namespace:httpd
params	http/common.hh	/^    std::unordered_map<sstring, sstring> params;$/;"	m	class:httpd::parameters
path	http/common.hh	/^    const sstring& path(const sstring& key) const {$/;"	f	class:httpd::parameters
set	http/common.hh	/^    void set(const sstring& key, const sstring& value) {$/;"	f	class:httpd::parameters
EXCEPTION_HH_	http/exception.hh	23;"	d
_code	http/exception.hh	/^    json::json_element<int> _code;$/;"	m	class:httpd::json_exception
_msg	http/exception.hh	/^    json::json_element<std::string> _msg;$/;"	m	class:httpd::json_exception
_msg	http/exception.hh	/^    std::string _msg;$/;"	m	class:httpd::base_exception
_status	http/exception.hh	/^    reply::status_type _status;$/;"	m	class:httpd::base_exception
bad_param_exception	http/exception.hh	/^    bad_param_exception(const std::string& msg)$/;"	f	class:httpd::bad_param_exception
bad_param_exception	http/exception.hh	/^class bad_param_exception : public bad_request_exception {$/;"	c	namespace:httpd
bad_request_exception	http/exception.hh	/^    bad_request_exception(const std::string& msg)$/;"	f	class:httpd::bad_request_exception
bad_request_exception	http/exception.hh	/^class bad_request_exception : public base_exception {$/;"	c	namespace:httpd
base_exception	http/exception.hh	/^    base_exception(const std::string& msg, reply::status_type status)$/;"	f	class:httpd::base_exception
base_exception	http/exception.hh	/^class base_exception : public std::exception {$/;"	c	namespace:httpd
httpd	http/exception.hh	/^namespace httpd {$/;"	n
json_exception	http/exception.hh	/^    json_exception(const base_exception & e) {$/;"	f	class:httpd::json_exception
json_exception	http/exception.hh	/^    json_exception(const std::exception& e) {$/;"	f	class:httpd::json_exception
json_exception	http/exception.hh	/^class json_exception : public json::json_base {$/;"	c	namespace:httpd
missing_param_exception	http/exception.hh	/^    missing_param_exception(const std::string& param)$/;"	f	class:httpd::missing_param_exception
missing_param_exception	http/exception.hh	/^class missing_param_exception : public bad_request_exception {$/;"	c	namespace:httpd
not_found_exception	http/exception.hh	/^    not_found_exception(const std::string& msg = "Not found")$/;"	f	class:httpd::not_found_exception
not_found_exception	http/exception.hh	/^class not_found_exception : public base_exception {$/;"	c	namespace:httpd
redirect_exception	http/exception.hh	/^    redirect_exception(const std::string& url)$/;"	f	class:httpd::redirect_exception
redirect_exception	http/exception.hh	/^class redirect_exception : public base_exception {$/;"	c	namespace:httpd
register_params	http/exception.hh	/^    void register_params() {$/;"	f	class:httpd::json_exception
server_error_exception	http/exception.hh	/^    server_error_exception(const std::string& msg)$/;"	f	class:httpd::server_error_exception
server_error_exception	http/exception.hh	/^class server_error_exception : public base_exception {$/;"	c	namespace:httpd
set	http/exception.hh	/^    void set(const std::string& msg, reply::status_type code) {$/;"	f	class:httpd::json_exception
status	http/exception.hh	/^    reply::status_type status() const {$/;"	f	class:httpd::base_exception
str	http/exception.hh	/^    virtual const std::string& str() const {$/;"	f	class:httpd::base_exception
url	http/exception.hh	/^    std::string url;$/;"	m	class:httpd::redirect_exception
what	http/exception.hh	/^    virtual const char* what() const throw () {$/;"	f	class:httpd::base_exception
_rep	http/file_handler.cc	/^    std::unique_ptr<reply> _rep;$/;"	m	struct:httpd::reader	file:
directory_handler	http/file_handler.cc	/^directory_handler::directory_handler(const sstring& doc_root,$/;"	f	class:httpd::directory_handler
get_extension	http/file_handler.cc	/^sstring file_interaction_handler::get_extension(const sstring& file) {$/;"	f	class:httpd::file_interaction_handler
handle	http/file_handler.cc	/^future<std::unique_ptr<reply>> directory_handler::handle(const sstring& path,$/;"	f	class:httpd::directory_handler
handle	http/file_handler.cc	/^future<std::unique_ptr<reply>> file_handler::handle(const sstring& path,$/;"	f	class:httpd::file_handler
httpd	http/file_handler.cc	/^namespace httpd {$/;"	n	file:
is	http/file_handler.cc	/^    input_stream<char> is;$/;"	m	struct:httpd::reader	file:
operator ()	http/file_handler.cc	/^    future<unconsumed_remainder> operator()(temporary_buffer<char> data) {$/;"	f	struct:httpd::reader
read	http/file_handler.cc	/^future<std::unique_ptr<reply>> file_interaction_handler::read($/;"	f	class:httpd::file_interaction_handler
reader	http/file_handler.cc	/^    reader(file f, std::unique_ptr<reply> rep)$/;"	f	struct:httpd::reader
reader	http/file_handler.cc	/^struct reader {$/;"	s	namespace:httpd	file:
redirect_if_needed	http/file_handler.cc	/^bool file_interaction_handler::redirect_if_needed(const request& req,$/;"	f	class:httpd::file_interaction_handler
~file_interaction_handler	http/file_handler.cc	/^file_interaction_handler::~file_interaction_handler() {$/;"	f	class:httpd::file_interaction_handler
HTTP_FILE_HANDLER_HH_	http/file_handler.hh	23;"	d
directory_handler	http/file_handler.hh	/^class directory_handler : public file_interaction_handler {$/;"	c	namespace:httpd
doc_root	http/file_handler.hh	/^    sstring doc_root;$/;"	m	class:httpd::directory_handler
file	http/file_handler.hh	/^    sstring file;$/;"	m	class:httpd::file_handler
file_handler	http/file_handler.hh	/^    explicit file_handler(const sstring& file, file_transformer* transformer =$/;"	f	class:httpd::file_handler
file_handler	http/file_handler.hh	/^class file_handler : public file_interaction_handler {$/;"	c	namespace:httpd
file_interaction_handler	http/file_handler.hh	/^    file_interaction_handler(file_transformer* p = nullptr)$/;"	f	class:httpd::file_interaction_handler
file_interaction_handler	http/file_handler.hh	/^class file_interaction_handler : public handler_base {$/;"	c	namespace:httpd
file_transformer	http/file_handler.hh	/^class file_transformer {$/;"	c	namespace:httpd
force_path	http/file_handler.hh	/^    bool force_path;$/;"	m	class:httpd::file_handler
httpd	http/file_handler.hh	/^namespace httpd {$/;"	n
override	http/file_handler.hh	/^            std::unique_ptr<request> req, std::unique_ptr<reply> rep) override;$/;"	m	class:httpd::directory_handler
override	http/file_handler.hh	/^            std::unique_ptr<request> req, std::unique_ptr<reply> rep) override;$/;"	m	class:httpd::file_handler
set_transformer	http/file_handler.hh	/^    file_interaction_handler* set_transformer(file_transformer* t) {$/;"	f	class:httpd::file_interaction_handler
transformer	http/file_handler.hh	/^    file_transformer* transformer;$/;"	m	class:httpd::file_interaction_handler
_f_handle	http/function_handlers.hh	/^                    std::unique_ptr<reply> rep)> _f_handle;$/;"	m	class:httpd::function_handler
_type	http/function_handlers.hh	/^    sstring _type;$/;"	m	class:httpd::function_handler
function_handler	http/function_handlers.hh	/^    function_handler(const future_json_function& _handle)$/;"	f	class:httpd::function_handler
function_handler	http/function_handlers.hh	/^    function_handler(const handle_function & f_handle, const sstring& type)$/;"	f	class:httpd::function_handler
function_handler	http/function_handlers.hh	/^    function_handler(const json_request_function& _handle)$/;"	f	class:httpd::function_handler
function_handler	http/function_handlers.hh	/^    function_handler(const request_function & _handle, const sstring& type)$/;"	f	class:httpd::function_handler
function_handler	http/function_handlers.hh	/^class function_handler : public handler_base {$/;"	c	namespace:httpd
future_json_function	http/function_handlers.hh	/^        future<json::json_return_type>(std::unique_ptr<request> req)> future_json_function;$/;"	t	namespace:httpd
handle_function	http/function_handlers.hh	/^typedef std::function<sstring(const_req req, reply&)> handle_function;$/;"	t	namespace:httpd
httpd	http/function_handlers.hh	/^namespace httpd {$/;"	n
json_request_function	http/function_handlers.hh	/^typedef std::function<json::json_return_type(const_req req)> json_request_function;$/;"	t	namespace:httpd
request_function	http/function_handlers.hh	/^typedef std::function<sstring(const_req req)> request_function;$/;"	t	namespace:httpd
HANDLERS_HH_	http/handlers.hh	23;"	d
_mandatory_param	http/handlers.hh	/^    std::vector<sstring> _mandatory_param;$/;"	m	class:httpd::handler_base
const_req	http/handlers.hh	/^typedef const httpd::request& const_req;$/;"	t	namespace:httpd
handler_base	http/handlers.hh	/^class handler_base {$/;"	c	namespace:httpd
httpd	http/handlers.hh	/^namespace httpd {$/;"	n
mandatory	http/handlers.hh	/^    handler_base& mandatory(const sstring& param) {$/;"	f	class:httpd::handler_base
http_stats	http/httpd.cc	/^http_stats::http_stats(http_server& server)$/;"	f	class:httpd::http_stats
httpd	http/httpd.cc	/^namespace httpd {$/;"	n	file:
APPS_HTTPD_HTTPD_HH_	http/httpd.hh	23;"	d
_all_connections_stopped	http/httpd.hh	/^    promise<> _all_connections_stopped;$/;"	m	class:httpd::http_server
_connections	http/httpd.hh	/^    boost::intrusive::list<connection> _connections;$/;"	m	class:httpd::http_server
_connections_being_accepted	http/httpd.hh	/^    uint64_t _connections_being_accepted = 0;$/;"	m	class:httpd::http_server
_current_connections	http/httpd.hh	/^    uint64_t _current_connections = 0;$/;"	m	class:httpd::http_server
_date	http/httpd.hh	/^    sstring _date = http_date();$/;"	m	class:httpd::http_server
_done	http/httpd.hh	/^        queue<std::unique_ptr<reply>> _replies { 10 };bool _done = false;$/;"	m	class:httpd::http_server::connection
_fd	http/httpd.hh	/^        connected_socket _fd;$/;"	m	class:httpd::http_server::connection
_listeners	http/httpd.hh	/^    std::vector<server_socket> _listeners;$/;"	m	class:httpd::http_server
_read_buf	http/httpd.hh	/^        input_stream<char> _read_buf;$/;"	m	class:httpd::http_server::connection
_regs	http/httpd.hh	/^    scollectd::registrations _regs;$/;"	m	class:httpd::http_stats
_req	http/httpd.hh	/^        std::unique_ptr<request> _req;$/;"	m	class:httpd::http_server::connection
_requests_served	http/httpd.hh	/^    uint64_t _requests_served = 0;$/;"	m	class:httpd::http_server
_resp	http/httpd.hh	/^        std::unique_ptr<reply> _resp;$/;"	m	class:httpd::http_server::connection
_routes	http/httpd.hh	/^    routes _routes;$/;"	m	class:httpd::http_server
_server	http/httpd.hh	/^        http_server& _server;$/;"	m	class:httpd::http_server::connection
_server_dist	http/httpd.hh	/^    distributed<http_server>* _server_dist;$/;"	m	class:httpd::http_server_control
_stopped	http/httpd.hh	/^    future<> _stopped = _all_connections_stopped.get_future();$/;"	m	class:httpd::http_server
_stopping	http/httpd.hh	/^    bool _stopping = false;$/;"	m	class:httpd::http_server
_total_connections	http/httpd.hh	/^    uint64_t _total_connections = 0;$/;"	m	class:httpd::http_server
_write_buf	http/httpd.hh	/^        output_stream<char> _write_buf;$/;"	m	class:httpd::http_server::connection
add_param	http/httpd.hh	/^        static void add_param(request& req, const std::experimental::string_view& param) {$/;"	f	class:httpd::http_server::connection
connection	http/httpd.hh	/^        connection(http_server& server, connected_socket&& fd,$/;"	f	class:httpd::http_server::connection
connection	http/httpd.hh	/^    class connection : public boost::intrusive::list_base_hook<> {$/;"	c	class:httpd::http_server
current_connections	http/httpd.hh	/^    uint64_t current_connections() const {$/;"	f	class:httpd::http_server
do_accepts	http/httpd.hh	/^    future<> do_accepts(int which) {$/;"	f	class:httpd::http_server
generate_reply	http/httpd.hh	/^        future<bool> generate_reply(std::unique_ptr<request> req) {$/;"	f	class:httpd::http_server::connection
hex_to_byte	http/httpd.hh	/^        static short hex_to_byte(char c) {$/;"	f	class:httpd::http_server::connection
hexstr_to_char	http/httpd.hh	/^        static char hexstr_to_char(const std::experimental::string_view& in, size_t from) {$/;"	f	class:httpd::http_server::connection
http_date	http/httpd.hh	/^    static sstring http_date() {$/;"	f	class:httpd::http_server
http_server	http/httpd.hh	/^    http_server() {$/;"	f	class:httpd::http_server
http_server	http/httpd.hh	/^class http_server {$/;"	c	namespace:httpd
http_server_control	http/httpd.hh	/^    http_server_control() : _server_dist(new distributed<http_server>) {$/;"	f	class:httpd::http_server_control
http_server_control	http/httpd.hh	/^class http_server_control {$/;"	c	namespace:httpd
http_stats	http/httpd.hh	/^class http_stats {$/;"	c	namespace:httpd
httpd	http/httpd.hh	/^namespace httpd {$/;"	n
limit	http/httpd.hh	/^        static constexpr size_t limit = 4096;$/;"	m	class:httpd::http_server::connection
listen	http/httpd.hh	/^    future<> listen(ipv4_addr addr) {$/;"	f	class:httpd::http_server
listen	http/httpd.hh	/^    future<> listen(uint16_t port) {$/;"	f	class:httpd::http_server_control
maybe_idle	http/httpd.hh	/^    void maybe_idle() {$/;"	f	class:httpd::http_server
process	http/httpd.hh	/^        future<> process() {$/;"	f	class:httpd::http_server::connection
read	http/httpd.hh	/^        future<> read() {$/;"	f	class:httpd::http_server::connection
read_one	http/httpd.hh	/^        future<> read_one() {$/;"	f	class:httpd::http_server::connection
requests_served	http/httpd.hh	/^    uint64_t requests_served() const {$/;"	f	class:httpd::http_server
respond	http/httpd.hh	/^        future<> respond() {$/;"	f	class:httpd::http_server::connection
server	http/httpd.hh	/^    distributed<http_server>& server() {$/;"	f	class:httpd::http_server_control
set_query_param	http/httpd.hh	/^        static sstring set_query_param(request& req) {$/;"	f	class:httpd::http_server::connection
set_routes	http/httpd.hh	/^    future<> set_routes(std::function<void(routes& r)> fun) {$/;"	f	class:httpd::http_server_control
shutdown	http/httpd.hh	/^        void shutdown() {$/;"	f	class:httpd::http_server::connection
start	http/httpd.hh	/^    future<> start() {$/;"	f	class:httpd::http_server_control
start_response	http/httpd.hh	/^        future<> start_response() {$/;"	f	class:httpd::http_server::connection
stop	http/httpd.hh	/^    future<> stop() {$/;"	f	class:httpd::http_server
stop	http/httpd.hh	/^    future<> stop() {$/;"	f	class:httpd::http_server_control
total_connections	http/httpd.hh	/^    uint64_t total_connections() const {$/;"	f	class:httpd::http_server
url_decode	http/httpd.hh	/^        static bool url_decode(const std::experimental::string_view& in, sstring& out) {$/;"	f	class:httpd::http_server::connection
write_body	http/httpd.hh	/^        future<> write_body() {$/;"	f	class:httpd::http_server::connection
write_reply_headers	http/httpd.hh	/^        future<> write_reply_headers($/;"	f	class:httpd::http_server::connection
~connection	http/httpd.hh	/^        ~connection() {$/;"	f	class:httpd::http_server::connection
httpd	http/json_path.cc	/^namespace httpd {$/;"	n	file:
path_description	http/json_path.cc	/^path_description::path_description(const sstring& path, operation_type method,$/;"	f	class:httpd::path_description
set	http/json_path.cc	/^void path_description::set(routes& _routes, const future_json_function& f) const {$/;"	f	class:httpd::path_description
set	http/json_path.cc	/^void path_description::set(routes& _routes, handler_base* handler) const {$/;"	f	class:httpd::path_description
set	http/json_path.cc	/^void path_description::set(routes& _routes,$/;"	f	class:httpd::path_description
JSON_PATH_HH_	http/json_path.hh	23;"	d
httpd	http/json_path.hh	/^namespace httpd {$/;"	n
json_operation	http/json_path.hh	/^    json_operation()$/;"	f	struct:httpd::json_operation
json_operation	http/json_path.hh	/^    json_operation(operation_type method, const sstring& nickname)$/;"	f	struct:httpd::json_operation
json_operation	http/json_path.hh	/^struct json_operation {$/;"	s	namespace:httpd
mandatory_queryparams	http/json_path.hh	/^    std::vector<sstring> mandatory_queryparams;$/;"	m	struct:httpd::path_description
method	http/json_path.hh	/^    operation_type method;$/;"	m	struct:httpd::json_operation
nickname	http/json_path.hh	/^    sstring nickname;$/;"	m	struct:httpd::json_operation
operations	http/json_path.hh	/^    json_operation operations;$/;"	m	struct:httpd::path_description
params	http/json_path.hh	/^    std::vector<std::pair<sstring, bool>> params;$/;"	m	struct:httpd::path_description
path	http/json_path.hh	/^    sstring path;$/;"	m	struct:httpd::path_description
path_description	http/json_path.hh	/^struct path_description {$/;"	s	namespace:httpd
pushmandatory_param	http/json_path.hh	/^    path_description* pushmandatory_param(const sstring& param) {$/;"	f	struct:httpd::path_description
pushparam	http/json_path.hh	/^    path_description* pushparam(const sstring& param,$/;"	f	struct:httpd::path_description
find_end_param	http/matcher.cc	/^static size_t find_end_param(const sstring& url, size_t ind, bool entire_path) {$/;"	f	namespace:httpd
httpd	http/matcher.cc	/^namespace httpd {$/;"	n	file:
match	http/matcher.cc	/^size_t param_matcher::match(const sstring& url, size_t ind, parameters& param) {$/;"	f	class:httpd::param_matcher
match	http/matcher.cc	/^size_t str_matcher::match(const sstring& url, size_t ind, parameters& param) {$/;"	f	class:httpd::str_matcher
MATCHER_HH_	http/matcher.hh	23;"	d
_cmp	http/matcher.hh	/^    sstring _cmp;$/;"	m	class:httpd::str_matcher
_entire_path	http/matcher.hh	/^    bool _entire_path;$/;"	m	class:httpd::param_matcher
_len	http/matcher.hh	/^    unsigned _len;$/;"	m	class:httpd::str_matcher
_name	http/matcher.hh	/^    sstring _name;$/;"	m	class:httpd::param_matcher
httpd	http/matcher.hh	/^namespace httpd {$/;"	n
matcher	http/matcher.hh	/^class matcher {$/;"	c	namespace:httpd
override	http/matcher.hh	/^            override;$/;"	m	class:httpd::param_matcher
override	http/matcher.hh	/^            override;$/;"	m	class:httpd::str_matcher
param_matcher	http/matcher.hh	/^    explicit param_matcher(const sstring& name, bool entire_path = false)$/;"	f	class:httpd::param_matcher
param_matcher	http/matcher.hh	/^class param_matcher : public matcher {$/;"	c	namespace:httpd
str_matcher	http/matcher.hh	/^    explicit str_matcher(const sstring& cmp)$/;"	f	class:httpd::str_matcher
str_matcher	http/matcher.hh	/^class str_matcher : public matcher {$/;"	c	namespace:httpd
MATCH_RULES_HH_	http/matchrules.hh	23;"	d
_handler	http/matchrules.hh	/^    handler_base* _handler;$/;"	m	class:httpd::match_rule
_match_list	http/matchrules.hh	/^    std::vector<matcher*> _match_list;$/;"	m	class:httpd::match_rule
add_matcher	http/matchrules.hh	/^    match_rule& add_matcher(matcher* match) {$/;"	f	class:httpd::match_rule
add_param	http/matchrules.hh	/^    match_rule& add_param(const sstring& str, bool fullpath = false) {$/;"	f	class:httpd::match_rule
add_str	http/matchrules.hh	/^    match_rule& add_str(const sstring& str) {$/;"	f	class:httpd::match_rule
get	http/matchrules.hh	/^    handler_base* get(const sstring& url, parameters& params) {$/;"	f	class:httpd::match_rule
httpd	http/matchrules.hh	/^namespace httpd {$/;"	n
match_rule	http/matchrules.hh	/^    explicit match_rule(handler_base* handler)$/;"	f	class:httpd::match_rule
match_rule	http/matchrules.hh	/^class match_rule {$/;"	c	namespace:httpd
~match_rule	http/matchrules.hh	/^    ~match_rule() {$/;"	f	class:httpd::match_rule
extension	http/mime_types.cc	/^    const char* extension;$/;"	m	struct:httpd::mime_types::mapping	file:
extension_to_type	http/mime_types.cc	/^const char* extension_to_type(const sstring& extension)$/;"	f	namespace:httpd::mime_types
httpd	http/mime_types.cc	/^namespace httpd {$/;"	n	file:
mapping	http/mime_types.cc	/^struct mapping {$/;"	s	namespace:httpd::mime_types	file:
mappings	http/mime_types.cc	/^} mappings[] = {$/;"	m	namespace:httpd::mime_types	typeref:struct:httpd::mime_types::mapping	file:
mime_type	http/mime_types.cc	/^    const char* mime_type;$/;"	m	struct:httpd::mime_types::mapping	file:
mime_types	http/mime_types.cc	/^namespace mime_types {$/;"	n	namespace:httpd	file:
HTTP_MIME_TYPES_HH	http/mime_types.hh	12;"	d
httpd	http/mime_types.hh	/^namespace httpd {$/;"	n
mime_types	http/mime_types.hh	/^namespace mime_types {$/;"	n	namespace:httpd
accepted	http/reply.cc	/^const sstring accepted = " 202 Accepted\\r\\n";$/;"	m	namespace:httpd::status_strings	file:
bad_gateway	http/reply.cc	/^const sstring bad_gateway = " 502 Bad Gateway\\r\\n";$/;"	m	namespace:httpd::status_strings	file:
bad_request	http/reply.cc	/^const sstring bad_request = " 400 Bad Request\\r\\n";$/;"	m	namespace:httpd::status_strings	file:
created	http/reply.cc	/^const sstring created = " 201 Created\\r\\n";$/;"	m	namespace:httpd::status_strings	file:
crlf	http/reply.cc	/^const char crlf[] = { '\\r', '\\n' };$/;"	m	namespace:httpd::misc_strings	file:
forbidden	http/reply.cc	/^const sstring forbidden = " 403 Forbidden\\r\\n";$/;"	m	namespace:httpd::status_strings	file:
httpd	http/reply.cc	/^namespace httpd {$/;"	n	file:
internal_server_error	http/reply.cc	/^const sstring internal_server_error = " 500 Internal Server Error\\r\\n";$/;"	m	namespace:httpd::status_strings	file:
misc_strings	http/reply.cc	/^namespace misc_strings {$/;"	n	namespace:httpd	file:
moved_permanently	http/reply.cc	/^const sstring moved_permanently = " 301 Moved Permanently\\r\\n";$/;"	m	namespace:httpd::status_strings	file:
moved_temporarily	http/reply.cc	/^const sstring moved_temporarily = " 302 Moved Temporarily\\r\\n";$/;"	m	namespace:httpd::status_strings	file:
multiple_choices	http/reply.cc	/^const sstring multiple_choices = " 300 Multiple Choices\\r\\n";$/;"	m	namespace:httpd::status_strings	file:
name_value_separator	http/reply.cc	/^const char name_value_separator[] = { ':', ' ' };$/;"	m	namespace:httpd::misc_strings	file:
no_content	http/reply.cc	/^const sstring no_content = " 204 No Content\\r\\n";$/;"	m	namespace:httpd::status_strings	file:
not_found	http/reply.cc	/^const sstring not_found = " 404 Not Found\\r\\n";$/;"	m	namespace:httpd::status_strings	file:
not_implemented	http/reply.cc	/^const sstring not_implemented = " 501 Not Implemented\\r\\n";$/;"	m	namespace:httpd::status_strings	file:
not_modified	http/reply.cc	/^const sstring not_modified = " 304 Not Modified\\r\\n";$/;"	m	namespace:httpd::status_strings	file:
ok	http/reply.cc	/^const sstring ok = " 200 OK\\r\\n";$/;"	m	namespace:httpd::status_strings	file:
response_line	http/reply.cc	/^sstring reply::response_line() {$/;"	f	class:httpd::reply
service_unavailable	http/reply.cc	/^const sstring service_unavailable = " 503 Service Unavailable\\r\\n";$/;"	m	namespace:httpd::status_strings	file:
status_strings	http/reply.cc	/^namespace status_strings {$/;"	n	namespace:httpd	file:
to_string	http/reply.cc	/^static const sstring& to_string(reply::status_type status) {$/;"	f	namespace:httpd::status_strings
unauthorized	http/reply.cc	/^const sstring unauthorized = " 401 Unauthorized\\r\\n";$/;"	m	namespace:httpd::status_strings	file:
_content	http/reply.hh	/^    sstring _content;$/;"	m	class:httpd::reply::status_type
_headers	http/reply.hh	/^    std::unordered_map<sstring, sstring> _headers;$/;"	m	class:httpd::reply::status_type
_response_line	http/reply.hh	/^    sstring _response_line;$/;"	m	class:httpd::reply::status_type
_version	http/reply.hh	/^    sstring _version;$/;"	m	class:httpd::reply::status_type
accepted	http/reply.hh	/^        accepted = 202, \/\/!< accepted$/;"	m	class:httpd::reply::status_type
add_header	http/reply.hh	/^    reply& add_header(const sstring& h, const sstring& value) {$/;"	f	class:httpd::reply::status_type
bad_gateway	http/reply.hh	/^        bad_gateway = 502, \/\/!< bad_gateway$/;"	m	class:httpd::reply::status_type
bad_request	http/reply.hh	/^        bad_request = 400, \/\/!< bad_request$/;"	m	class:httpd::reply::status_type
created	http/reply.hh	/^        created = 201, \/\/!< created$/;"	m	class:httpd::reply::status_type
done	http/reply.hh	/^    reply& done() {$/;"	f	class:httpd::reply::status_type
done	http/reply.hh	/^    reply& done(const sstring& content_type) {$/;"	f	class:httpd::reply::status_type
forbidden	http/reply.hh	/^        forbidden = 403, \/\/!< forbidden$/;"	m	class:httpd::reply::status_type
httpd	http/reply.hh	/^namespace httpd {$/;"	n
internal_server_error	http/reply.hh	/^        internal_server_error = 500, \/\/!< internal_server_error$/;"	m	class:httpd::reply::status_type
moved_permanently	http/reply.hh	/^        moved_permanently = 301, \/\/!< moved_permanently$/;"	m	class:httpd::reply::status_type
moved_temporarily	http/reply.hh	/^        moved_temporarily = 302, \/\/!< moved_temporarily$/;"	m	class:httpd::reply::status_type
multiple_choices	http/reply.hh	/^        multiple_choices = 300, \/\/!< multiple_choices$/;"	m	class:httpd::reply::status_type
no_content	http/reply.hh	/^        no_content = 204, \/\/!< no_content$/;"	m	class:httpd::reply::status_type
not_found	http/reply.hh	/^        not_found = 404, \/\/!< not_found$/;"	m	class:httpd::reply::status_type
not_implemented	http/reply.hh	/^        not_implemented = 501, \/\/!< not_implemented$/;"	m	class:httpd::reply::status_type
not_modified	http/reply.hh	/^        not_modified = 304, \/\/!< not_modified$/;"	m	class:httpd::reply::status_type
ok	http/reply.hh	/^        ok = 200, \/\/!< ok$/;"	m	class:httpd::reply::status_type
reply	http/reply.hh	/^    reply()$/;"	f	class:httpd::reply::status_type
reply	http/reply.hh	/^struct reply {$/;"	s	namespace:httpd
service_unavailable	http/reply.hh	/^        service_unavailable = 503  \/\/!< service_unavailable$/;"	m	class:httpd::reply::status_type
set_content_type	http/reply.hh	/^    reply& set_content_type(const sstring& content_type = "html") {$/;"	f	class:httpd::reply::status_type
set_mime_type	http/reply.hh	/^    reply& set_mime_type(const sstring& mime) {$/;"	f	class:httpd::reply::status_type
set_status	http/reply.hh	/^    reply& set_status(status_type status, const sstring& content = "") {$/;"	f	class:httpd::reply::status_type
set_version	http/reply.hh	/^    reply& set_version(const sstring& version) {$/;"	f	class:httpd::reply::status_type
status_type	http/reply.hh	/^    enum class status_type {$/;"	c	struct:httpd::reply
unauthorized	http/reply.hh	/^        unauthorized = 401, \/\/!< unauthorized$/;"	m	class:httpd::reply::status_type
HTTP_REQUEST_HPP	http/request.hh	32;"	d
_headers	http/request.hh	/^    std::unordered_map<sstring, sstring> _headers;$/;"	m	struct:httpd::request
_method	http/request.hh	/^    sstring _method;$/;"	m	struct:httpd::request
_url	http/request.hh	/^    sstring _url;$/;"	m	struct:httpd::request
_version	http/request.hh	/^    sstring _version;$/;"	m	struct:httpd::request
app_x_www_urlencoded	http/request.hh	/^            other, multipart, app_x_www_urlencoded,$/;"	m	class:httpd::request::ctclass
connection_ptr	http/request.hh	/^    connection* connection_ptr;$/;"	m	struct:httpd::request
content	http/request.hh	/^    sstring content;$/;"	m	struct:httpd::request
content_length	http/request.hh	/^    size_t content_length = 0;$/;"	m	struct:httpd::request
content_type_class	http/request.hh	/^    ctclass content_type_class;$/;"	m	struct:httpd::request
ctclass	http/request.hh	/^    enum class ctclass$/;"	c	struct:httpd::request
get_header	http/request.hh	/^    sstring get_header(const sstring& name) const {$/;"	f	struct:httpd::request
get_protocol_name	http/request.hh	/^    sstring get_protocol_name() const {$/;"	f	struct:httpd::request
get_query_param	http/request.hh	/^    sstring get_query_param(const sstring& name) const {$/;"	f	struct:httpd::request
get_url	http/request.hh	/^    sstring get_url() const {$/;"	f	struct:httpd::request
http_version_major	http/request.hh	/^    int http_version_major;$/;"	m	struct:httpd::request
http_version_minor	http/request.hh	/^    int http_version_minor;$/;"	m	struct:httpd::request
httpd	http/request.hh	/^namespace httpd {$/;"	n
is_form_post	http/request.hh	/^    bool is_form_post() const {$/;"	f	struct:httpd::request
is_multi_part	http/request.hh	/^    bool is_multi_part() const {$/;"	f	struct:httpd::request
multipart	http/request.hh	/^            other, multipart, app_x_www_urlencoded,$/;"	m	class:httpd::request::ctclass
other	http/request.hh	/^            other, multipart, app_x_www_urlencoded,$/;"	m	class:httpd::request::ctclass
param	http/request.hh	/^    parameters param;$/;"	m	struct:httpd::request
protocol_name	http/request.hh	/^    sstring protocol_name;$/;"	m	struct:httpd::request
query_parameters	http/request.hh	/^    std::unordered_map<sstring, sstring> query_parameters;$/;"	m	struct:httpd::request
request	http/request.hh	/^struct request {$/;"	s	namespace:httpd
add	http/routes.cc	/^routes& routes::add(operation_type type, const url& url,$/;"	f	class:httpd::routes
get_handler	http/routes.cc	/^handler_base* routes::get_handler(operation_type type, const sstring& url,$/;"	f	class:httpd::routes
handle	http/routes.cc	/^future<std::unique_ptr<reply> > routes::handle(const sstring& path, std::unique_ptr<request> req, std::unique_ptr<reply> rep) {$/;"	f	class:httpd::routes
httpd	http/routes.cc	/^namespace httpd {$/;"	n	file:
normalize_url	http/routes.cc	/^sstring routes::normalize_url(const sstring& url) {$/;"	f	class:httpd::routes
verify_param	http/routes.cc	/^void verify_param(const request& req, const sstring& param) {$/;"	f	namespace:httpd
~routes	http/routes.cc	/^routes::~routes() {$/;"	f	class:httpd::routes
ROUTES_HH_	http/routes.hh	23;"	d
_map	http/routes.hh	/^    std::unordered_map<sstring, handler_base*> _map[NUM_OPERATION];$/;"	m	class:httpd::routes
_param	http/routes.hh	/^    sstring _param;$/;"	m	class:httpd::url
_path	http/routes.hh	/^    sstring _path;$/;"	m	class:httpd::url
_rules	http/routes.hh	/^    std::vector<match_rule*> _rules[NUM_OPERATION];$/;"	m	class:httpd::routes
add	http/routes.hh	/^    routes& add(match_rule* rule, operation_type type = GET) {$/;"	f	class:httpd::routes
get_exact_match	http/routes.hh	/^    handler_base* get_exact_match(operation_type type, const sstring& url) {$/;"	f	class:httpd::routes
httpd	http/routes.hh	/^namespace httpd {$/;"	n
put	http/routes.hh	/^    routes& put(operation_type type, const sstring& url,$/;"	f	class:httpd::routes
remainder	http/routes.hh	/^    url& remainder(const sstring& param) {$/;"	f	class:httpd::url
routes	http/routes.hh	/^class routes {$/;"	c	namespace:httpd
url	http/routes.hh	/^    url(const sstring& path)$/;"	f	class:httpd::url
url	http/routes.hh	/^class url {$/;"	c	namespace:httpd
httpd	http/transformers.cc	/^namespace httpd {$/;"	n	file:
transform	http/transformers.cc	/^void content_replace::transform(sstring& content, const request& req,$/;"	f	class:httpd::content_replace
TRANSFORMERS_HH_	http/transformers.hh	23;"	d
content_replace	http/transformers.hh	/^    explicit content_replace(const sstring& extension = "")$/;"	f	class:httpd::content_replace
content_replace	http/transformers.hh	/^class content_replace : public file_transformer {$/;"	c	namespace:httpd
extension	http/transformers.hh	/^    sstring extension;$/;"	m	class:httpd::content_replace
httpd	http/transformers.hh	/^namespace httpd {$/;"	n
override	http/transformers.hh	/^            const sstring& extension) override;$/;"	m	class:httpd::content_replace
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
Action	json/argparse.py	/^class Action(_AttributeHolder):$/;"	c
ArgumentDefaultsHelpFormatter	json/argparse.py	/^class ArgumentDefaultsHelpFormatter(HelpFormatter):$/;"	c
ArgumentError	json/argparse.py	/^class ArgumentError(Exception):$/;"	c
ArgumentParser	json/argparse.py	/^class ArgumentParser(_AttributeHolder, _ActionsContainer):$/;"	c
ArgumentTypeError	json/argparse.py	/^class ArgumentTypeError(Exception):$/;"	c
FileType	json/argparse.py	/^class FileType(object):$/;"	c
HelpFormatter	json/argparse.py	/^class HelpFormatter(object):$/;"	c
MetavarTypeHelpFormatter	json/argparse.py	/^class MetavarTypeHelpFormatter(HelpFormatter):$/;"	c
Namespace	json/argparse.py	/^class Namespace(_AttributeHolder):$/;"	c
ONE_OR_MORE	json/argparse.py	/^ONE_OR_MORE = '+'$/;"	v
OPTIONAL	json/argparse.py	/^OPTIONAL = '?'$/;"	v
PARSER	json/argparse.py	/^PARSER = 'A...'$/;"	v
REMAINDER	json/argparse.py	/^REMAINDER = '...'$/;"	v
RawDescriptionHelpFormatter	json/argparse.py	/^class RawDescriptionHelpFormatter(HelpFormatter):$/;"	c
RawTextHelpFormatter	json/argparse.py	/^class RawTextHelpFormatter(RawDescriptionHelpFormatter):$/;"	c
ZERO_OR_MORE	json/argparse.py	/^ZERO_OR_MORE = '*'$/;"	v
_ActionsContainer	json/argparse.py	/^class _ActionsContainer(object):$/;"	c
_AppendAction	json/argparse.py	/^class _AppendAction(Action):$/;"	c
_AppendConstAction	json/argparse.py	/^class _AppendConstAction(Action):$/;"	c
_ArgumentGroup	json/argparse.py	/^class _ArgumentGroup(_ActionsContainer):$/;"	c
_AttributeHolder	json/argparse.py	/^class _AttributeHolder(object):$/;"	c
_ChoicesPseudoAction	json/argparse.py	/^    class _ChoicesPseudoAction(Action):$/;"	c	class:_SubParsersAction
_CountAction	json/argparse.py	/^class _CountAction(Action):$/;"	c
_HelpAction	json/argparse.py	/^class _HelpAction(Action):$/;"	c
_MutuallyExclusiveGroup	json/argparse.py	/^class _MutuallyExclusiveGroup(_ArgumentGroup):$/;"	c
_Section	json/argparse.py	/^    class _Section(object):$/;"	c	class:HelpFormatter
_StoreAction	json/argparse.py	/^class _StoreAction(Action):$/;"	c
_StoreConstAction	json/argparse.py	/^class _StoreConstAction(Action):$/;"	c
_StoreFalseAction	json/argparse.py	/^class _StoreFalseAction(_StoreConstAction):$/;"	c
_StoreTrueAction	json/argparse.py	/^class _StoreTrueAction(_StoreConstAction):$/;"	c
_SubParsersAction	json/argparse.py	/^class _SubParsersAction(Action):$/;"	c
_UNRECOGNIZED_ARGS_ATTR	json/argparse.py	/^_UNRECOGNIZED_ARGS_ATTR = '_unrecognized_args'$/;"	v
_VersionAction	json/argparse.py	/^class _VersionAction(Action):$/;"	c
__all__	json/argparse.py	/^__all__ = [$/;"	v
__call__	json/argparse.py	/^    def __call__(self, parser, namespace, values, option_string=None):$/;"	m	class:Action	file:
__call__	json/argparse.py	/^    def __call__(self, parser, namespace, values, option_string=None):$/;"	m	class:_AppendAction	file:
__call__	json/argparse.py	/^    def __call__(self, parser, namespace, values, option_string=None):$/;"	m	class:_AppendConstAction	file:
__call__	json/argparse.py	/^    def __call__(self, parser, namespace, values, option_string=None):$/;"	m	class:_CountAction	file:
__call__	json/argparse.py	/^    def __call__(self, parser, namespace, values, option_string=None):$/;"	m	class:_HelpAction	file:
__call__	json/argparse.py	/^    def __call__(self, parser, namespace, values, option_string=None):$/;"	m	class:_StoreAction	file:
__call__	json/argparse.py	/^    def __call__(self, parser, namespace, values, option_string=None):$/;"	m	class:_StoreConstAction	file:
__call__	json/argparse.py	/^    def __call__(self, parser, namespace, values, option_string=None):$/;"	m	class:_SubParsersAction	file:
__call__	json/argparse.py	/^    def __call__(self, parser, namespace, values, option_string=None):$/;"	m	class:_VersionAction	file:
__call__	json/argparse.py	/^    def __call__(self, string):$/;"	m	class:FileType	file:
__contains__	json/argparse.py	/^    def __contains__(self, key):$/;"	m	class:Namespace	file:
__eq__	json/argparse.py	/^    def __eq__(self, other):$/;"	m	class:Namespace	file:
__init__	json/argparse.py	/^        def __init__(self, formatter, parent, heading=None):$/;"	m	class:HelpFormatter._Section
__init__	json/argparse.py	/^        def __init__(self, name, aliases, help):$/;"	m	class:_SubParsersAction._ChoicesPseudoAction
__init__	json/argparse.py	/^    def __init__(self, **kwargs):$/;"	m	class:Namespace
__init__	json/argparse.py	/^    def __init__(self, argument, message):$/;"	m	class:ArgumentError
__init__	json/argparse.py	/^    def __init__(self, container, required=False):$/;"	m	class:_MutuallyExclusiveGroup
__init__	json/argparse.py	/^    def __init__(self, container, title=None, description=None, **kwargs):$/;"	m	class:_ArgumentGroup
__init__	json/argparse.py	/^    def __init__(self, mode='r', bufsize=-1):$/;"	m	class:FileType
__init__	json/argparse.py	/^    def __init__(self,$/;"	m	class:Action
__init__	json/argparse.py	/^    def __init__(self,$/;"	m	class:ArgumentParser
__init__	json/argparse.py	/^    def __init__(self,$/;"	m	class:HelpFormatter
__init__	json/argparse.py	/^    def __init__(self,$/;"	m	class:_ActionsContainer
__init__	json/argparse.py	/^    def __init__(self,$/;"	m	class:_AppendAction
__init__	json/argparse.py	/^    def __init__(self,$/;"	m	class:_AppendConstAction
__init__	json/argparse.py	/^    def __init__(self,$/;"	m	class:_CountAction
__init__	json/argparse.py	/^    def __init__(self,$/;"	m	class:_HelpAction
__init__	json/argparse.py	/^    def __init__(self,$/;"	m	class:_StoreAction
__init__	json/argparse.py	/^    def __init__(self,$/;"	m	class:_StoreConstAction
__init__	json/argparse.py	/^    def __init__(self,$/;"	m	class:_StoreFalseAction
__init__	json/argparse.py	/^    def __init__(self,$/;"	m	class:_StoreTrueAction
__init__	json/argparse.py	/^    def __init__(self,$/;"	m	class:_SubParsersAction
__init__	json/argparse.py	/^    def __init__(self,$/;"	m	class:_VersionAction
__ne__	json/argparse.py	/^    def __ne__(self, other):$/;"	m	class:Namespace	file:
__repr__	json/argparse.py	/^    def __repr__(self):$/;"	m	class:FileType	file:
__repr__	json/argparse.py	/^    def __repr__(self):$/;"	m	class:_AttributeHolder	file:
__str__	json/argparse.py	/^    def __str__(self):$/;"	m	class:ArgumentError	file:
__version__	json/argparse.py	/^__version__ = '1.1'$/;"	v
_add_action	json/argparse.py	/^    def _add_action(self, action):$/;"	m	class:ArgumentParser
_add_action	json/argparse.py	/^    def _add_action(self, action):$/;"	m	class:_ActionsContainer
_add_action	json/argparse.py	/^    def _add_action(self, action):$/;"	m	class:_ArgumentGroup
_add_action	json/argparse.py	/^    def _add_action(self, action):$/;"	m	class:_MutuallyExclusiveGroup
_add_container_actions	json/argparse.py	/^    def _add_container_actions(self, container):$/;"	m	class:_ActionsContainer
_add_item	json/argparse.py	/^    def _add_item(self, func, args):$/;"	m	class:HelpFormatter
_check_conflict	json/argparse.py	/^    def _check_conflict(self, action):$/;"	m	class:_ActionsContainer
_check_value	json/argparse.py	/^    def _check_value(self, action, value):$/;"	m	class:ArgumentParser
_dedent	json/argparse.py	/^    def _dedent(self):$/;"	m	class:HelpFormatter
_ensure_value	json/argparse.py	/^def _ensure_value(namespace, name, value):$/;"	f
_expand_help	json/argparse.py	/^    def _expand_help(self, action):$/;"	m	class:HelpFormatter
_fill_text	json/argparse.py	/^    def _fill_text(self, text, width, indent):$/;"	m	class:HelpFormatter
_fill_text	json/argparse.py	/^    def _fill_text(self, text, width, indent):$/;"	m	class:RawDescriptionHelpFormatter
_format_action	json/argparse.py	/^    def _format_action(self, action):$/;"	m	class:HelpFormatter
_format_action_invocation	json/argparse.py	/^    def _format_action_invocation(self, action):$/;"	m	class:HelpFormatter
_format_actions_usage	json/argparse.py	/^    def _format_actions_usage(self, actions, groups):$/;"	m	class:HelpFormatter
_format_args	json/argparse.py	/^    def _format_args(self, action, default_metavar):$/;"	m	class:HelpFormatter
_format_text	json/argparse.py	/^    def _format_text(self, text):$/;"	m	class:HelpFormatter
_format_usage	json/argparse.py	/^    def _format_usage(self, usage, actions, groups, prefix):$/;"	m	class:HelpFormatter
_get_action_name	json/argparse.py	/^def _get_action_name(argument):$/;"	f
_get_args	json/argparse.py	/^    def _get_args(self):$/;"	m	class:_AttributeHolder
_get_default_metavar_for_optional	json/argparse.py	/^    def _get_default_metavar_for_optional(self, action):$/;"	m	class:HelpFormatter
_get_default_metavar_for_optional	json/argparse.py	/^    def _get_default_metavar_for_optional(self, action):$/;"	m	class:MetavarTypeHelpFormatter
_get_default_metavar_for_positional	json/argparse.py	/^    def _get_default_metavar_for_positional(self, action):$/;"	m	class:HelpFormatter
_get_default_metavar_for_positional	json/argparse.py	/^    def _get_default_metavar_for_positional(self, action):$/;"	m	class:MetavarTypeHelpFormatter
_get_formatter	json/argparse.py	/^    def _get_formatter(self):$/;"	m	class:ArgumentParser
_get_handler	json/argparse.py	/^    def _get_handler(self):$/;"	m	class:_ActionsContainer
_get_help_string	json/argparse.py	/^    def _get_help_string(self, action):$/;"	m	class:ArgumentDefaultsHelpFormatter
_get_help_string	json/argparse.py	/^    def _get_help_string(self, action):$/;"	m	class:HelpFormatter
_get_kwargs	json/argparse.py	/^    def _get_kwargs(self):$/;"	m	class:Action
_get_kwargs	json/argparse.py	/^    def _get_kwargs(self):$/;"	m	class:ArgumentParser
_get_kwargs	json/argparse.py	/^    def _get_kwargs(self):$/;"	m	class:_AttributeHolder
_get_nargs_pattern	json/argparse.py	/^    def _get_nargs_pattern(self, action):$/;"	m	class:ArgumentParser
_get_option_tuples	json/argparse.py	/^    def _get_option_tuples(self, option_string):$/;"	m	class:ArgumentParser
_get_optional_actions	json/argparse.py	/^    def _get_optional_actions(self):$/;"	m	class:ArgumentParser
_get_optional_kwargs	json/argparse.py	/^    def _get_optional_kwargs(self, *args, **kwargs):$/;"	m	class:_ActionsContainer
_get_positional_actions	json/argparse.py	/^    def _get_positional_actions(self):$/;"	m	class:ArgumentParser
_get_positional_kwargs	json/argparse.py	/^    def _get_positional_kwargs(self, dest, **kwargs):$/;"	m	class:_ActionsContainer
_get_subactions	json/argparse.py	/^    def _get_subactions(self):$/;"	m	class:_SubParsersAction
_get_value	json/argparse.py	/^    def _get_value(self, action, arg_string):$/;"	m	class:ArgumentParser
_get_values	json/argparse.py	/^    def _get_values(self, action, arg_strings):$/;"	m	class:ArgumentParser
_handle_conflict_error	json/argparse.py	/^    def _handle_conflict_error(self, action, conflicting_actions):$/;"	m	class:_ActionsContainer
_handle_conflict_resolve	json/argparse.py	/^    def _handle_conflict_resolve(self, action, conflicting_actions):$/;"	m	class:_ActionsContainer
_indent	json/argparse.py	/^    def _indent(self):$/;"	m	class:HelpFormatter
_iter_indented_subactions	json/argparse.py	/^    def _iter_indented_subactions(self, action):$/;"	m	class:HelpFormatter
_join_parts	json/argparse.py	/^    def _join_parts(self, part_strings):$/;"	m	class:HelpFormatter
_match_argument	json/argparse.py	/^    def _match_argument(self, action, arg_strings_pattern):$/;"	m	class:ArgumentParser
_match_arguments_partial	json/argparse.py	/^    def _match_arguments_partial(self, actions, arg_strings_pattern):$/;"	m	class:ArgumentParser
_metavar_formatter	json/argparse.py	/^    def _metavar_formatter(self, action, default_metavar):$/;"	m	class:HelpFormatter
_parse_known_args	json/argparse.py	/^    def _parse_known_args(self, arg_strings, namespace):$/;"	m	class:ArgumentParser
_parse_optional	json/argparse.py	/^    def _parse_optional(self, arg_string):$/;"	m	class:ArgumentParser
_pop_action_class	json/argparse.py	/^    def _pop_action_class(self, kwargs, default=None):$/;"	m	class:_ActionsContainer
_print_message	json/argparse.py	/^    def _print_message(self, message, file=None):$/;"	m	class:ArgumentParser
_read_args_from_files	json/argparse.py	/^    def _read_args_from_files(self, arg_strings):$/;"	m	class:ArgumentParser
_registry_get	json/argparse.py	/^    def _registry_get(self, registry_name, value, default=None):$/;"	m	class:_ActionsContainer
_remove_action	json/argparse.py	/^    def _remove_action(self, action):$/;"	m	class:_ActionsContainer
_remove_action	json/argparse.py	/^    def _remove_action(self, action):$/;"	m	class:_ArgumentGroup
_remove_action	json/argparse.py	/^    def _remove_action(self, action):$/;"	m	class:_MutuallyExclusiveGroup
_split_lines	json/argparse.py	/^    def _split_lines(self, text, width):$/;"	m	class:HelpFormatter
_split_lines	json/argparse.py	/^    def _split_lines(self, text, width):$/;"	m	class:RawTextHelpFormatter
add_argument	json/argparse.py	/^    def add_argument(self, *args, **kwargs):$/;"	m	class:_ActionsContainer
add_argument	json/argparse.py	/^    def add_argument(self, action):$/;"	m	class:HelpFormatter
add_argument_group	json/argparse.py	/^    def add_argument_group(self, *args, **kwargs):$/;"	m	class:_ActionsContainer
add_arguments	json/argparse.py	/^    def add_arguments(self, actions):$/;"	m	class:HelpFormatter
add_mutually_exclusive_group	json/argparse.py	/^    def add_mutually_exclusive_group(self, **kwargs):$/;"	m	class:_ActionsContainer
add_parser	json/argparse.py	/^    def add_parser(self, name, **kwargs):$/;"	m	class:_SubParsersAction
add_subparsers	json/argparse.py	/^    def add_subparsers(self, **kwargs):$/;"	m	class:ArgumentParser
add_text	json/argparse.py	/^    def add_text(self, text):$/;"	m	class:HelpFormatter
add_usage	json/argparse.py	/^    def add_usage(self, usage, actions, groups, prefix=None):$/;"	m	class:HelpFormatter
consume_optional	json/argparse.py	/^        def consume_optional(start_index):$/;"	f	function:ArgumentParser._parse_known_args
consume_positionals	json/argparse.py	/^        def consume_positionals(start_index):$/;"	f	function:ArgumentParser._parse_known_args
convert_arg_line_to_args	json/argparse.py	/^    def convert_arg_line_to_args(self, arg_line):$/;"	m	class:ArgumentParser
end_section	json/argparse.py	/^    def end_section(self):$/;"	m	class:HelpFormatter
error	json/argparse.py	/^    def error(self, message):$/;"	m	class:ArgumentParser
exit	json/argparse.py	/^    def exit(self, status=0, message=None):$/;"	m	class:ArgumentParser
format	json/argparse.py	/^        def format(tuple_size):$/;"	f	function:HelpFormatter._metavar_formatter
format_help	json/argparse.py	/^        def format_help(self):$/;"	m	class:HelpFormatter._Section
format_help	json/argparse.py	/^    def format_help(self):$/;"	m	class:ArgumentParser
format_help	json/argparse.py	/^    def format_help(self):$/;"	m	class:HelpFormatter
format_usage	json/argparse.py	/^    def format_usage(self):$/;"	m	class:ArgumentParser
format_version	json/argparse.py	/^    def format_version(self):$/;"	m	class:ArgumentParser
get_default	json/argparse.py	/^    def get_default(self, dest):$/;"	m	class:_ActionsContainer
get_lines	json/argparse.py	/^                def get_lines(parts, indent, prefix=None):$/;"	f	function:HelpFormatter._format_usage
identity	json/argparse.py	/^        def identity(string):$/;"	f	function:ArgumentParser.__init__
parse_args	json/argparse.py	/^    def parse_args(self, args=None, namespace=None):$/;"	m	class:ArgumentParser
parse_known_args	json/argparse.py	/^    def parse_known_args(self, args=None, namespace=None):$/;"	m	class:ArgumentParser
print_help	json/argparse.py	/^    def print_help(self, file=None):$/;"	m	class:ArgumentParser
print_usage	json/argparse.py	/^    def print_usage(self, file=None):$/;"	m	class:ArgumentParser
print_version	json/argparse.py	/^    def print_version(self, file=None):$/;"	m	class:ArgumentParser
register	json/argparse.py	/^    def register(self, registry_name, value, object):$/;"	m	class:_ActionsContainer
set_defaults	json/argparse.py	/^    def set_defaults(self, **kwargs):$/;"	m	class:_ActionsContainer
start_section	json/argparse.py	/^    def start_section(self, heading):$/;"	m	class:HelpFormatter
take_action	json/argparse.py	/^        def take_action(action, argument_strings, option_string=None):$/;"	f	function:ArgumentParser._parse_known_args
json	json/formatter.cc	/^namespace json {$/;"	n	file:
to_json	json/formatter.cc	/^sstring formatter::to_json(bool b) {$/;"	f	class:json::formatter
to_json	json/formatter.cc	/^sstring formatter::to_json(const char* str) {$/;"	f	class:json::formatter
to_json	json/formatter.cc	/^sstring formatter::to_json(const date_time& d) {$/;"	f	class:json::formatter
to_json	json/formatter.cc	/^sstring formatter::to_json(const jsonable& obj) {$/;"	f	class:json::formatter
to_json	json/formatter.cc	/^sstring formatter::to_json(const sstring& str) {$/;"	f	class:json::formatter
to_json	json/formatter.cc	/^sstring formatter::to_json(double d) {$/;"	f	class:json::formatter
to_json	json/formatter.cc	/^sstring formatter::to_json(float f) {$/;"	f	class:json::formatter
to_json	json/formatter.cc	/^sstring formatter::to_json(int n) {$/;"	f	class:json::formatter
to_json	json/formatter.cc	/^sstring formatter::to_json(long n) {$/;"	f	class:json::formatter
to_json	json/formatter.cc	/^sstring formatter::to_json(unsigned long l) {$/;"	f	class:json::formatter
FORMATTER_HH_	json/formatter.hh	23;"	d
TIME_FORMAT	json/formatter.hh	/^    static constexpr const char* TIME_FORMAT = "%a %b %d %I:%M:%S %Z %Y";$/;"	m	class:json::formatter
date_time	json/formatter.hh	/^typedef struct tm date_time;$/;"	t	namespace:json	typeref:struct:json::tm
formatter	json/formatter.hh	/^class formatter {$/;"	c	namespace:json
json	json/formatter.hh	/^namespace json {$/;"	n
to_json	json/formatter.hh	/^    static sstring to_json(const std::vector<T>& vec) {$/;"	f	class:json::formatter
add_include	json/json2code.py	/^def add_include(f, includes):$/;"	f
add_path	json/json2code.py	/^def add_path(f, path, details):$/;"	f
clean_param	json/json2code.py	/^def clean_param(param):$/;"	f
clear_path_ending	json/json2code.py	/^def clear_path_ending(path):$/;"	f
close_namespace	json/json2code.py	/^def close_namespace(f):$/;"	f
combined	json/json2code.py	/^    combined = open(config.combined, "w")$/;"	v
config	json/json2code.py	/^config = parser.parse_args()$/;"	v
create_h_file	json/json2code.py	/^def create_h_file(data, hfile_name, api_name, init_method, base_api):$/;"	f
current_file	json/json2code.py	/^current_file = ''$/;"	v
default	json/json2code.py	/^                    default='autogen\/pathautogen.ee')$/;"	v
default	json/json2code.py	/^                    default='json\/')$/;"	v
fprint	json/json2code.py	/^def fprint(f, *args):$/;"	f
fprintln	json/json2code.py	/^def fprintln(f, *args):$/;"	f
get_base_name	json/json2code.py	/^def get_base_name(param):$/;"	f
get_parameter_by_name	json/json2code.py	/^def get_parameter_by_name(obj, name):$/;"	f
getitem	json/json2code.py	/^def getitem(d, key, name):$/;"	f
is_model_valid	json/json2code.py	/^def is_model_valid(name, model):$/;"	f
open_namespace	json/json2code.py	/^def open_namespace(f, ns=config.ns):$/;"	f
parse_file	json/json2code.py	/^def parse_file(param, combined):$/;"	f
print_comment	json/json2code.py	/^def print_comment(f, *params):$/;"	f
print_copyrights	json/json2code.py	/^def print_copyrights(f):$/;"	f
print_h_file_headers	json/json2code.py	/^def print_h_file_headers(f, name):$/;"	f
print_ind_comment	json/json2code.py	/^def print_ind_comment(f, ind, *params):$/;"	f
resolve_model_order	json/json2code.py	/^def resolve_model_order(data):$/;"	f
spacing	json/json2code.py	/^spacing = "    "$/;"	v
trace_err	json/json2code.py	/^def trace_err(*params):$/;"	f
trace_verbose	json/json2code.py	/^def trace_verbose(*params):$/;"	f
type_change	json/json2code.py	/^def type_change(param, member):$/;"	f
valid_type	json/json2code.py	/^def valid_type(param):$/;"	f
valid_vars	json/json2code.py	/^valid_vars = {'string': 'sstring', 'int': 'int', 'double': 'double',$/;"	v
CLOSE	json/json_elements.cc	/^    static const string CLOSE;$/;"	m	class:json::json_builder	file:
OPEN	json/json_elements.cc	/^    static const string OPEN;$/;"	m	class:json::json_builder	file:
add	json/json_elements.cc	/^    void add(const string& name, const string& str) {$/;"	f	class:json::json_builder
add	json/json_elements.cc	/^    void add(json_base_element* element) {$/;"	f	class:json::json_builder
add	json/json_elements.cc	/^void json_base::add(json_base_element* element, string name, bool mandatory) {$/;"	f	class:json::json_base
as_json	json/json_elements.cc	/^    string as_json() {$/;"	f	class:json::json_builder
first	json/json_elements.cc	/^    bool first;$/;"	m	class:json::json_builder	file:
is_verify	json/json_elements.cc	/^bool json_base::is_verify() const {$/;"	f	class:json::json_base
json	json/json_elements.cc	/^namespace json {$/;"	n	file:
json_builder	json/json_elements.cc	/^    json_builder()$/;"	f	class:json::json_builder
json_builder	json/json_elements.cc	/^class json_builder {$/;"	c	namespace:json	file:
result	json/json_elements.cc	/^    stringstream result;$/;"	m	class:json::json_builder	file:
to_json	json/json_elements.cc	/^string json_base::to_json() const {$/;"	f	class:json::json_base
JSON_ELEMENTS_HH_	json/json_elements.hh	23;"	d
_elements	json/json_elements.hh	/^    std::vector<T> _elements;$/;"	m	class:json::json_list
_elements	json/json_elements.hh	/^    std::vector<json_base_element*> _elements;$/;"	m	struct:json::json_base
_mandatory	json/json_elements.hh	/^    bool _mandatory;$/;"	m	class:json::json_base_element
_name	json/json_elements.hh	/^    std::string _name;$/;"	m	class:json::json_base_element
_res	json/json_elements.hh	/^    sstring _res;$/;"	m	struct:json::json_return_type
_set	json/json_elements.hh	/^    bool _set;$/;"	m	class:json::json_base_element
_value	json/json_elements.hh	/^    T _value;$/;"	m	class:json::json_element
is_verify	json/json_elements.hh	/^    virtual bool is_verify() {$/;"	f	class:json::json_base_element
json	json/json_elements.hh	/^namespace json {$/;"	n
json_base	json/json_elements.hh	/^struct json_base : public jsonable {$/;"	s	namespace:json
json_base_element	json/json_elements.hh	/^    json_base_element()$/;"	f	class:json::json_base_element
json_base_element	json/json_elements.hh	/^class json_base_element {$/;"	c	namespace:json
json_element	json/json_elements.hh	/^class json_element : public json_base_element {$/;"	c	namespace:json
json_list	json/json_elements.hh	/^class json_list : public json_base_element {$/;"	c	namespace:json
json_return_type	json/json_elements.hh	/^    json_return_type(const T& res) {$/;"	f	struct:json::json_return_type
json_return_type	json/json_elements.hh	/^struct json_return_type {$/;"	s	namespace:json
jsonable	json/json_elements.hh	/^class jsonable {$/;"	c	namespace:json
operator ()	json/json_elements.hh	/^    const T& operator()() const {$/;"	f	class:json::json_element
operator =	json/json_elements.hh	/^    json_element &operator=(const C& new_value) {$/;"	f	class:json::json_element
operator =	json/json_elements.hh	/^    json_element &operator=(const T& new_value) {$/;"	f	class:json::json_element
push	json/json_elements.hh	/^    void push(const T& element) {$/;"	f	class:json::json_list
NET_API_HH_	net/api.hh	23;"	d
_impl	net/api.hh	/^    std::unique_ptr<udp_channel_impl> _impl;$/;"	m	class:net::udp_channel
_impl	net/api.hh	/^    std::unique_ptr<udp_datagram_impl> _impl;$/;"	m	class:net::final
as_posix_sockaddr	net/api.hh	/^    ::sockaddr& as_posix_sockaddr() { return u.sa; }$/;"	f	class:socket_address
as_posix_sockaddr	net/api.hh	/^    const ::sockaddr& as_posix_sockaddr() const { return u.sa; }$/;"	f	class:socket_address
as_posix_sockaddr_in	net/api.hh	/^    ::sockaddr_in& as_posix_sockaddr_in() { return u.in; }$/;"	f	class:socket_address
as_posix_sockaddr_in	net/api.hh	/^    const ::sockaddr_in& as_posix_sockaddr_in() const { return u.in; }$/;"	f	class:socket_address
close	net/api.hh	/^    void close() { return _impl->close(); }$/;"	f	class:net::udp_channel
final	net/api.hh	/^class udp_datagram final {$/;"	c	namespace:net
get_data	net/api.hh	/^    packet& get_data() { return _impl->get_data(); }$/;"	f	class:net::final
get_dst	net/api.hh	/^    ipv4_addr get_dst() { return _impl->get_dst(); }$/;"	f	class:net::final
get_dst_port	net/api.hh	/^    uint16_t get_dst_port() { return _impl->get_dst_port(); }$/;"	f	class:net::final
get_src	net/api.hh	/^    ipv4_addr get_src() { return _impl->get_src(); }$/;"	f	class:net::final
in	net/api.hh	/^        ::sockaddr_in in;$/;"	m	union:socket_address::__anon5
ip	net/api.hh	/^    uint32_t ip;$/;"	m	struct:ipv4_addr
ipv4_addr	net/api.hh	/^    ipv4_addr() : ip(0), port(0) {}$/;"	f	struct:ipv4_addr
ipv4_addr	net/api.hh	/^    ipv4_addr(const socket_address &sa) {$/;"	f	struct:ipv4_addr
ipv4_addr	net/api.hh	/^    ipv4_addr(socket_address &&sa) : ipv4_addr(sa) {}$/;"	f	struct:ipv4_addr
ipv4_addr	net/api.hh	/^    ipv4_addr(uint16_t port) : ip(0), port(port) {}$/;"	f	struct:ipv4_addr
ipv4_addr	net/api.hh	/^    ipv4_addr(uint32_t ip, uint16_t port) : ip(ip), port(port) {}$/;"	f	struct:ipv4_addr
ipv4_addr	net/api.hh	/^struct ipv4_addr {$/;"	s
is_closed	net/api.hh	/^    bool is_closed() const { return _impl->is_closed(); }$/;"	f	class:net::udp_channel
is_ip_unspecified	net/api.hh	/^bool is_ip_unspecified(ipv4_addr &addr) {$/;"	f
is_port_unspecified	net/api.hh	/^bool is_port_unspecified(ipv4_addr &addr) {$/;"	f
kj_receive	net/api.hh	/^    kj::Promise<udp_datagram> kj_receive() { return _impl->kj_receive(); }$/;"	f	class:net::udp_channel
kj_send	net/api.hh	/^    kj::Promise<void> kj_send(ipv4_addr dst, const char* msg) { return _impl->kj_send(std::move(dst), msg); }$/;"	f	class:net::udp_channel
kj_send	net/api.hh	/^    kj::Promise<void> kj_send(ipv4_addr dst, packet p) { return _impl->kj_send(std::move(dst), std::move(p)); }$/;"	f	class:net::udp_channel
listen_options	net/api.hh	/^struct listen_options {$/;"	s
make_ipv4_address	net/api.hh	/^socket_address make_ipv4_address(ipv4_addr addr) {$/;"	f
net	net/api.hh	/^namespace net {$/;"	n
operator <<	net/api.hh	/^std::ostream& operator<<(std::ostream &os, ipv4_addr addr) {$/;"	f
port	net/api.hh	/^    uint16_t port;$/;"	m	struct:ipv4_addr
receive	net/api.hh	/^    future<udp_datagram> receive() { return _impl->receive(); }$/;"	f	class:net::udp_channel
reuse_address	net/api.hh	/^    bool reuse_address = false;$/;"	m	struct:listen_options
sa	net/api.hh	/^        ::sockaddr sa;$/;"	m	union:socket_address::__anon5
sas	net/api.hh	/^        ::sockaddr_storage sas;$/;"	m	union:socket_address::__anon5
send	net/api.hh	/^    future<> send(ipv4_addr dst, const char* msg) { return _impl->send(std::move(dst), msg); }$/;"	f	class:net::udp_channel
send	net/api.hh	/^    future<> send(ipv4_addr dst, packet p) { return _impl->send(std::move(dst), std::move(p)); }$/;"	f	class:net::udp_channel
socket_address	net/api.hh	/^    socket_address(sockaddr_in sa) {$/;"	f	class:socket_address
socket_address	net/api.hh	/^class socket_address {$/;"	c
u	net/api.hh	/^    } u;$/;"	m	class:socket_address	typeref:union:socket_address::__anon5
udp_channel	net/api.hh	/^    udp_channel() {}$/;"	f	class:net::udp_channel
udp_channel	net/api.hh	/^    udp_channel(std::unique_ptr<udp_channel_impl> impl) : _impl(std::move(impl)) {}$/;"	f	class:net::udp_channel
udp_channel	net/api.hh	/^class udp_channel {$/;"	c	namespace:net
udp_channel_impl	net/api.hh	/^class udp_channel_impl {$/;"	c	namespace:net
udp_datagram	net/api.hh	/^    udp_datagram(std::unique_ptr<udp_datagram_impl>&& impl) : _impl(std::move(impl)) {};$/;"	f	class:net::final
udp_datagram_impl	net/api.hh	/^class udp_datagram_impl {$/;"	c	namespace:net
~udp_channel_impl	net/api.hh	/^    virtual ~udp_channel_impl() {};$/;"	f	class:net::udp_channel_impl
~udp_datagram_impl	net/api.hh	/^    virtual ~udp_datagram_impl() {};$/;"	f	class:net::udp_datagram_impl
add	net/arp.cc	/^void arp::add(uint16_t proto_num, arp_for_protocol* afp) {$/;"	f	class:net::arp
arp	net/arp.cc	/^arp::arp(interface* netif) : _netif(netif), _proto(netif, eth_protocol_num::arp, [this] { return get_packet(); })$/;"	f	class:net::arp
arp_for_protocol	net/arp.cc	/^arp_for_protocol::arp_for_protocol(arp& a, uint16_t proto_num)$/;"	f	class:net::arp_for_protocol
del	net/arp.cc	/^void arp::del(uint16_t proto_num) {$/;"	f	class:net::arp
forward	net/arp.cc	/^bool arp::forward(forward_hash& out_hash_data, packet& p, size_t off) {$/;"	f	class:net::arp
get_packet	net/arp.cc	/^std::experimental::optional<l3_protocol::l3packet> arp::get_packet() {$/;"	f	class:net::arp
net	net/arp.cc	/^namespace net {$/;"	n	file:
process_packet	net/arp.cc	/^arp::process_packet(packet p, ethernet_address from) {$/;"	f	class:net::arp
~arp_for_protocol	net/arp.cc	/^arp_for_protocol::~arp_for_protocol() {$/;"	f	class:net::arp_for_protocol
ARP_HH_	net/arp.hh	24;"	d
_arp	net/arp.hh	/^    arp& _arp;$/;"	m	class:net::arp_for_protocol
_arp_for_protocol	net/arp.hh	/^    std::unordered_map<uint16_t, arp_for_protocol*> _arp_for_protocol;$/;"	m	class:net::arp
_in_progress	net/arp.hh	/^    std::unordered_map<l3addr, resolution> _in_progress;$/;"	m	class:net::arp_for
_l3self	net/arp.hh	/^    l3addr _l3self = L3::broadcast_address();$/;"	m	class:net::arp_for
_netif	net/arp.hh	/^    interface* _netif;$/;"	m	class:net::arp
_packetq	net/arp.hh	/^    circular_buffer<l3_protocol::l3packet> _packetq;$/;"	m	class:net::arp
_proto	net/arp.hh	/^    l3_protocol _proto;$/;"	m	class:net::arp
_proto_num	net/arp.hh	/^    uint16_t _proto_num;$/;"	m	class:net::arp_for_protocol
_rx_packets	net/arp.hh	/^    subscription<packet, ethernet_address> _rx_packets;$/;"	m	class:net::arp
_table	net/arp.hh	/^    std::unordered_map<l3addr, l2addr> _table;$/;"	m	class:net::arp_for
_timeout_timer	net/arp.hh	/^        timer<> _timeout_timer;$/;"	m	struct:net::arp_for::resolution
_waiters	net/arp.hh	/^        std::vector<promise<l2addr>> _waiters;$/;"	m	struct:net::arp_for::resolution
adjust_endianness	net/arp.hh	/^        void adjust_endianness(Adjuster a) { return a(htype, ptype); }$/;"	f	struct:net::arp::arp_hdr
adjust_endianness	net/arp.hh	/^        void adjust_endianness(Adjuster a) {$/;"	f	struct:net::arp_for::arp_hdr
arp	net/arp.hh	/^class arp {$/;"	c	namespace:net
arp_error	net/arp.hh	/^    arp_error(const std::string& msg) : std::runtime_error(msg) {}$/;"	f	class:net::arp_error
arp_error	net/arp.hh	/^class arp_error : public std::runtime_error {$/;"	c	namespace:net
arp_for	net/arp.hh	/^    explicit arp_for(arp& a) : arp_for_protocol(a, L3::arp_protocol_type()) {$/;"	f	class:net::arp_for
arp_for	net/arp.hh	/^class arp_for : public arp_for_protocol {$/;"	c	namespace:net
arp_for_protocol	net/arp.hh	/^class arp_for_protocol {$/;"	c	namespace:net
arp_hdr	net/arp.hh	/^    struct arp_hdr {$/;"	s	class:net::arp
arp_hdr	net/arp.hh	/^    struct arp_hdr {$/;"	s	class:net::arp_for
arp_queue_full_error	net/arp.hh	/^    arp_queue_full_error() : arp_error("ARP waiter's queue is full") {}$/;"	f	class:net::arp_queue_full_error
arp_queue_full_error	net/arp.hh	/^class arp_queue_full_error : public arp_error {$/;"	c	namespace:net
arp_timeout_error	net/arp.hh	/^    arp_timeout_error() : arp_error("ARP timeout") {}$/;"	f	class:net::arp_timeout_error
arp_timeout_error	net/arp.hh	/^class arp_timeout_error : public arp_error {$/;"	c	namespace:net
forward	net/arp.hh	/^    virtual bool forward(forward_hash& out_hash_data, packet& p, size_t off) { return false; }$/;"	f	class:net::arp_for_protocol
handle_request	net/arp.hh	/^arp_for<L3>::handle_request(arp_hdr* ah) {$/;"	f	class:net::arp_for
hlen	net/arp.hh	/^        uint8_t hlen;$/;"	m	struct:net::arp_for::arp_hdr
htype	net/arp.hh	/^        packed<uint16_t> htype;$/;"	m	struct:net::arp::arp_hdr
htype	net/arp.hh	/^        packed<uint16_t> htype;$/;"	m	struct:net::arp_for::arp_hdr
l2self	net/arp.hh	/^    ethernet_address l2self() { return _netif->hw_address(); }$/;"	f	class:net::arp
l2self	net/arp.hh	/^    l2addr l2self() { return _arp.l2self(); }$/;"	f	class:net::arp_for
learn	net/arp.hh	/^arp_for<L3>::learn(l2addr hwaddr, l3addr paddr) {$/;"	f	class:net::arp_for
lookup	net/arp.hh	/^arp_for<L3>::lookup(const l3addr& paddr) {$/;"	f	class:net::arp_for
make_query_packet	net/arp.hh	/^arp_for<L3>::make_query_packet(l3addr paddr) {$/;"	f	class:net::arp_for
max_waiters	net/arp.hh	/^    static constexpr auto max_waiters = 512;$/;"	m	class:net::arp_for
net	net/arp.hh	/^namespace net {$/;"	n
op_reply	net/arp.hh	/^        op_reply = 2,$/;"	e	enum:net::arp_for::oper
op_request	net/arp.hh	/^        op_request = 1,$/;"	e	enum:net::arp_for::oper
oper	net/arp.hh	/^        packed<uint16_t> oper;$/;"	m	struct:net::arp_for::arp_hdr
oper	net/arp.hh	/^    enum oper {$/;"	g	class:net::arp_for
override	net/arp.hh	/^    virtual future<> received(packet p) override;$/;"	m	class:net::arp_for
plen	net/arp.hh	/^        uint8_t plen;$/;"	m	struct:net::arp_for::arp_hdr
ptype	net/arp.hh	/^        packed<uint16_t> ptype;$/;"	m	struct:net::arp::arp_hdr
ptype	net/arp.hh	/^        packed<uint16_t> ptype;$/;"	m	struct:net::arp_for::arp_hdr
received	net/arp.hh	/^arp_for<L3>::received(packet p) {$/;"	f	class:net::arp_for
resolution	net/arp.hh	/^    struct resolution {$/;"	s	class:net::arp_for
send	net/arp.hh	/^void arp_for<L3>::send(l2addr to, packet p) {$/;"	f	class:net::arp_for
send_query	net/arp.hh	/^arp_for<L3>::send_query(const l3addr& paddr) {$/;"	f	class:net::arp_for
sender_hwaddr	net/arp.hh	/^        l2addr sender_hwaddr;$/;"	m	struct:net::arp_for::arp_hdr
sender_paddr	net/arp.hh	/^        l3addr sender_paddr;$/;"	m	struct:net::arp_for::arp_hdr
set_self_addr	net/arp.hh	/^    void set_self_addr(l3addr addr) { _l3self = addr; }$/;"	f	class:net::arp_for
target_hwaddr	net/arp.hh	/^        l2addr target_hwaddr;$/;"	m	struct:net::arp_for::arp_hdr
target_paddr	net/arp.hh	/^        l3addr target_paddr;$/;"	m	struct:net::arp_for::arp_hdr
BYTEORDER_HH_	net/byteorder.hh	23;"	d
hton	net/byteorder.hh	/^T hton(const T& x) {$/;"	f	namespace:net
hton	net/byteorder.hh	/^inline T hton(const packed<T>& x) {$/;"	f	namespace:net
hton	net/byteorder.hh	/^inline int16_t hton(int16_t x) { return htons(x); }$/;"	f	namespace:net
hton	net/byteorder.hh	/^inline int32_t hton(int32_t x) { return htonl(x); }$/;"	f	namespace:net
hton	net/byteorder.hh	/^inline int64_t hton(int64_t x) { return htonq(x); }$/;"	f	namespace:net
hton	net/byteorder.hh	/^inline int8_t hton(int8_t x) { return x; }$/;"	f	namespace:net
hton	net/byteorder.hh	/^inline uint16_t hton(uint16_t x) { return htons(x); }$/;"	f	namespace:net
hton	net/byteorder.hh	/^inline uint32_t hton(uint32_t x) { return htonl(x); }$/;"	f	namespace:net
hton	net/byteorder.hh	/^inline uint64_t hton(uint64_t x) { return htonq(x); }$/;"	f	namespace:net
hton	net/byteorder.hh	/^inline uint8_t hton(uint8_t x) { return x; }$/;"	f	namespace:net
hton	net/byteorder.hh	/^inline void hton() {}$/;"	f	namespace:net
hton_inplace	net/byteorder.hh	/^void hton_inplace() {};$/;"	f	namespace:net
hton_inplace	net/byteorder.hh	/^void hton_inplace(First& first, Rest&... rest) {$/;"	f	namespace:net
htonq	net/byteorder.hh	/^inline uint64_t htonq(uint64_t v) {$/;"	f
net	net/byteorder.hh	/^namespace net {$/;"	n
ntoh	net/byteorder.hh	/^T ntoh(const T& x) {$/;"	f	namespace:net
ntoh	net/byteorder.hh	/^inline T ntoh(const packed<T>& x) {$/;"	f	namespace:net
ntoh	net/byteorder.hh	/^inline int16_t ntoh(int16_t x) { return ntohs(x); }$/;"	f	namespace:net
ntoh	net/byteorder.hh	/^inline int32_t ntoh(int32_t x) { return ntohl(x); }$/;"	f	namespace:net
ntoh	net/byteorder.hh	/^inline int64_t ntoh(int64_t x) { return ntohq(x); }$/;"	f	namespace:net
ntoh	net/byteorder.hh	/^inline int8_t ntoh(int8_t x) { return x; }$/;"	f	namespace:net
ntoh	net/byteorder.hh	/^inline uint16_t ntoh(uint16_t x) { return ntohs(x); }$/;"	f	namespace:net
ntoh	net/byteorder.hh	/^inline uint32_t ntoh(uint32_t x) { return ntohl(x); }$/;"	f	namespace:net
ntoh	net/byteorder.hh	/^inline uint64_t ntoh(uint64_t x) { return ntohq(x); }$/;"	f	namespace:net
ntoh	net/byteorder.hh	/^inline uint8_t ntoh(uint8_t x) { return x; }$/;"	f	namespace:net
ntoh	net/byteorder.hh	/^inline void ntoh() {}$/;"	f	namespace:net
ntoh_inplace	net/byteorder.hh	/^void ntoh_inplace() {}$/;"	f	namespace:net
ntoh_inplace	net/byteorder.hh	/^void ntoh_inplace(First& first, Rest&... rest) {$/;"	f	namespace:net
ntohq	net/byteorder.hh	/^inline uint64_t ntohq(uint64_t v) {$/;"	f
operator <<	net/byteorder.hh	/^inline std::ostream& operator<<(std::ostream& os, const packed<T>& v) {$/;"	f	namespace:net
CONST_HH_	net/const.hh	23;"	d
arp	net/const.hh	/^    ipv4 = 0x0800, arp = 0x0806, ipv6 = 0x86dd$/;"	m	class:net::ip_protocol_num::eth_protocol_num
eth_hdr_len	net/const.hh	/^const uint8_t eth_hdr_len = 14;$/;"	m	class:net::ip_protocol_num::eth_protocol_num
eth_protocol_num	net/const.hh	/^enum class eth_protocol_num : uint16_t {$/;"	c	class:net::ip_protocol_num
icmp	net/const.hh	/^    icmp = 1, tcp = 6, udp = 17, unused = 255$/;"	m	class:net::ip_protocol_num
ip_packet_len_max	net/const.hh	/^const uint16_t ip_packet_len_max = 65535;$/;"	m	class:net::ip_protocol_num::eth_protocol_num
ip_protocol_num	net/const.hh	/^enum class ip_protocol_num : uint8_t {$/;"	c	namespace:net
ipv4	net/const.hh	/^    ipv4 = 0x0800, arp = 0x0806, ipv6 = 0x86dd$/;"	m	class:net::ip_protocol_num::eth_protocol_num
ipv4_hdr_len_min	net/const.hh	/^const uint8_t ipv4_hdr_len_min = 20;$/;"	m	class:net::ip_protocol_num::eth_protocol_num
ipv6	net/const.hh	/^    ipv4 = 0x0800, arp = 0x0806, ipv6 = 0x86dd$/;"	m	class:net::ip_protocol_num::eth_protocol_num
ipv6_hdr_len_min	net/const.hh	/^const uint8_t ipv6_hdr_len_min = 40;$/;"	m	class:net::ip_protocol_num::eth_protocol_num
net	net/const.hh	/^namespace net {$/;"	n
tcp	net/const.hh	/^    icmp = 1, tcp = 6, udp = 17, unused = 255$/;"	m	class:net::ip_protocol_num
tcp_hdr_len_min	net/const.hh	/^const uint8_t tcp_hdr_len_min = 20;$/;"	m	class:net::ip_protocol_num::eth_protocol_num
udp	net/const.hh	/^    icmp = 1, tcp = 6, udp = 17, unused = 255$/;"	m	class:net::ip_protocol_num
unused	net/const.hh	/^    icmp = 1, tcp = 6, udp = 17, unused = 255$/;"	m	class:net::ip_protocol_num
ACK	net/dhcp.cc	/^        ACK = 5,$/;"	m	class:net::dhcp::impl::m_type::htype::opt_type::msg_type	file:
BOOTREPLY	net/dhcp.cc	/^        BOOTREPLY = 2$/;"	m	class:net::dhcp::impl::m_type	file:
BOOTREQUEST	net/dhcp.cc	/^        BOOTREQUEST = 1,$/;"	m	class:net::dhcp::impl::m_type	file:
BROADCAST_ADDRESS	net/dhcp.cc	/^        BROADCAST_ADDRESS = 28,$/;"	m	class:net::dhcp::impl::m_type::htype::opt_type	file:
CLASSLESS_ROUTE	net/dhcp.cc	/^        CLASSLESS_ROUTE = 121,$/;"	m	class:net::dhcp::impl::m_type::htype::opt_type	file:
DECLINE	net/dhcp.cc	/^        DECLINE = 4,$/;"	m	class:net::dhcp::impl::m_type::htype::opt_type::msg_type	file:
DHCP_SERVER	net/dhcp.cc	/^        DHCP_SERVER = 54,$/;"	m	class:net::dhcp::impl::m_type::htype::opt_type	file:
DISCOVER	net/dhcp.cc	/^        DISCOVER = 1,$/;"	m	class:net::dhcp::impl::m_type::htype::opt_type::msg_type	file:
DISCOVER	net/dhcp.cc	/^        DISCOVER,$/;"	m	class:net::dhcp::impl::state	file:
DOMAIN_NAME_SERVERS	net/dhcp.cc	/^        DOMAIN_NAME_SERVERS = 6,$/;"	m	class:net::dhcp::impl::m_type::htype::opt_type	file:
DONE	net/dhcp.cc	/^        DONE,$/;"	m	class:net::dhcp::impl::state	file:
END	net/dhcp.cc	/^        END = 255$/;"	m	class:net::dhcp::impl::m_type::htype::opt_type	file:
ETHERNET	net/dhcp.cc	/^        ETHERNET = 1$/;"	m	class:net::dhcp::impl::m_type::htype	file:
FAIL	net/dhcp.cc	/^        FAIL,$/;"	m	class:net::dhcp::impl::state	file:
INFORM	net/dhcp.cc	/^        INFORM = 8,$/;"	m	class:net::dhcp::impl::m_type::htype::opt_type::msg_type	file:
INTERFACE_MTU	net/dhcp.cc	/^        INTERFACE_MTU = 26,$/;"	m	class:net::dhcp::impl::m_type::htype::opt_type	file:
INVALID	net/dhcp.cc	/^        INVALID = 255$/;"	m	class:net::dhcp::impl::m_type::htype::opt_type::msg_type	file:
LEASEACTIVE	net/dhcp.cc	/^        LEASEACTIVE = 13,$/;"	m	class:net::dhcp::impl::m_type::htype::opt_type::msg_type	file:
LEASEQUERY	net/dhcp.cc	/^        LEASEQUERY = 10,$/;"	m	class:net::dhcp::impl::m_type::htype::opt_type::msg_type	file:
LEASEUNASSIGNED	net/dhcp.cc	/^        LEASEUNASSIGNED = 11,$/;"	m	class:net::dhcp::impl::m_type::htype::opt_type::msg_type	file:
LEASEUNKNOWN	net/dhcp.cc	/^        LEASEUNKNOWN = 12,$/;"	m	class:net::dhcp::impl::m_type::htype::opt_type::msg_type	file:
LEASE_TIME	net/dhcp.cc	/^        LEASE_TIME = 51,$/;"	m	class:net::dhcp::impl::m_type::htype::opt_type	file:
MESSAGE_TYPE	net/dhcp.cc	/^        MESSAGE_TYPE = 53,$/;"	m	class:net::dhcp::impl::m_type::htype::opt_type	file:
NAK	net/dhcp.cc	/^        NAK = 6,$/;"	m	class:net::dhcp::impl::m_type::htype::opt_type::msg_type	file:
NONE	net/dhcp.cc	/^        NONE,$/;"	m	class:net::dhcp::impl::state	file:
OFFER	net/dhcp.cc	/^        OFFER = 2,$/;"	m	class:net::dhcp::impl::m_type::htype::opt_type::msg_type	file:
PAD	net/dhcp.cc	/^        PAD = 0,$/;"	m	class:net::dhcp::impl::m_type::htype::opt_type	file:
PARAMETER_REQUEST_LIST	net/dhcp.cc	/^        PARAMETER_REQUEST_LIST = 55,$/;"	m	class:net::dhcp::impl::m_type::htype::opt_type	file:
REBINDING_TIME	net/dhcp.cc	/^        REBINDING_TIME = 59,$/;"	m	class:net::dhcp::impl::m_type::htype::opt_type	file:
RELEASE	net/dhcp.cc	/^        RELEASE = 7,$/;"	m	class:net::dhcp::impl::m_type::htype::opt_type::msg_type	file:
RENEWAL_TIME	net/dhcp.cc	/^        RENEWAL_TIME = 58,$/;"	m	class:net::dhcp::impl::m_type::htype::opt_type	file:
REQUEST	net/dhcp.cc	/^        REQUEST = 3,$/;"	m	class:net::dhcp::impl::m_type::htype::opt_type::msg_type	file:
REQUEST	net/dhcp.cc	/^        REQUEST,$/;"	m	class:net::dhcp::impl::state	file:
REQUESTED_ADDRESS	net/dhcp.cc	/^        REQUESTED_ADDRESS = 50,$/;"	m	class:net::dhcp::impl::m_type::htype::opt_type	file:
ROUTER	net/dhcp.cc	/^        ROUTER = 3,$/;"	m	class:net::dhcp::impl::m_type::htype::opt_type	file:
SUBNET_MASK	net/dhcp.cc	/^        SUBNET_MASK = 1,$/;"	m	class:net::dhcp::impl::m_type::htype::opt_type	file:
_result	net/dhcp.cc	/^    promise<bool, lease> _result;$/;"	m	class:net::dhcp::impl::m_type::htype::opt_type::msg_type	file:
_retry_timer	net/dhcp.cc	/^    timer<> _retry_timer;$/;"	m	class:net::dhcp::impl::m_type::htype::opt_type::msg_type	file:
_sock	net/dhcp.cc	/^    udp_channel _sock;$/;"	m	class:net::dhcp::impl::m_type::htype::opt_type::msg_type	file:
_stack	net/dhcp.cc	/^    ipv4 & _stack;$/;"	m	class:net::dhcp::impl::m_type::htype::opt_type::msg_type	file:
_state	net/dhcp.cc	/^    state _state = state::NONE;$/;"	m	class:net::dhcp::impl::m_type::htype::opt_type::msg_type	file:
_timer	net/dhcp.cc	/^    timer<> _timer;$/;"	m	class:net::dhcp::impl::m_type::htype::opt_type::msg_type	file:
_xid	net/dhcp.cc	/^    uint32_t _xid = 0;$/;"	m	class:net::dhcp::impl::m_type::htype::opt_type::msg_type	file:
adjust_endianness	net/dhcp.cc	/^        auto adjust_endianness(Adjuster a) {$/;"	f	struct:net::dhcp::impl::m_type::htype::opt_type::msg_type::dhcp_header
adjust_endianness	net/dhcp.cc	/^        auto adjust_endianness(Adjuster a) {$/;"	f	struct:net::dhcp::impl::m_type::htype::opt_type::msg_type::dhcp_packet_base
adjust_endianness	net/dhcp.cc	/^        auto adjust_endianness(Adjuster a) {$/;"	f	struct:net::dhcp::impl::m_type::htype::opt_type::msg_type::dhcp_payload
bootp	net/dhcp.cc	/^        dhcp_header bootp;$/;"	m	struct:net::dhcp::impl::m_type::htype::opt_type::msg_type::dhcp_payload	file:
chaddr	net/dhcp.cc	/^        uint8_t chaddr[16] = { 0, };     \/\/ Client hardware address.$/;"	m	struct:net::dhcp::impl::m_type::htype::opt_type::msg_type::dhcp_header	file:
ciaddr	net/dhcp.cc	/^        ipv4_address ciaddr;  \/\/ Client IP address$/;"	m	struct:net::dhcp::impl::m_type::htype::opt_type::msg_type::dhcp_header	file:
client_port	net/dhcp.cc	/^    static const uint16_t client_port = 68;$/;"	m	class:net::dhcp::impl::m_type::htype::opt_type::msg_type	file:
client_port	net/dhcp.cc	/^const uint16_t net::dhcp::impl::client_port;$/;"	m	class:net::dhcp::impl::m_type::htype::opt_type::net::dhcp::impl	file:
default_timeout	net/dhcp.cc	/^const clock_type::duration net::dhcp::default_timeout = std::chrono::duration_cast<clock_type::duration>(std::chrono::seconds(30));$/;"	m	class:net::dhcp::impl::m_type::htype::opt_type::net::dhcp	file:
dhcp	net/dhcp.cc	/^net::dhcp::dhcp(dhcp && v)$/;"	f	class:net::dhcp::impl::m_type::htype::opt_type::net::dhcp	file:
dhcp	net/dhcp.cc	/^net::dhcp::dhcp(ipv4 & ip)$/;"	f	class:net::dhcp::impl::m_type::htype::opt_type::net::dhcp	file:
dhcp_header	net/dhcp.cc	/^    struct dhcp_header {$/;"	s	class:net::dhcp::impl::m_type::htype::opt_type::msg_type	file:
dhcp_packet_base	net/dhcp.cc	/^    struct dhcp_packet_base {$/;"	s	class:net::dhcp::impl::m_type::htype::opt_type::msg_type	file:
dhcp_payload	net/dhcp.cc	/^    struct dhcp_payload {$/;"	s	class:net::dhcp::impl::m_type::htype::opt_type::msg_type	file:
dhp	net/dhcp.cc	/^        dhcp_payload dhp;$/;"	m	struct:net::dhcp::impl::m_type::htype::opt_type::msg_type::dhcp_packet_base	file:
discover	net/dhcp.cc	/^net::dhcp::result_type net::dhcp::discover(const clock_type::duration & timeout) {$/;"	f	class:net::dhcp::impl::m_type::htype::opt_type::net::dhcp	file:
file	net/dhcp.cc	/^        char file[128] = { 0, };         \/\/ unused$/;"	m	struct:net::dhcp::impl::m_type::htype::opt_type::msg_type::dhcp_header	file:
flags	net/dhcp.cc	/^        packed<uint16_t> flags = 0;         \/\/ Flags$/;"	m	struct:net::dhcp::impl::m_type::htype::opt_type::msg_type::dhcp_header	file:
get_ipv4_filter	net/dhcp.cc	/^net::ip_packet_filter* net::dhcp::get_ipv4_filter() {$/;"	f	class:net::dhcp::impl::m_type::htype::opt_type::net::dhcp	file:
giaddr	net/dhcp.cc	/^        ipv4_address giaddr;  \/\/ Relay agent IP address$/;"	m	struct:net::dhcp::impl::m_type::htype::opt_type::msg_type::dhcp_header	file:
hlen	net/dhcp.cc	/^        uint8_t hlen = 6;           \/\/ Hardware address length$/;"	m	struct:net::dhcp::impl::m_type::htype::opt_type::msg_type::dhcp_header	file:
hops	net/dhcp.cc	/^        uint8_t hops = 0;           \/\/ Client sets to zero, used by relay agents$/;"	m	struct:net::dhcp::impl::m_type::htype::opt_type::msg_type::dhcp_header	file:
htype	net/dhcp.cc	/^    enum class htype : uint8_t {$/;"	c	class:net::dhcp::impl::m_type	file:
impl	net/dhcp.cc	/^    impl(ipv4 & stack)$/;"	f	class:net::dhcp::impl::m_type::htype::opt_type::msg_type	file:
impl	net/dhcp.cc	/^class net::dhcp::impl : public ip_packet_filter {$/;"	c	class:net::dhcp	file:
ip	net/dhcp.cc	/^        packed<uint32_t> ip;$/;"	m	struct:net::dhcp::impl::m_type::htype::opt_type::msg_type::ip_option	file:
ip_info	net/dhcp.cc	/^    struct ip_info : public lease {$/;"	s	class:net::dhcp::impl::m_type::htype::opt_type::msg_type	file:
ip_option	net/dhcp.cc	/^        ip_option(opt_type t = opt_type::BROADCAST_ADDRESS, const ipv4_address & ip = ipv4_address()) : option(t, sizeof(uint32_t)), ip(::htonl(ip.ip)) {}$/;"	f	struct:net::dhcp::impl::m_type::htype::opt_type::msg_type::ip_option
ip_option	net/dhcp.cc	/^    struct ip_option : public option {$/;"	s	class:net::dhcp::impl::m_type::htype::opt_type::msg_type	file:
len	net/dhcp.cc	/^        uint8_t len;$/;"	m	struct:net::dhcp::impl::m_type::htype::opt_type::msg_type::option	file:
log	net/dhcp.cc	/^    decltype(std::cout) & log() {$/;"	f	class:net::dhcp::impl
m_type	net/dhcp.cc	/^    enum class m_type : uint8_t {$/;"	c	class:net::dhcp::impl	file:
magic	net/dhcp.cc	/^        magic_tag magic = options_magic;$/;"	m	struct:net::dhcp::impl::m_type::htype::opt_type::msg_type::dhcp_payload	file:
magic_tag	net/dhcp.cc	/^    typedef std::array<uint8_t, 4> magic_tag;$/;"	t	class:net::dhcp::impl::m_type::htype::opt_type::msg_type	file:
msg_type	net/dhcp.cc	/^    enum class msg_type : uint8_t {$/;"	c	class:net::dhcp::impl::m_type::htype::opt_type	file:
mtu	net/dhcp.cc	/^        packed<uint16_t> mtu;$/;"	m	struct:net::dhcp::impl::m_type::htype::opt_type::msg_type::mtu_option	file:
mtu_option	net/dhcp.cc	/^        mtu_option(uint16_t v) : option(opt_type::INTERFACE_MTU, 2), mtu((::htons)(v)) {}$/;"	f	struct:net::dhcp::impl::m_type::htype::opt_type::msg_type::mtu_option
mtu_option	net/dhcp.cc	/^    struct mtu_option : public option {$/;"	s	class:net::dhcp::impl::m_type::htype::opt_type::msg_type	file:
op	net/dhcp.cc	/^        m_type op = m_type::BOOTREQUEST; \/\/ Message op code \/ message type.$/;"	m	struct:net::dhcp::impl::m_type::htype::opt_type::msg_type::dhcp_header	file:
opt_type	net/dhcp.cc	/^    enum class opt_type : uint8_t {$/;"	c	class:net::dhcp::impl::m_type::htype	file:
option	net/dhcp.cc	/^        option(opt_type t, uint8_t l = 1) : option_mark(t), len(l) {};$/;"	f	struct:net::dhcp::impl::m_type::htype::opt_type::msg_type::option
option	net/dhcp.cc	/^    struct option : public option_mark {$/;"	s	class:net::dhcp::impl::m_type::htype::opt_type::msg_type	file:
option_mark	net/dhcp.cc	/^        option_mark(opt_type t = opt_type::END) : type(t) {};$/;"	f	struct:net::dhcp::impl::m_type::htype::opt_type::msg_type::option_mark
option_mark	net/dhcp.cc	/^    struct option_mark {$/;"	s	class:net::dhcp::impl::m_type::htype::opt_type::msg_type	file:
options_magic	net/dhcp.cc	/^    static const magic_tag options_magic;$/;"	m	class:net::dhcp::impl::m_type::htype::opt_type::msg_type	file:
options_magic	net/dhcp.cc	/^const net::dhcp::impl::magic_tag net::dhcp::impl::options_magic = { { 0x63, 0x82, 0x53,$/;"	m	class:net::dhcp::impl::m_type::htype::opt_type::net::dhcp::impl	file:
parse_options	net/dhcp.cc	/^        void parse_options(packet & p, size_t off) {$/;"	f	struct:net::dhcp::impl::m_type::htype::opt_type::msg_type::ip_info
process_packet	net/dhcp.cc	/^    future<> process_packet(packet p, dhcp_payload* dhp, size_t opt_off) {$/;"	f	class:net::dhcp::impl::m_type::htype::opt_type::msg_type	file:
renew	net/dhcp.cc	/^net::dhcp::result_type net::dhcp::renew(const lease & l, const clock_type::duration & timeout) {$/;"	f	class:net::dhcp::impl::m_type::htype::opt_type::net::dhcp	file:
req	net/dhcp.cc	/^        req_opt_type req;$/;"	m	struct:net::dhcp::impl::m_type::htype::opt_type::msg_type::requested_option	file:
req_opt_type	net/dhcp.cc	/^    typedef std::array<opt_type, 5> req_opt_type;$/;"	t	class:net::dhcp::impl::m_type::htype::opt_type::msg_type	file:
requested_option	net/dhcp.cc	/^        requested_option()$/;"	f	struct:net::dhcp::impl::m_type::htype::opt_type::msg_type::requested_option
requested_option	net/dhcp.cc	/^    struct requested_option: public option {$/;"	s	class:net::dhcp::impl::m_type::htype::opt_type::msg_type	file:
requested_options	net/dhcp.cc	/^    static const req_opt_type requested_options;$/;"	m	class:net::dhcp::impl::m_type::htype::opt_type::msg_type	file:
requested_options	net/dhcp.cc	/^const net::dhcp::impl::req_opt_type net::dhcp::impl::requested_options = { {$/;"	m	class:net::dhcp::impl::m_type::htype::opt_type::net::dhcp::impl	file:
run	net/dhcp.cc	/^    future<bool, lease> run(const lease & l,$/;"	f	class:net::dhcp::impl::m_type::htype::opt_type::msg_type	file:
secs	net/dhcp.cc	/^        packed<uint16_t> secs = 0;          \/\/ Client sets seconds elapsed since op start$/;"	m	struct:net::dhcp::impl::m_type::htype::opt_type::msg_type::dhcp_header	file:
send	net/dhcp.cc	/^    future<> send(T && pkt) {$/;"	f	class:net::dhcp::impl::m_type::htype::opt_type::msg_type	file:
send_discover	net/dhcp.cc	/^    future<> send_discover(const ipv4_address & ip = ipv4_address()) {$/;"	f	class:net::dhcp::impl::m_type::htype::opt_type::msg_type	file:
send_request	net/dhcp.cc	/^    future<> send_request(const lease & info) {$/;"	f	class:net::dhcp::impl::m_type::htype::opt_type::msg_type	file:
server_port	net/dhcp.cc	/^    static const uint16_t server_port = 67;$/;"	m	class:net::dhcp::impl::m_type::htype::opt_type::msg_type	file:
server_port	net/dhcp.cc	/^const uint16_t net::dhcp::impl::server_port;$/;"	m	class:net::dhcp::impl::m_type::htype::opt_type::net::dhcp::impl	file:
set	net/dhcp.cc	/^        void set(opt_type type, const ipv4_address & ip) {$/;"	f	struct:net::dhcp::impl::m_type::htype::opt_type::msg_type::ip_info
set	net/dhcp.cc	/^        void set(opt_type type, std::chrono::seconds s) {$/;"	f	struct:net::dhcp::impl::m_type::htype::opt_type::msg_type::ip_info
siaddr	net/dhcp.cc	/^        ipv4_address siaddr;  \/\/ IP address of next server to use in bootstrap$/;"	m	struct:net::dhcp::impl::m_type::htype::opt_type::msg_type::dhcp_header	file:
sname	net/dhcp.cc	/^        char sname[64] = { 0, };         \/\/ unused$/;"	m	struct:net::dhcp::impl::m_type::htype::opt_type::msg_type::dhcp_header	file:
state	net/dhcp.cc	/^    enum class state {$/;"	c	class:net::dhcp::impl	file:
time	net/dhcp.cc	/^        packed<uint32_t> time;$/;"	m	struct:net::dhcp::impl::m_type::htype::opt_type::msg_type::time_option	file:
time_option	net/dhcp.cc	/^        time_option(opt_type t, uint32_t v) : option(t, sizeof(uint32_t)), time(::htonl(v)) {}$/;"	f	struct:net::dhcp::impl::m_type::htype::opt_type::msg_type::time_option
time_option	net/dhcp.cc	/^    struct time_option : public option {$/;"	s	class:net::dhcp::impl::m_type::htype::opt_type::msg_type	file:
type	net/dhcp.cc	/^        htype type = htype::ETHERNET;             \/\/ Hardware address type$/;"	m	struct:net::dhcp::impl::m_type::htype::opt_type::msg_type::dhcp_header	file:
type	net/dhcp.cc	/^        msg_type type = msg_type();$/;"	m	struct:net::dhcp::impl::m_type::htype::opt_type::msg_type::ip_info	file:
type	net/dhcp.cc	/^        msg_type type;$/;"	m	struct:net::dhcp::impl::m_type::htype::opt_type::msg_type::type_option	file:
type	net/dhcp.cc	/^        opt_type type;$/;"	m	struct:net::dhcp::impl::m_type::htype::opt_type::msg_type::option_mark	file:
type_option	net/dhcp.cc	/^        type_option(msg_type t) : option(opt_type::MESSAGE_TYPE), type(t) {}$/;"	f	struct:net::dhcp::impl::m_type::htype::opt_type::msg_type::type_option
type_option	net/dhcp.cc	/^    struct type_option : public option {$/;"	s	class:net::dhcp::impl::m_type::htype::opt_type::msg_type	file:
xid	net/dhcp.cc	/^        packed<uint32_t> xid = 0;           \/\/ Client sets Transaction ID, a random number$/;"	m	struct:net::dhcp::impl::m_type::htype::opt_type::msg_type::dhcp_header	file:
yiaddr	net/dhcp.cc	/^        ipv4_address yiaddr;  \/\/ 'your' (client) IP address.$/;"	m	struct:net::dhcp::impl::m_type::htype::opt_type::msg_type::dhcp_header	file:
~dhcp	net/dhcp.cc	/^net::dhcp::~dhcp()$/;"	f	class:net::dhcp::impl::m_type::htype::opt_type::net::dhcp	file:
NET_DHCP_HH_	net/dhcp.hh	23;"	d
_impl	net/dhcp.hh	/^    std::unique_ptr<impl> _impl;$/;"	m	class:net::dhcp
broadcast	net/dhcp.hh	/^        ipv4_address broadcast;$/;"	m	struct:net::dhcp::lease
default_timeout	net/dhcp.hh	/^    static const clock_type::duration default_timeout;$/;"	m	class:net::dhcp
dhcp	net/dhcp.hh	/^class dhcp {$/;"	c	namespace:net
dhcp_server	net/dhcp.hh	/^        ipv4_address dhcp_server;$/;"	m	struct:net::dhcp::lease
gateway	net/dhcp.hh	/^        ipv4_address gateway;$/;"	m	struct:net::dhcp::lease
ip	net/dhcp.hh	/^        ipv4_address ip;$/;"	m	struct:net::dhcp::lease
lease	net/dhcp.hh	/^    struct lease {$/;"	s	class:net::dhcp
lease_time	net/dhcp.hh	/^        std::chrono::seconds lease_time;$/;"	m	struct:net::dhcp::lease
mtu	net/dhcp.hh	/^        uint16_t mtu = 0;$/;"	m	struct:net::dhcp::lease
name_servers	net/dhcp.hh	/^        std::vector<ipv4_address> name_servers;$/;"	m	struct:net::dhcp::lease
net	net/dhcp.hh	/^namespace net {$/;"	n
netmask	net/dhcp.hh	/^        ipv4_address netmask;$/;"	m	struct:net::dhcp::lease
rebind_time	net/dhcp.hh	/^        std::chrono::seconds rebind_time;$/;"	m	struct:net::dhcp::lease
renew_time	net/dhcp.hh	/^        std::chrono::seconds renew_time;$/;"	m	struct:net::dhcp::lease
result_type	net/dhcp.hh	/^    typedef future<bool, lease> result_type;$/;"	t	class:net::dhcp
MARKER	net/dpdk.cc	/^typedef void    *MARKER[0];   \/**< generic marker for a point in a structure *\/$/;"	t	file:
_buf_len	net/dpdk.cc	/^        uint32_t _buf_len;$/;"	m	class:dpdk::dpdk_qp::tx_buf	file:
_buf_physaddr	net/dpdk.cc	/^        phys_addr_t _buf_physaddr;$/;"	m	class:dpdk::dpdk_qp::tx_buf	file:
_bufs	net/dpdk.cc	/^    std::vector<char*> _bufs;$/;"	m	class:dpdk::dpdk_qp	file:
_collectd_regs	net/dpdk.cc	/^    std::vector<scollectd::registration> _collectd_regs;$/;"	m	class:dpdk::dpdk_device	file:
_data	net/dpdk.cc	/^        void*    _data;$/;"	m	class:dpdk::dpdk_qp::tx_buf	file:
_data_off	net/dpdk.cc	/^        uint16_t _data_off;$/;"	m	class:dpdk::dpdk_qp::tx_buf	file:
_dev	net/dpdk.cc	/^    dpdk_device* _dev;$/;"	m	class:dpdk::dpdk_qp	file:
_dev_info	net/dpdk.cc	/^    rte_eth_dev_info _dev_info = {};$/;"	m	class:dpdk::dpdk_device	file:
_enable_fc	net/dpdk.cc	/^    bool _enable_fc;$/;"	m	class:dpdk::dpdk_device	file:
_fc	net/dpdk.cc	/^        tx_buf_factory& _fc;$/;"	m	class:dpdk::dpdk_qp::tx_buf	file:
_frags	net/dpdk.cc	/^    std::vector<fragment> _frags;$/;"	m	class:dpdk::dpdk_qp	file:
_home_cpu	net/dpdk.cc	/^    unsigned _home_cpu;$/;"	m	class:dpdk::dpdk_device	file:
_hw_features	net/dpdk.cc	/^    net::hw_features _hw_features;$/;"	m	class:dpdk::dpdk_device	file:
_is_zc	net/dpdk.cc	/^        bool _is_zc = false;$/;"	m	class:dpdk::dpdk_qp::tx_buf	file:
_link_ready_promise	net/dpdk.cc	/^    promise<> _link_ready_promise;$/;"	m	class:dpdk::dpdk_device	file:
_mbuf	net/dpdk.cc	/^        struct rte_mbuf _mbuf;$/;"	m	class:dpdk::dpdk_qp::tx_buf	typeref:struct:dpdk::dpdk_qp::tx_buf::rte_mbuf	file:
_num_queues	net/dpdk.cc	/^    uint16_t _num_queues;$/;"	m	class:dpdk::dpdk_device	file:
_num_rx_free_segs	net/dpdk.cc	/^    size_t _num_rx_free_segs = 0;$/;"	m	class:dpdk::dpdk_qp	file:
_p	net/dpdk.cc	/^        std::experimental::optional<packet> _p;$/;"	m	class:dpdk::dpdk_qp::tx_buf	file:
_pktmbuf_pool_rx	net/dpdk.cc	/^    rte_mempool *_pktmbuf_pool_rx;$/;"	m	class:dpdk::dpdk_qp	file:
_pool	net/dpdk.cc	/^        rte_mempool* _pool = nullptr;$/;"	m	class:dpdk::dpdk_qp::tx_buf_factory	file:
_port_idx	net/dpdk.cc	/^    uint8_t _port_idx;$/;"	m	class:dpdk::dpdk_device	file:
_qid	net/dpdk.cc	/^    uint8_t _qid;$/;"	m	class:dpdk::dpdk_qp	file:
_queues_ready	net/dpdk.cc	/^    uint8_t _queues_ready = 0;$/;"	m	class:dpdk::dpdk_device	file:
_redir_table	net/dpdk.cc	/^    std::vector<uint8_t> _redir_table;$/;"	m	class:dpdk::dpdk_device	file:
_ring	net/dpdk.cc	/^        std::vector<tx_buf*> _ring;$/;"	m	class:dpdk::dpdk_qp::tx_buf_factory	file:
_rx_conf_default	net/dpdk.cc	/^    struct rte_eth_rxconf _rx_conf_default = {};$/;"	m	class:dpdk::dpdk_device	typeref:struct:dpdk::dpdk_device::rte_eth_rxconf	file:
_rx_free_bufs	net/dpdk.cc	/^    std::vector<rte_mbuf*> _rx_free_bufs;$/;"	m	class:dpdk::dpdk_qp	file:
_rx_free_pkts	net/dpdk.cc	/^    std::vector<rte_mbuf*> _rx_free_pkts;$/;"	m	class:dpdk::dpdk_qp	file:
_rx_gc_poller	net/dpdk.cc	/^    reactor::poller _rx_gc_poller;$/;"	m	class:dpdk::dpdk_qp	file:
_rx_poller	net/dpdk.cc	/^    std::experimental::optional<reactor::poller> _rx_poller;$/;"	m	class:dpdk::dpdk_qp	file:
_rx_xmem	net/dpdk.cc	/^    std::unique_ptr<void, free_deleter> _rx_xmem;$/;"	m	class:dpdk::dpdk_qp	file:
_send	net/dpdk.cc	/^    uint32_t _send(circular_buffer<packet>& pb, Func packet_to_tx_buf_p) {$/;"	f	class:dpdk::dpdk_qp	file:
_stats	net/dpdk.cc	/^    port_stats _stats;$/;"	m	class:dpdk::dpdk_device	file:
_stats_collector	net/dpdk.cc	/^    timer<> _stats_collector;$/;"	m	class:dpdk::dpdk_device	file:
_stats_plugin_inst	net/dpdk.cc	/^    const std::string _stats_plugin_inst;$/;"	m	class:dpdk::dpdk_device	file:
_stats_plugin_name	net/dpdk.cc	/^    const std::string _stats_plugin_name;$/;"	m	class:dpdk::dpdk_device	file:
_tx_buf_factory	net/dpdk.cc	/^    tx_buf_factory _tx_buf_factory;$/;"	m	class:dpdk::dpdk_qp	file:
_tx_burst	net/dpdk.cc	/^    std::vector<rte_mbuf*> _tx_burst;$/;"	m	class:dpdk::dpdk_qp	file:
_tx_burst_idx	net/dpdk.cc	/^    uint16_t _tx_burst_idx = 0;$/;"	m	class:dpdk::dpdk_qp	file:
_tx_conf_default	net/dpdk.cc	/^    struct rte_eth_txconf _tx_conf_default = {};$/;"	m	class:dpdk::dpdk_device	typeref:struct:dpdk::dpdk_device::rte_eth_txconf	file:
_tx_gc_poller	net/dpdk.cc	/^    reactor::poller _tx_gc_poller;$/;"	m	class:dpdk::dpdk_qp	file:
_use_lro	net/dpdk.cc	/^    bool _use_lro;$/;"	m	class:dpdk::dpdk_device	file:
_xmem	net/dpdk.cc	/^        std::unique_ptr<void, free_deleter> _xmem;$/;"	m	class:dpdk::dpdk_qp::tx_buf_factory	file:
alloc_mempool_xmem	net/dpdk.cc	/^void* dpdk_qp<HugetlbfsMemBackend>::alloc_mempool_xmem($/;"	f	class:dpdk::dpdk_qp
as_cookie	net/dpdk.cc	/^void* as_cookie(struct rte_pktmbuf_pool_private& p) {$/;"	f
bad	net/dpdk.cc	/^        } bad;$/;"	m	struct:dpdk::port_stats::__anon12	typeref:struct:dpdk::port_stats::__anon12::__anon14	file:
bad	net/dpdk.cc	/^        } bad;$/;"	m	struct:dpdk::port_stats::__anon9	typeref:struct:dpdk::port_stats::__anon9::__anon11	file:
check_frag0	net/dpdk.cc	/^        static bool check_frag0(packet& p)$/;"	f	class:dpdk::dpdk_qp::tx_buf	file:
check_port_link_status	net/dpdk.cc	/^void dpdk_device::check_port_link_status()$/;"	f	class:dpdk::dpdk_device
copy_one_data_buf	net/dpdk.cc	/^        static size_t copy_one_data_buf($/;"	f	class:dpdk::dpdk_qp::tx_buf	file:
copy_one_frag	net/dpdk.cc	/^        static bool copy_one_frag(dpdk_qp& qp, fragment& frag,$/;"	f	class:dpdk::dpdk_qp::tx_buf	file:
crc	net/dpdk.cc	/^            uint64_t crc;          \/\/ packets with CRC error$/;"	m	struct:dpdk::port_stats::__anon9::__anon11	file:
create_dpdk_net_device	net/dpdk.cc	/^std::unique_ptr<net::device> create_dpdk_net_device($/;"	f
def_rx_conf	net/dpdk.cc	/^    const rte_eth_rxconf* def_rx_conf() const {$/;"	f	class:dpdk::dpdk_device
def_tx_conf	net/dpdk.cc	/^    const rte_eth_txconf* def_tx_conf() const {$/;"	f	class:dpdk::dpdk_device
default_pthresh	net/dpdk.cc	/^static constexpr uint8_t default_pthresh         = 36;$/;"	m	namespace:dpdk	file:
default_ring_size	net/dpdk.cc	/^static constexpr uint16_t default_ring_size      = 512;$/;"	m	namespace:dpdk	file:
default_rx_hthresh	net/dpdk.cc	/^static constexpr uint8_t default_rx_hthresh      = 8;$/;"	m	namespace:dpdk	file:
default_tx_hthresh	net/dpdk.cc	/^static constexpr uint8_t default_tx_hthresh      = 0;$/;"	m	namespace:dpdk	file:
default_wthresh	net/dpdk.cc	/^static constexpr uint8_t default_wthresh         = 0;$/;"	m	namespace:dpdk	file:
do_one_frag	net/dpdk.cc	/^        static bool do_one_frag(DoOneBufFunc do_one_buf, dpdk_qp& qp,$/;"	f	class:dpdk::dpdk_qp::tx_buf	file:
dpdk	net/dpdk.cc	/^namespace dpdk {$/;"	n	file:
dpdk_device	net/dpdk.cc	/^    dpdk_device(uint8_t port_idx, uint16_t num_queues, bool use_lro,$/;"	f	class:dpdk::dpdk_device
dpdk_device	net/dpdk.cc	/^class dpdk_device : public device {$/;"	c	namespace:dpdk	file:
dpdk_qp	net/dpdk.cc	/^class dpdk_qp : public net::qp {$/;"	c	namespace:dpdk	file:
dpdk_qp	net/dpdk.cc	/^dpdk_qp<HugetlbfsMemBackend>::dpdk_qp(dpdk_device* dev, uint8_t qid,$/;"	f	class:dpdk::dpdk_qp
dropped	net/dpdk.cc	/^            uint64_t dropped;      \/\/ missed packets (e.g. full FIFO)$/;"	m	struct:dpdk::port_stats::__anon9::__anon11	file:
from_mbuf	net/dpdk.cc	/^dpdk_qp<false>::from_mbuf(rte_mbuf* m)$/;"	f	class:dpdk::dpdk_qp
from_mbuf	net/dpdk.cc	/^inline std::experimental::optional<packet> dpdk_qp<true>::from_mbuf(rte_mbuf* m)$/;"	f	class:dpdk::dpdk_qp
from_mbuf_lro	net/dpdk.cc	/^dpdk_qp<false>::from_mbuf_lro(rte_mbuf* m)$/;"	f	class:dpdk::dpdk_qp
from_mbuf_lro	net/dpdk.cc	/^dpdk_qp<true>::from_mbuf_lro(rte_mbuf* m)$/;"	f	class:dpdk::dpdk_qp
from_packet	net/dpdk.cc	/^        static tx_buf* from_packet($/;"	f	class:dpdk::dpdk_qp::tx_buf	file:
from_packet_copy	net/dpdk.cc	/^        static tx_buf* from_packet_copy($/;"	f	class:dpdk::dpdk_qp::tx_buf
from_packet_zc	net/dpdk.cc	/^        static tx_buf* from_packet_zc($/;"	f	class:dpdk::dpdk_qp::tx_buf
gc	net/dpdk.cc	/^        bool gc() {$/;"	f	class:dpdk::dpdk_qp::tx_buf_factory
gc_count	net/dpdk.cc	/^        static constexpr int gc_count = 1;$/;"	m	class:dpdk::dpdk_qp::tx_buf_factory	file:
get	net/dpdk.cc	/^        tx_buf* get() {$/;"	f	class:dpdk::dpdk_qp::tx_buf_factory
get_dpdk_net_options_description	net/dpdk.cc	/^get_dpdk_net_options_description()$/;"	f
get_one_completed	net/dpdk.cc	/^        tx_buf* get_one_completed() {$/;"	f	class:dpdk::dpdk_qp::tx_buf_factory	file:
get_rss_table	net/dpdk.cc	/^void dpdk_device::get_rss_table()$/;"	f	class:dpdk::dpdk_device
get_tx_buf	net/dpdk.cc	/^    tx_buf* get_tx_buf() { return _tx_buf_factory.get(); }$/;"	f	class:dpdk::dpdk_qp
good	net/dpdk.cc	/^        } good;$/;"	m	struct:dpdk::port_stats::__anon12	typeref:struct:dpdk::port_stats::__anon12::__anon13	file:
good	net/dpdk.cc	/^        } good;$/;"	m	struct:dpdk::port_stats::__anon9	typeref:struct:dpdk::port_stats::__anon9::__anon10	file:
hw_features_ref	net/dpdk.cc	/^    net::hw_features& hw_features_ref() { return _hw_features; }$/;"	f	class:dpdk::dpdk_device
init_factory	net/dpdk.cc	/^        void init_factory() {$/;"	f	class:dpdk::dpdk_qp::tx_buf_factory	file:
init_local_queue	net/dpdk.cc	/^std::unique_ptr<qp> dpdk_device::init_local_queue(boost::program_options::variables_map opts, uint16_t qid) {$/;"	f	class:dpdk::dpdk_device
init_noninline_rx_mbuf	net/dpdk.cc	/^    static bool init_noninline_rx_mbuf(rte_mbuf* m,$/;"	f	class:dpdk::dpdk_qp	file:
init_port_fini	net/dpdk.cc	/^void dpdk_device::init_port_fini()$/;"	f	class:dpdk::dpdk_device
init_port_start	net/dpdk.cc	/^int dpdk_device::init_port_start()$/;"	f	class:dpdk::dpdk_device
init_rx_mbuf_pool	net/dpdk.cc	/^bool dpdk_qp<HugetlbfsMemBackend>::init_rx_mbuf_pool()$/;"	f	class:dpdk::dpdk_qp
inline_mbuf_data_size	net/dpdk.cc	/^static constexpr size_t   inline_mbuf_data_size  = 2048;$/;"	m	namespace:dpdk	file:
inline_mbuf_size	net/dpdk.cc	/^static constexpr uint16_t inline_mbuf_size       =$/;"	m	namespace:dpdk	file:
len	net/dpdk.cc	/^            uint64_t len;          \/\/ packets with a bad length$/;"	m	struct:dpdk::port_stats::__anon9::__anon11	file:
link_ready	net/dpdk.cc	/^    virtual future<> link_ready() { return _link_ready_promise.get_future(); }$/;"	f	class:dpdk::dpdk_device
max_frags	net/dpdk.cc	/^static constexpr uint8_t  max_frags              = 32 + 1;$/;"	m	namespace:dpdk	file:
mbuf_cache_size	net/dpdk.cc	/^static constexpr uint16_t mbuf_cache_size        = 512;$/;"	m	namespace:dpdk	file:
mbuf_data_size	net/dpdk.cc	/^static constexpr size_t   mbuf_data_size         = 2048;$/;"	m	namespace:dpdk	file:
mbuf_overhead	net/dpdk.cc	/^static constexpr uint16_t mbuf_overhead          =$/;"	m	namespace:dpdk	file:
mbufs_per_queue_rx	net/dpdk.cc	/^static constexpr uint16_t mbufs_per_queue_rx     = 2 * default_ring_size;$/;"	m	namespace:dpdk	file:
mbufs_per_queue_tx	net/dpdk.cc	/^static constexpr uint16_t mbufs_per_queue_tx     = 2 * default_ring_size;$/;"	m	namespace:dpdk	file:
mcast	net/dpdk.cc	/^            uint64_t mcast;        \/\/ number of received multicast packets$/;"	m	struct:dpdk::port_stats::__anon9::__anon10	file:
me	net/dpdk.cc	/^        static tx_buf* me(rte_mbuf* mbuf) {$/;"	f	class:dpdk::dpdk_qp::tx_buf
override	net/dpdk.cc	/^    virtual std::unique_ptr<qp> init_local_queue(boost::program_options::variables_map opts, uint16_t qid) override;$/;"	m	class:dpdk::dpdk_device	file:
override	net/dpdk.cc	/^    virtual void rx_start() override;$/;"	m	class:dpdk::dpdk_qp	file:
packet_read_size	net/dpdk.cc	/^static constexpr uint8_t packet_read_size        = 32;$/;"	m	namespace:dpdk	file:
page_mask	net/dpdk.cc	/^    static constexpr phys_addr_t page_mask = ~(memory::page_size - 1);$/;"	m	class:dpdk::dpdk_qp	file:
pause_xoff	net/dpdk.cc	/^            uint64_t pause_xoff;   \/\/ number of received PAUSE XOFF frames$/;"	m	struct:dpdk::port_stats::__anon9::__anon10	file:
pause_xoff	net/dpdk.cc	/^            uint64_t pause_xoff;  \/\/ number of sent PAUSE XOFF frames$/;"	m	struct:dpdk::port_stats::__anon12::__anon13	file:
pause_xon	net/dpdk.cc	/^            uint64_t pause_xon;    \/\/ number of received PAUSE XON frames$/;"	m	struct:dpdk::port_stats::__anon9::__anon10	file:
pause_xon	net/dpdk.cc	/^            uint64_t pause_xon;   \/\/ number of sent PAUSE XON frames$/;"	m	struct:dpdk::port_stats::__anon12::__anon13	file:
pktmbuf_pool_name	net/dpdk.cc	/^static constexpr const char* pktmbuf_pool_name   = "dpdk_net_pktmbuf_pool";$/;"	m	namespace:dpdk	file:
poll_rx_once	net/dpdk.cc	/^bool dpdk_qp<HugetlbfsMemBackend>::poll_rx_once()$/;"	f	class:dpdk::dpdk_qp
port	net/dpdk.cc	/^    dpdk_device& port() const { return *_dev; }$/;"	f	class:dpdk::dpdk_qp
port_idx	net/dpdk.cc	/^    uint8_t port_idx() { return _port_idx; }$/;"	f	class:dpdk::dpdk_device
port_stats	net/dpdk.cc	/^    port_stats() {$/;"	f	struct:dpdk::port_stats
port_stats	net/dpdk.cc	/^struct port_stats {$/;"	s	namespace:dpdk	file:
private_end	net/dpdk.cc	/^        MARKER private_end;$/;"	m	class:dpdk::dpdk_qp::tx_buf	file:
private_start	net/dpdk.cc	/^        MARKER private_start;$/;"	m	class:dpdk::dpdk_qp::tx_buf	file:
process_packets	net/dpdk.cc	/^void dpdk_qp<HugetlbfsMemBackend>::process_packets($/;"	f	class:dpdk::dpdk_qp
put	net/dpdk.cc	/^        void put(tx_buf* buf) {$/;"	f	class:dpdk::dpdk_qp::tx_buf_factory
qp_mempool_obj_size	net/dpdk.cc	/^uint32_t qp_mempool_obj_size(bool hugetlbfs_membackend)$/;"	f	namespace:dpdk
recycle	net/dpdk.cc	/^        void recycle() {$/;"	f	class:dpdk::dpdk_qp::tx_buf
refill_one_cluster	net/dpdk.cc	/^inline bool dpdk_qp<HugetlbfsMemBackend>::refill_one_cluster(rte_mbuf* head)$/;"	f	class:dpdk::dpdk_qp
refill_rx_mbuf	net/dpdk.cc	/^    static bool refill_rx_mbuf(rte_mbuf* m, size_t size = mbuf_data_size) {$/;"	f	class:dpdk::dpdk_qp	file:
reset_zc	net/dpdk.cc	/^        void reset_zc() {$/;"	f	class:dpdk::dpdk_qp::tx_buf
rte_mbuf_p	net/dpdk.cc	/^        rte_mbuf* rte_mbuf_p() { return &_mbuf; }$/;"	f	class:dpdk::dpdk_qp::tx_buf
rte_mbuf_to_baddr	net/dpdk.cc	/^rte_mbuf_to_baddr(rte_mbuf* mbuf) {$/;"	f	file:
rx	net/dpdk.cc	/^    } rx;$/;"	m	struct:dpdk::port_stats	typeref:struct:dpdk::port_stats::__anon9	file:
rx_gc	net/dpdk.cc	/^bool dpdk_qp<HugetlbfsMemBackend>::rx_gc()$/;"	f	class:dpdk::dpdk_qp
rx_gc_thresh	net/dpdk.cc	/^static constexpr uint16_t rx_gc_thresh           = 64;$/;"	m	namespace:dpdk	file:
rx_start	net/dpdk.cc	/^void dpdk_qp<HugetlbfsMemBackend>::rx_start() {$/;"	f	class:dpdk::dpdk_qp
set_hw_flow_control	net/dpdk.cc	/^void dpdk_device::set_hw_flow_control()$/;"	f	class:dpdk::dpdk_device
set_one_data_buf	net/dpdk.cc	/^        static size_t set_one_data_buf($/;"	f	class:dpdk::dpdk_qp::tx_buf	file:
set_packet	net/dpdk.cc	/^        void set_packet(packet&& p) {$/;"	f	class:dpdk::dpdk_qp::tx_buf
set_zc_info	net/dpdk.cc	/^        void set_zc_info(void* va, phys_addr_t pa, size_t len) {$/;"	f	class:dpdk::dpdk_qp::tx_buf
total	net/dpdk.cc	/^            uint64_t total;        \/\/ total number of erroneous received packets$/;"	m	struct:dpdk::port_stats::__anon9::__anon11	file:
total	net/dpdk.cc	/^            uint64_t total;   \/\/ total number of failed transmitted packets$/;"	m	struct:dpdk::port_stats::__anon12::__anon14	file:
translate_one_frag	net/dpdk.cc	/^        static bool translate_one_frag(dpdk_qp& qp, fragment& frag,$/;"	f	class:dpdk::dpdk_qp::tx_buf	file:
tx	net/dpdk.cc	/^    } tx;$/;"	m	struct:dpdk::port_stats	typeref:struct:dpdk::port_stats::__anon12	file:
tx_buf	net/dpdk.cc	/^        tx_buf(tx_buf_factory& fc) : _fc(fc) {$/;"	f	class:dpdk::dpdk_qp::tx_buf
tx_buf	net/dpdk.cc	/^    class tx_buf {$/;"	c	class:dpdk::dpdk_qp	file:
tx_buf_factory	net/dpdk.cc	/^        tx_buf_factory(uint8_t qid) {$/;"	f	class:dpdk::dpdk_qp::tx_buf_factory
tx_buf_factory	net/dpdk.cc	/^    class tx_buf_factory {$/;"	c	class:dpdk::dpdk_qp	file:
~dpdk_device	net/dpdk.cc	/^    ~dpdk_device() {$/;"	f	class:dpdk::dpdk_device
~dpdk_qp	net/dpdk.cc	/^    virtual ~dpdk_qp() {}$/;"	f	class:dpdk::dpdk_qp
_SEASTAR_DPDK_DEV_H	net/dpdk.hh	25;"	d
dpdk	net/dpdk.hh	/^namespace dpdk {$/;"	n
net	net/ethernet.cc	/^namespace net {$/;"	n	file:
operator <<	net/ethernet.cc	/^std::ostream& operator<<(std::ostream& os, ethernet_address ea) {$/;"	f	namespace:net
parse_ethernet_address	net/ethernet.cc	/^ethernet_address parse_ethernet_address(std::string addr)$/;"	f	namespace:net
ETHERNET_HH_	net/ethernet.hh	23;"	d
adjust_endianness	net/ethernet.hh	/^    auto adjust_endianness(Adjuster a) {$/;"	f	struct:net::eth_hdr
adjust_endianness	net/ethernet.hh	/^    void adjust_endianness(Adjuster a) {}$/;"	f	struct:net::ethernet_address
arp_hardware_type	net/ethernet.hh	/^    static constexpr uint16_t arp_hardware_type() { return 1; }$/;"	f	struct:net::ethernet
broadcast_address	net/ethernet.hh	/^    static address broadcast_address() {$/;"	f	struct:net::ethernet
dst_mac	net/ethernet.hh	/^    ethernet_address dst_mac;$/;"	m	struct:net::eth_hdr
eth_hdr	net/ethernet.hh	/^struct eth_hdr {$/;"	s	namespace:net
eth_proto	net/ethernet.hh	/^    packed<uint16_t> eth_proto;$/;"	m	struct:net::eth_hdr
ethernet	net/ethernet.hh	/^struct ethernet {$/;"	s	namespace:net
ethernet_address	net/ethernet.hh	/^    ethernet_address() {}$/;"	f	struct:net::ethernet_address
ethernet_address	net/ethernet.hh	/^    ethernet_address(const uint8_t *eaddr) {$/;"	f	struct:net::ethernet_address
ethernet_address	net/ethernet.hh	/^    ethernet_address(std::initializer_list<uint8_t> eaddr) {$/;"	f	struct:net::ethernet_address
ethernet_address	net/ethernet.hh	/^struct ethernet_address {$/;"	s	namespace:net
mac	net/ethernet.hh	/^    std::array<uint8_t, 6> mac;$/;"	m	struct:net::ethernet_address
net	net/ethernet.hh	/^namespace net {$/;"	n
src_mac	net/ethernet.hh	/^    ethernet_address src_mac;$/;"	m	struct:net::eth_hdr
_frag_high_thresh	net/ip.cc	/^constexpr uint32_t ipv4::_frag_high_thresh;$/;"	m	class:net::ipv4	file:
_frag_low_thresh	net/ip.cc	/^constexpr uint32_t ipv4::_frag_low_thresh;$/;"	m	class:net::ipv4	file:
_frag_timeout	net/ip.cc	/^constexpr std::chrono::seconds ipv4::_frag_timeout;$/;"	m	class:net::ipv4	file:
forward	net/ip.cc	/^bool ipv4::forward(forward_hash& out_hash_data, packet& p, size_t off)$/;"	f	class:net::ipv4
frag_drop	net/ip.cc	/^void ipv4::frag_drop(ipv4_frag_id frag_id, uint32_t dropped_size) {$/;"	f	class:net::ipv4
frag_limit_mem	net/ip.cc	/^void ipv4::frag_limit_mem() {$/;"	f	class:net::ipv4
frag_timeout	net/ip.cc	/^void ipv4::frag_timeout() {$/;"	f	class:net::ipv4
get_assembled_packet	net/ip.cc	/^packet ipv4::frag::get_assembled_packet(ethernet_address from, ethernet_address to) {$/;"	f	class:net::ipv4::frag
get_l2_dst_address	net/ip.cc	/^future<ethernet_address> ipv4::get_l2_dst_address(ipv4_address to) {$/;"	f	class:net::ipv4
get_packet	net/ip.cc	/^std::experimental::optional<l3_protocol::l3packet> ipv4::get_packet() {$/;"	f	class:net::ipv4
gw_address	net/ip.cc	/^ipv4_address ipv4::gw_address() const {$/;"	f	class:net::ipv4
handle_received_packet	net/ip.cc	/^ipv4::handle_received_packet(packet p, ethernet_address from) {$/;"	f	class:net::ipv4
host_address	net/ip.cc	/^ipv4_address ipv4::host_address() {$/;"	f	class:net::ipv4
in_my_netmask	net/ip.cc	/^bool ipv4::in_my_netmask(ipv4_address a) const {$/;"	f	class:net::ipv4
ipv4	net/ip.cc	/^ipv4::ipv4(interface* netif)$/;"	f	class:net::ipv4
is_complete	net/ip.cc	/^bool ipv4::frag::is_complete() {$/;"	f	class:net::ipv4::frag
merge	net/ip.cc	/^int32_t ipv4::frag::merge(ip_hdr &h, uint16_t offset, packet p) {$/;"	f	class:net::ipv4::frag
needs_frag	net/ip.cc	/^bool ipv4::needs_frag(packet& p, ip_protocol_num prot_num, net::hw_features hw_features) {$/;"	f	class:net::ipv4
net	net/ip.cc	/^namespace net {$/;"	n	file:
netmask_address	net/ip.cc	/^ipv4_address ipv4::netmask_address() const {$/;"	f	class:net::ipv4
operator <<	net/ip.cc	/^std::ostream& operator<<(std::ostream& os, ipv4_address a) {$/;"	f	namespace:net
packet_filter	net/ip.cc	/^ip_packet_filter * ipv4::packet_filter() const {$/;"	f	class:net::ipv4
received	net/ip.cc	/^void icmp::received(packet p, ipaddr from, ipaddr to) {$/;"	f	class:net::icmp
send	net/ip.cc	/^void ipv4::send(ipv4_address to, ip_protocol_num proto_num, packet p, ethernet_address e_dst) {$/;"	f	class:net::ipv4
set_gw_address	net/ip.cc	/^void ipv4::set_gw_address(ipv4_address ip) {$/;"	f	class:net::ipv4
set_host_address	net/ip.cc	/^void ipv4::set_host_address(ipv4_address ip) {$/;"	f	class:net::ipv4
set_netmask_address	net/ip.cc	/^void ipv4::set_netmask_address(ipv4_address ip) {$/;"	f	class:net::ipv4
set_packet_filter	net/ip.cc	/^void ipv4::set_packet_filter(ip_packet_filter * f) {$/;"	f	class:net::ipv4
IP_HH_	net/ip.hh	24;"	d
_arp	net/ip.hh	/^    arp_for<ipv4> _arp;$/;"	m	class:net::ipv4
_channels	net/ip.hh	/^    std::unordered_map<uint16_t, lw_shared_ptr<udp_channel_state>> _channels;$/;"	m	class:net::ipv4_udp
_frag_timer	net/ip.hh	/^    timer<lowres_clock> _frag_timer;$/;"	m	class:net::ipv4
_frags	net/ip.hh	/^    std::unordered_map<ipv4_frag_id, frag, ipv4_frag_id::hash> _frags;$/;"	m	class:net::ipv4
_frags_age	net/ip.hh	/^    std::list<ipv4_frag_id> _frags_age;$/;"	m	class:net::ipv4
_global_arp	net/ip.hh	/^    arp _global_arp;$/;"	m	class:net::ipv4
_gw_address	net/ip.hh	/^    ipv4_address _gw_address;$/;"	m	class:net::ipv4
_host_address	net/ip.hh	/^    ipv4_address _host_address;$/;"	m	class:net::ipv4
_icmp	net/ip.hh	/^    icmp _icmp;$/;"	m	class:net::final
_icmp	net/ip.hh	/^    ipv4_icmp _icmp;$/;"	m	class:net::ipv4
_inet	net/ip.hh	/^    inet_type& _inet;$/;"	m	class:net::icmp
_inet	net/ip.hh	/^    ipv4 &_inet;$/;"	m	class:net::ipv4_udp
_inet	net/ip.hh	/^    ipv4& _inet;$/;"	m	class:net::ipv4_l4
_inet_l4	net/ip.hh	/^    ipv4_l4<ip_protocol_num::icmp> _inet_l4;$/;"	m	class:net::final
_inet_l4	net/ip.hh	/^    ipv4_l4<ip_protocol_num::tcp> _inet_l4;$/;"	m	class:net::final
_l3	net/ip.hh	/^    l3_protocol _l3;$/;"	m	class:net::ipv4
_l4	net/ip.hh	/^    array_map<ip_protocol*, 256> _l4;$/;"	m	class:net::ipv4
_netif	net/ip.hh	/^    interface* _netif;$/;"	m	class:net::ipv4
_netmask	net/ip.hh	/^    ipv4_address _netmask;$/;"	m	class:net::ipv4
_next_anonymous_port	net/ip.hh	/^    uint16_t _next_anonymous_port = min_anonymous_port;$/;"	m	class:net::ipv4_udp
_packet_filter	net/ip.hh	/^    ip_packet_filter * _packet_filter = nullptr;$/;"	m	class:net::ipv4
_packetq	net/ip.hh	/^    circular_buffer<ipv4_traits::l4packet> _packetq;$/;"	m	class:net::icmp
_packetq	net/ip.hh	/^    circular_buffer<l3_protocol::l3packet> _packetq;$/;"	m	class:net::ipv4
_packetq	net/ip.hh	/^    circular_buffer<std::tuple<ipv4_traits::l4packet, lw_shared_ptr<udp_channel_state>, size_t>> _packetq;$/;"	m	class:net::ipv4_udp
_pkt_provider_idx	net/ip.hh	/^    unsigned _pkt_provider_idx = 0;$/;"	m	class:net::ipv4
_pkt_providers	net/ip.hh	/^    std::vector<ipv4_traits::packet_provider_type> _pkt_providers;$/;"	m	class:net::ipv4
_port	net/ip.hh	/^        uint16_t _port;$/;"	m	class:net::ipv4_udp::registration
_proto	net/ip.hh	/^        ipv4_udp &_proto;$/;"	m	class:net::ipv4_udp::registration
_queue_size	net/ip.hh	/^    int _queue_size = default_queue_size;$/;"	m	class:net::ipv4_udp
_queue_space	net/ip.hh	/^    semaphore _queue_space = {212992};$/;"	m	class:net::icmp
_rx_packets	net/ip.hh	/^    subscription<packet, ethernet_address> _rx_packets;$/;"	m	class:net::ipv4
_tcp	net/ip.hh	/^    ipv4_tcp _tcp;$/;"	m	class:net::ipv4
_tcp	net/ip.hh	/^    std::unique_ptr<tcp<ipv4_traits>> _tcp;$/;"	m	class:net::final
_udp	net/ip.hh	/^    ipv4_udp _udp;$/;"	m	class:net::ipv4
adjust_endianness	net/ip.hh	/^    auto adjust_endianness(Adjuster a) { return a(ip); }$/;"	f	struct:net::ipv4_address
adjust_endianness	net/ip.hh	/^    auto adjust_endianness(Adjuster a) {$/;"	f	class:net::ip_hdr::frag_bits
adjust_endianness	net/ip.hh	/^    auto adjust_endianness(Adjuster a) {$/;"	f	struct:net::icmp_hdr
arp_protocol_type	net/ip.hh	/^    static proto_type arp_protocol_type() { return proto_type(eth_protocol_num::ipv4); }$/;"	f	class:net::ipv4
broadcast_address	net/ip.hh	/^    static address_type broadcast_address() { return ipv4_address(0xffffffff); }$/;"	f	class:net::ipv4
code	net/ip.hh	/^    uint8_t code;$/;"	m	struct:net::icmp_hdr
connid_hash	net/ip.hh	/^struct l4connid<InetTraits>::connid_hash : private std::hash<ipaddr>, private std::hash<uint16_t> {$/;"	s	class:net::ip_hdr::l4connid
csum	net/ip.hh	/^    packed<uint16_t> csum;$/;"	m	class:net::ip_hdr::frag_bits
csum	net/ip.hh	/^    packed<uint16_t> csum;$/;"	m	struct:net::icmp_hdr
data	net/ip.hh	/^        packet_merger<uint32_t> data;$/;"	m	struct:net::ipv4::frag
default_queue_size	net/ip.hh	/^    static const int default_queue_size;$/;"	m	class:net::ipv4_udp
df	net/ip.hh	/^    bool df() { return frag & (1 << uint8_t(frag_bits::df)); }$/;"	f	class:net::ip_hdr::frag_bits
df	net/ip.hh	/^    enum class frag_bits : uint8_t { mf = 13, df = 14, reserved = 15, offset_shift = 3 };$/;"	m	class:net::ip_hdr::frag_bits
dscp	net/ip.hh	/^    uint8_t dscp : 6;$/;"	m	struct:net::ip_hdr
dst_ip	net/ip.hh	/^    ipv4_address dst_ip;$/;"	m	class:net::ip_hdr::frag_bits
dst_ip	net/ip.hh	/^    ipv4_address dst_ip;$/;"	m	struct:net::ipv4_frag_id
e_dst	net/ip.hh	/^        ethernet_address e_dst;$/;"	m	struct:net::ipv4_traits::l4packet
echo_reply	net/ip.hh	/^        echo_reply = 0,$/;"	m	class:net::icmp_hdr::msg_type
echo_request	net/ip.hh	/^        echo_request = 8,$/;"	m	class:net::icmp_hdr::msg_type
ecn	net/ip.hh	/^    uint8_t ecn : 2;$/;"	m	struct:net::ip_hdr
final	net/ip.hh	/^class ipv4_icmp final : public ip_protocol {$/;"	c	namespace:net
final	net/ip.hh	/^class ipv4_tcp final : public ip_protocol {$/;"	c	namespace:net
foreign_ip	net/ip.hh	/^    ipaddr foreign_ip;$/;"	m	struct:net::l4connid
foreign_port	net/ip.hh	/^    uint16_t foreign_port;$/;"	m	struct:net::l4connid
forward	net/ip.hh	/^    virtual bool forward(forward_hash& out_hash_data, packet& p, size_t off) { return true; }$/;"	f	class:net::ip_protocol
frag	net/ip.hh	/^    packed<uint16_t> frag;$/;"	m	struct:net::ip_hdr
frag	net/ip.hh	/^    struct frag {$/;"	s	class:net::ipv4
frag_arm	net/ip.hh	/^    void frag_arm() {$/;"	f	class:net::ipv4
frag_arm	net/ip.hh	/^    void frag_arm(clock_type::time_point now) {$/;"	f	class:net::ipv4
frag_bits	net/ip.hh	/^    enum class frag_bits : uint8_t { mf = 13, df = 14, reserved = 15, offset_shift = 3 };$/;"	c	struct:net::ip_hdr
get_l2_dst_address	net/ip.hh	/^future<ethernet_address> ipv4_l4<ProtoNum>::get_l2_dst_address(ipv4_address to) {$/;"	f	class:net::ipv4_l4
get_tcp	net/ip.hh	/^    tcp<ipv4_traits>& get_tcp() { return *_tcp._tcp; }$/;"	f	class:net::ipv4
get_udp	net/ip.hh	/^    ipv4_udp& get_udp() { return _udp; }$/;"	f	class:net::ipv4
hash	net/ip.hh	/^    uint32_t hash() {$/;"	f	struct:net::l4connid
hash	net/ip.hh	/^struct hash<net::ipv4_address> {$/;"	s	namespace:std
hash	net/ip.hh	/^struct ipv4_frag_id::hash : private std::hash<ipv4_address>,$/;"	s	class:net::ipv4_frag_id
header	net/ip.hh	/^        packet header;$/;"	m	struct:net::ipv4::frag
hw_features	net/ip.hh	/^    const net::hw_features& hw_features() const { return _netif->hw_features(); }$/;"	f	class:net::ipv4
icmp	net/ip.hh	/^    explicit icmp(inet_type& inet) : _inet(inet) {$/;"	f	class:net::icmp
icmp	net/ip.hh	/^class icmp {$/;"	c	namespace:net
icmp_hdr	net/ip.hh	/^struct icmp_hdr {$/;"	s	namespace:net
id	net/ip.hh	/^    packed<uint16_t> id;$/;"	m	struct:net::ip_hdr
identification	net/ip.hh	/^    uint16_t identification;$/;"	m	struct:net::ipv4_frag_id
ihl	net/ip.hh	/^    uint8_t ihl : 4;$/;"	m	struct:net::ip_hdr
ip	net/ip.hh	/^    packed<uint32_t> ip;$/;"	m	struct:net::ipv4_address
ip_hdr	net/ip.hh	/^struct ip_hdr {$/;"	s	namespace:net
ip_hdr_len_min	net/ip.hh	/^    static constexpr uint8_t ip_hdr_len_min = net::ipv4_hdr_len_min;$/;"	m	struct:net::ipv4_traits
ip_packet_filter	net/ip.hh	/^struct ip_packet_filter {$/;"	s	namespace:net
ip_proto	net/ip.hh	/^    uint8_t ip_proto;$/;"	m	class:net::ip_hdr::frag_bits
ip_protocol	net/ip.hh	/^class ip_protocol {$/;"	c	namespace:net
ipv4	net/ip.hh	/^class ipv4 {$/;"	c	namespace:net
ipv4_address	net/ip.hh	/^    explicit ipv4_address(const std::string& addr) {$/;"	f	struct:net::ipv4_address
ipv4_address	net/ip.hh	/^    explicit ipv4_address(uint32_t ip) : ip(ip) {}$/;"	f	struct:net::ipv4_address
ipv4_address	net/ip.hh	/^    ipv4_address() : ip(0) {}$/;"	f	struct:net::ipv4_address
ipv4_address	net/ip.hh	/^    ipv4_address(ipv4_addr addr) {$/;"	f	struct:net::ipv4_address
ipv4_address	net/ip.hh	/^struct ipv4_address {$/;"	s	namespace:net
ipv4_frag_id	net/ip.hh	/^struct ipv4_frag_id {$/;"	s	namespace:net
ipv4_icmp	net/ip.hh	/^    ipv4_icmp(ipv4& inet) : _inet_l4(inet), _icmp(_inet_l4) {}$/;"	f	class:net::final
ipv4_l4	net/ip.hh	/^    ipv4_l4(ipv4& inet) : _inet(inet) {}$/;"	f	class:net::ipv4_l4
ipv4_l4	net/ip.hh	/^class ipv4_l4 {$/;"	c	namespace:net
ipv4_traits	net/ip.hh	/^struct ipv4_traits {$/;"	s	namespace:net
ipv4_udp	net/ip.hh	/^class ipv4_udp : public ip_protocol {$/;"	c	namespace:net
is_unspecified	net/ip.hh	/^static inline bool is_unspecified(ipv4_address addr) { return addr.ip == 0; }$/;"	f	namespace:net
l4connid	net/ip.hh	/^struct l4connid {$/;"	s	namespace:net
l4packet	net/ip.hh	/^    struct l4packet {$/;"	s	struct:net::ipv4_traits
last_frag_received	net/ip.hh	/^        bool last_frag_received = false;$/;"	m	struct:net::ipv4::frag
learn	net/ip.hh	/^    void learn(ethernet_address l2, ipv4_address l3) {$/;"	f	class:net::ipv4
len	net/ip.hh	/^    packed<uint16_t> len;$/;"	m	struct:net::ip_hdr
local_ip	net/ip.hh	/^    ipaddr local_ip;$/;"	m	struct:net::l4connid
local_port	net/ip.hh	/^    uint16_t local_port;$/;"	m	struct:net::l4connid
mem_size	net/ip.hh	/^        uint32_t mem_size = 0;$/;"	m	struct:net::ipv4::frag
mf	net/ip.hh	/^    bool mf() { return frag & (1 << uint8_t(frag_bits::mf)); }$/;"	f	class:net::ip_hdr::frag_bits
mf	net/ip.hh	/^    enum class frag_bits : uint8_t { mf = 13, df = 14, reserved = 15, offset_shift = 3 };$/;"	m	class:net::ip_hdr::frag_bits
min_anonymous_port	net/ip.hh	/^    static const uint16_t min_anonymous_port = 32768;$/;"	m	class:net::ipv4_udp
msg_type	net/ip.hh	/^    enum class msg_type : uint8_t {$/;"	c	struct:net::icmp_hdr
net	net/ip.hh	/^namespace net {$/;"	n
netif	net/ip.hh	/^    interface * netif() const {$/;"	f	class:net::ipv4
offset	net/ip.hh	/^    uint16_t offset() { return frag << uint8_t(frag_bits::offset_shift); }$/;"	f	class:net::ip_hdr::frag_bits
offset_shift	net/ip.hh	/^    enum class frag_bits : uint8_t { mf = 13, df = 14, reserved = 15, offset_shift = 3 };$/;"	m	class:net::ip_hdr::frag_bits
operator !=	net/ip.hh	/^    friend bool operator!=(ipv4_address x, ipv4_address y) {$/;"	f	struct:net::ipv4_address
operator ()	net/ip.hh	/^    size_t operator()(net::ipv4_address a) const { return a.ip; }$/;"	f	struct:std::hash
operator ==	net/ip.hh	/^    bool operator==(const ipv4_frag_id& x) const {$/;"	f	struct:net::ipv4_frag_id
operator ==	net/ip.hh	/^    bool operator==(const l4connid& x) const {$/;"	f	struct:net::l4connid
operator ==	net/ip.hh	/^    friend bool operator==(ipv4_address x, ipv4_address y) {$/;"	f	struct:net::ipv4_address
options	net/ip.hh	/^    uint8_t options[0];$/;"	m	class:net::ip_hdr::frag_bits
override	net/ip.hh	/^    bool forward(forward_hash& out_hash_data, packet& p, size_t off) override;$/;"	m	class:net::ipv4_udp
override	net/ip.hh	/^    virtual bool forward(forward_hash& out_hash_data, packet& p, size_t off) override;$/;"	m	class:net::final
override	net/ip.hh	/^    virtual void received(packet p, ipv4_address from, ipv4_address to) override;$/;"	m	class:net::ipv4_udp
p	net/ip.hh	/^        packet p;$/;"	m	struct:net::ipv4_traits::l4packet
port	net/ip.hh	/^        uint16_t port() const {$/;"	f	class:net::ipv4_udp::registration
proto_num	net/ip.hh	/^        ip_protocol_num proto_num;$/;"	m	struct:net::ipv4_traits::l4packet
protocol	net/ip.hh	/^    uint8_t protocol;$/;"	m	struct:net::ipv4_frag_id
received	net/ip.hh	/^    virtual void received(packet p, ipv4_address from, ipv4_address to) {$/;"	f	class:net::final
register_packet_provider	net/ip.hh	/^    void register_packet_provider(ipv4_traits::packet_provider_type&& func) {$/;"	f	class:net::ipv4
register_packet_provider	net/ip.hh	/^void ipv4_l4<ProtoNum>::register_packet_provider(ipv4_traits::packet_provider_type func) {$/;"	f	class:net::ipv4_l4
registration	net/ip.hh	/^        registration(ipv4_udp &proto, uint16_t port) : _proto(proto), _port(port) {};$/;"	f	class:net::ipv4_udp::registration
registration	net/ip.hh	/^    class registration {$/;"	c	class:net::ipv4_udp
reserved	net/ip.hh	/^    enum class frag_bits : uint8_t { mf = 13, df = 14, reserved = 15, offset_shift = 3 };$/;"	m	class:net::ip_hdr::frag_bits
rest	net/ip.hh	/^    packed<uint32_t> rest;$/;"	m	struct:net::icmp_hdr
rx_time	net/ip.hh	/^        clock_type::time_point rx_time;$/;"	m	struct:net::ipv4::frag
set_queue_size	net/ip.hh	/^    void set_queue_size(int size) { _queue_size = size; }$/;"	f	class:net::ipv4_udp
src_ip	net/ip.hh	/^    ipv4_address src_ip;$/;"	m	class:net::ip_hdr::frag_bits
src_ip	net/ip.hh	/^    ipv4_address src_ip;$/;"	m	struct:net::ipv4_frag_id
std	net/ip.hh	/^namespace std {$/;"	n
tcp_pseudo_header_checksum	net/ip.hh	/^    static void tcp_pseudo_header_checksum(checksummer& csum, ipv4_address src, ipv4_address dst, uint16_t len) {$/;"	f	struct:net::ipv4_traits
to	net/ip.hh	/^        ipv4_address to;$/;"	m	struct:net::ipv4_traits::l4packet
ttl	net/ip.hh	/^    uint8_t ttl;$/;"	m	class:net::ip_hdr::frag_bits
type	net/ip.hh	/^    msg_type type;$/;"	m	struct:net::icmp_hdr
udp_pseudo_header_checksum	net/ip.hh	/^    static void udp_pseudo_header_checksum(checksummer& csum, ipv4_address src, ipv4_address dst, uint16_t len) {$/;"	f	struct:net::ipv4_traits
unregister	net/ip.hh	/^        void unregister() {$/;"	f	class:net::ipv4_udp::registration
ver	net/ip.hh	/^    uint8_t ver : 4;$/;"	m	struct:net::ip_hdr
~ip_packet_filter	net/ip.hh	/^    virtual ~ip_packet_filter() {};$/;"	f	struct:net::ip_packet_filter
~ip_protocol	net/ip.hh	/^    virtual ~ip_protocol() {}$/;"	f	class:net::ip_protocol
get	net/ip_checksum.cc	/^uint16_t checksummer::get() const {$/;"	f	class:net::checksummer
ip_checksum	net/ip_checksum.cc	/^uint16_t ip_checksum(const void* data, size_t len) {$/;"	f	namespace:net
net	net/ip_checksum.cc	/^namespace net {$/;"	n	file:
sum	net/ip_checksum.cc	/^void checksummer::sum(const char* data, size_t len) {$/;"	f	class:net::checksummer
sum	net/ip_checksum.cc	/^void checksummer::sum(const packet& p) {$/;"	f	class:net::checksummer
IP_CHECKSUM_HH_	net/ip_checksum.hh	23;"	d
checksummer	net/ip_checksum.hh	/^struct checksummer {$/;"	s	namespace:net
csum	net/ip_checksum.hh	/^    __int128 csum = 0;$/;"	m	struct:net::checksummer
net	net/ip_checksum.hh	/^namespace net {$/;"	n
odd	net/ip_checksum.hh	/^    bool odd = false;$/;"	m	struct:net::checksummer
sum	net/ip_checksum.hh	/^    void sum(uint16_t data) {$/;"	f	struct:net::checksummer
sum	net/ip_checksum.hh	/^    void sum(uint32_t data) {$/;"	f	struct:net::checksummer
sum	net/ip_checksum.hh	/^    void sum(uint8_t data) {$/;"	f	struct:net::checksummer
sum_many	net/ip_checksum.hh	/^    void sum_many() {}$/;"	f	struct:net::checksummer
sum_many	net/ip_checksum.hh	/^    void sum_many(T0 data, T... rest) {$/;"	f	struct:net::checksummer
NET_NATIVE_STACK_IMPL_HH_	net/native-stack-impl.hh	23;"	d
_buf	net/native-stack-impl.hh	/^    packet _buf;$/;"	m	class:net::final
_conn	net/native-stack-impl.hh	/^    typename Protocol::connection _conn;$/;"	m	class:net::native_connected_socket_impl
_conn	net/native-stack-impl.hh	/^    typename Protocol::connection& _conn;$/;"	m	class:net::final
_cur_frag	net/native-stack-impl.hh	/^    size_t _cur_frag = 0;$/;"	m	class:net::final
_eof	net/native-stack-impl.hh	/^    bool _eof = false;$/;"	m	class:net::final
_listener	net/native-stack-impl.hh	/^    typename Protocol::listener _listener;$/;"	m	class:net::native_server_socket_impl
abort_accept	net/native-stack-impl.hh	/^native_server_socket_impl<Protocol>::abort_accept() {$/;"	f	class:net::native_server_socket_impl
accept	net/native-stack-impl.hh	/^native_server_socket_impl<Protocol>::accept() {$/;"	f	class:net::native_server_socket_impl
final	net/native-stack-impl.hh	/^class native_connected_socket_impl<Protocol>::native_data_sink_impl final$/;"	c	namespace:net
final	net/native-stack-impl.hh	/^class native_connected_socket_impl<Protocol>::native_data_source_impl final$/;"	c	namespace:net
input	net/native-stack-impl.hh	/^native_connected_socket_impl<Protocol>::input() {$/;"	f	class:net::native_connected_socket_impl
kj_accept	net/native-stack-impl.hh	/^native_server_socket_impl<Protocol>::kj_accept() {$/;"	f	class:net::native_server_socket_impl
native_connected_socket_impl	net/native-stack-impl.hh	/^    explicit native_connected_socket_impl(typename Protocol::connection conn)$/;"	f	class:net::native_connected_socket_impl
native_connected_socket_impl	net/native-stack-impl.hh	/^class native_connected_socket_impl : public connected_socket_impl {$/;"	c	namespace:net
native_data_sink_impl	net/native-stack-impl.hh	/^    explicit native_data_sink_impl(typename Protocol::connection& conn)$/;"	f	class:net::final
native_data_source_impl	net/native-stack-impl.hh	/^    explicit native_data_source_impl(typename Protocol::connection& conn)$/;"	f	class:net::final
native_server_socket_impl	net/native-stack-impl.hh	/^class native_server_socket_impl : public server_socket_impl {$/;"	c	namespace:net
native_server_socket_impl	net/native-stack-impl.hh	/^native_server_socket_impl<Protocol>::native_server_socket_impl(Protocol& proto, uint16_t port, listen_options opt)$/;"	f	class:net::native_server_socket_impl
net	net/native-stack-impl.hh	/^namespace net {$/;"	n
output	net/native-stack-impl.hh	/^native_connected_socket_impl<Protocol>::output() {$/;"	f	class:net::native_connected_socket_impl
override	net/native-stack-impl.hh	/^    virtual future<connected_socket, socket_address> accept() override;$/;"	m	class:net::native_server_socket_impl
override	net/native-stack-impl.hh	/^    virtual input_stream<char> input() override;$/;"	m	class:net::native_connected_socket_impl
override	net/native-stack-impl.hh	/^    virtual kj::Promise<std::pair<connected_socket, socket_address>> kj_accept() override;$/;"	m	class:net::native_server_socket_impl
override	net/native-stack-impl.hh	/^    virtual output_stream<char> output() override;$/;"	m	class:net::native_connected_socket_impl
override	net/native-stack-impl.hh	/^    virtual void abort_accept() override;$/;"	m	class:net::native_server_socket_impl
override	net/native-stack-impl.hh	/^    virtual void shutdown_input() override;$/;"	m	class:net::native_connected_socket_impl
override	net/native-stack-impl.hh	/^    virtual void shutdown_output() override;$/;"	m	class:net::native_connected_socket_impl
shutdown_input	net/native-stack-impl.hh	/^native_connected_socket_impl<Protocol>::shutdown_input() {$/;"	f	class:net::native_connected_socket_impl
shutdown_output	net/native-stack-impl.hh	/^native_connected_socket_impl<Protocol>::shutdown_output() {$/;"	f	class:net::native_connected_socket_impl
_config	net/native-stack.cc	/^    promise<> _config;$/;"	m	class:net::native_network_stack	file:
_dhcp	net/native-stack.cc	/^    bool _dhcp = false;$/;"	m	class:net::native_network_stack	file:
_inet	net/native-stack.cc	/^    ipv4 _inet;$/;"	m	class:net::native_network_stack	file:
_netif	net/native-stack.cc	/^    interface _netif;$/;"	m	class:net::native_network_stack	file:
_timer	net/native-stack.cc	/^    timer<> _timer;$/;"	m	class:net::native_network_stack	file:
add_native_net_options_description	net/native-stack.cc	/^add_native_net_options_description(boost::program_options::options_description &opts) {$/;"	f	namespace:net
arp_learn	net/native-stack.cc	/^    void arp_learn(ethernet_address l2, ipv4_address l3) {$/;"	f	class:net::native_network_stack
arp_learn	net/native-stack.cc	/^void arp_learn(ethernet_address l2, ipv4_address l3)$/;"	f	namespace:net
connect	net/native-stack.cc	/^native_network_stack::connect(socket_address sa, socket_address local) {$/;"	f	class:net::native_network_stack
create	net/native-stack.cc	/^    static future<std::unique_ptr<network_stack>> create(boost::program_options::variables_map opts) {$/;"	f	class:net::native_network_stack
create_native_net_device	net/native-stack.cc	/^void create_native_net_device(boost::program_options::variables_map opts) {$/;"	f	namespace:net
create_native_stack	net/native-stack.cc	/^void create_native_stack(boost::program_options::variables_map opts, std::shared_ptr<device> dev) {$/;"	f	namespace:net
initialize	net/native-stack.cc	/^future<> native_network_stack::initialize() {$/;"	f	class:net::native_network_stack
is_xen	net/native-stack.cc	/^static xen_info is_xen()$/;"	f	namespace:net
kj_connect	net/native-stack.cc	/^native_network_stack::kj_connect(socket_address sa, socket_address local) {$/;"	f	class:net::native_network_stack
listen	net/native-stack.cc	/^native_network_stack::listen(socket_address sa, listen_options opts) {$/;"	f	class:net::native_network_stack
make_udp_channel	net/native-stack.cc	/^native_network_stack::make_udp_channel(ipv4_addr addr) {$/;"	f	class:net::native_network_stack
native_network_stack	net/native-stack.cc	/^class native_network_stack : public network_stack {$/;"	c	namespace:net	file:
native_network_stack	net/native-stack.cc	/^native_network_stack::native_network_stack(boost::program_options::variables_map opts, std::shared_ptr<device> dev)$/;"	f	class:net::native_network_stack
net	net/native-stack.cc	/^namespace net {$/;"	n	file:
nns_options	net/native-stack.cc	/^boost::program_options::options_description nns_options() {$/;"	f	namespace:net
nonxen	net/native-stack.cc	/^    nonxen = 0,$/;"	m	class:net::xen_info	file:
on_dhcp	net/native-stack.cc	/^void native_network_stack::on_dhcp(bool success, const dhcp::lease & res, bool is_renew) {$/;"	f	class:net::native_network_stack
osv	net/native-stack.cc	/^    osv = 2,$/;"	m	class:net::xen_info	file:
override	net/native-stack.cc	/^    virtual future<> initialize() override;$/;"	m	class:net::native_network_stack	file:
override	net/native-stack.cc	/^    virtual future<connected_socket> connect(socket_address sa, socket_address local) override;$/;"	m	class:net::native_network_stack	file:
override	net/native-stack.cc	/^    virtual kj::Promise<connected_socket> kj_connect(socket_address sa, socket_address local = socket_address(::sockaddr_in{AF_INET, INADDR_ANY, 0})) override;$/;"	m	class:net::native_network_stack	file:
override	net/native-stack.cc	/^    virtual server_socket listen(socket_address sa, listen_options opt) override;$/;"	m	class:net::native_network_stack	file:
override	net/native-stack.cc	/^    virtual udp_channel make_udp_channel(ipv4_addr addr) override;$/;"	m	class:net::native_network_stack	file:
ready_promise	net/native-stack.cc	/^    static thread_local promise<std::unique_ptr<network_stack>> ready_promise;$/;"	m	class:net::native_network_stack	file:
ready_promise	net/native-stack.cc	/^thread_local promise<std::unique_ptr<network_stack>> native_network_stack::ready_promise;$/;"	m	class:net::native_network_stack	file:
run_dhcp	net/native-stack.cc	/^future<> native_network_stack::run_dhcp(bool is_renew, const dhcp::lease& res) {$/;"	f	class:net::native_network_stack
set_ipv4_packet_filter	net/native-stack.cc	/^    void set_ipv4_packet_filter(ip_packet_filter* filter) {$/;"	f	class:net::native_network_stack	file:
userspace	net/native-stack.cc	/^    userspace = 1,$/;"	m	class:net::xen_info	file:
xen_info	net/native-stack.cc	/^enum class xen_info {$/;"	c	namespace:net	file:
STACK_HH_	net/native-stack.hh	23;"	d
net	net/native-stack.hh	/^namespace net {$/;"	n
build_sw_reta	net/net.cc	/^void qp::build_sw_reta(const std::map<unsigned, float>& cpu_weights) {$/;"	f	class:net::qp
configure_proxies	net/net.cc	/^void qp::configure_proxies(const std::map<unsigned, float>& cpu_weights) {$/;"	f	class:net::qp
dispatch_packet	net/net.cc	/^future<> interface::dispatch_packet(packet p) {$/;"	f	class:net::interface
forward	net/net.cc	/^void interface::forward(unsigned cpuid, packet p) {$/;"	f	class:net::interface
hash2cpu	net/net.cc	/^unsigned interface::hash2cpu(uint32_t hash) {$/;"	f	class:net::interface
interface	net/net.cc	/^interface::interface(std::shared_ptr<device> dev)$/;"	f	class:net::interface
ipv4_addr	net/net.cc	/^ipv4_addr::ipv4_addr(const std::string &addr) {$/;"	f	class:ipv4_addr
ipv4_addr	net/net.cc	/^ipv4_addr::ipv4_addr(const std::string &addr, uint16_t port_) : ip(boost::asio::ip::address_v4::from_string(addr).to_ulong()), port(port_) {}$/;"	f	class:ipv4_addr
l3_protocol	net/net.cc	/^l3_protocol::l3_protocol(interface* netif, eth_protocol_num proto_num, packet_provider_type func)$/;"	f	class:net::l3_protocol
net	net/net.cc	/^namespace net {$/;"	n	file:
poll_tx	net/net.cc	/^bool qp::poll_tx() {$/;"	f	class:net::qp
qp	net/net.cc	/^qp::qp(bool register_copy_stats,$/;"	f	class:net::qp
receive	net/net.cc	/^device::receive(std::function<future<> (packet)> next_packet) {$/;"	f	class:net::device
receive	net/net.cc	/^subscription<packet, ethernet_address> l3_protocol::receive($/;"	f	class:net::l3_protocol
register_l3	net/net.cc	/^interface::register_l3(eth_protocol_num proto_num,$/;"	f	class:net::interface
set_local_queue	net/net.cc	/^void device::set_local_queue(std::unique_ptr<qp> dev) {$/;"	f	class:net::device
~qp	net/net.cc	/^qp::~qp() {$/;"	f	class:net::qp
NET_HH_	net/net.hh	23;"	d
_collectd_regs	net/net.hh	/^    scollectd::registrations _collectd_regs;$/;"	m	class:net::qp
_dev	net/net.hh	/^    std::shared_ptr<device> _dev;$/;"	m	class:net::interface
_hw_address	net/net.hh	/^    ethernet_address _hw_address;$/;"	m	class:net::interface
_hw_features	net/net.hh	/^    net::hw_features _hw_features;$/;"	m	class:net::interface
_netif	net/net.hh	/^    interface* _netif;$/;"	m	class:net::l3_protocol
_pkt_providers	net/net.hh	/^    std::vector<l3_protocol::packet_provider_type> _pkt_providers;$/;"	m	class:net::interface
_proto_map	net/net.hh	/^    std::unordered_map<uint16_t, l3_rx_stream> _proto_map;$/;"	m	class:net::interface
_proto_num	net/net.hh	/^    eth_protocol_num _proto_num;$/;"	m	class:net::l3_protocol
_proxy_packetq	net/net.hh	/^    circular_buffer<packet> _proxy_packetq;$/;"	m	class:net::qp
_queue_name	net/net.hh	/^    const std::string _queue_name;$/;"	m	class:net::qp
_queues	net/net.hh	/^    std::unique_ptr<qp*[]> _queues;$/;"	m	class:net::device
_rss_table_bits	net/net.hh	/^    size_t _rss_table_bits = 0;$/;"	m	class:net::device
_rx	net/net.hh	/^    subscription<packet> _rx;$/;"	m	class:net::interface
_rx_stream	net/net.hh	/^    stream<packet> _rx_stream;$/;"	m	class:net::qp
_stats	net/net.hh	/^    qp_stats _stats;$/;"	m	class:net::qp
_stats_plugin_name	net/net.hh	/^    const std::string _stats_plugin_name;$/;"	m	class:net::qp
_sw_reta	net/net.hh	/^    std::experimental::optional<std::array<uint8_t, 128>> _sw_reta;$/;"	m	class:net::qp
_tx_packetq	net/net.hh	/^    circular_buffer<packet> _tx_packetq;$/;"	m	class:net::qp
_tx_poller	net/net.hh	/^    reactor::poller _tx_poller;$/;"	m	class:net::qp
bad	net/net.hh	/^        } bad;$/;"	m	struct:net::qp_stats::__anon2	typeref:struct:net::qp_stats::__anon2::__anon3
bytes	net/net.hh	/^    uint64_t bytes;      \/\/ total number of bytes$/;"	m	struct:net::qp_stats_good
copy_bytes	net/net.hh	/^    uint64_t copy_bytes; \/\/ bytes that were copied on L2 level$/;"	m	struct:net::qp_stats_good
copy_frags	net/net.hh	/^    uint64_t copy_frags; \/\/ fragments that were copied on L2 level$/;"	m	struct:net::qp_stats_good
csum	net/net.hh	/^            uint64_t csum;         \/\/ packets with bad checksum$/;"	m	struct:net::qp_stats::__anon2::__anon3
data	net/net.hh	/^    uint8_t data[64];$/;"	m	class:net::forward_hash
device	net/net.hh	/^    device() {$/;"	f	class:net::device
device	net/net.hh	/^class device {$/;"	c	namespace:net
end_idx	net/net.hh	/^    size_t end_idx = 0;$/;"	m	class:net::forward_hash
forward	net/net.hh	/^        std::function<bool (forward_hash&, packet&, size_t)> forward;$/;"	m	struct:net::interface::l3_rx_stream
forward_dst	net/net.hh	/^    unsigned forward_dst(unsigned src_cpuid, Func&& hashfn) {$/;"	f	class:net::device
forward_hash	net/net.hh	/^class forward_hash {$/;"	c	namespace:net
good	net/net.hh	/^        struct qp_stats_good good;$/;"	m	struct:net::qp_stats::__anon2	typeref:struct:net::qp_stats::__anon2::qp_stats_good
good	net/net.hh	/^        struct qp_stats_good good;$/;"	m	struct:net::qp_stats::__anon4	typeref:struct:net::qp_stats::__anon4::qp_stats_good
hash2cpu	net/net.hh	/^    virtual unsigned hash2cpu(uint32_t hash) {$/;"	f	class:net::device
hash2qid	net/net.hh	/^    virtual unsigned hash2qid(uint32_t hash) {$/;"	f	class:net::device
hw_address	net/net.hh	/^    ethernet_address hw_address() { return _hw_address; }$/;"	f	class:net::interface
hw_features	net/net.hh	/^    const net::hw_features& hw_features() const { return _hw_features; }$/;"	f	class:net::interface
hw_features	net/net.hh	/^struct hw_features {$/;"	s	namespace:net
hw_queues_count	net/net.hh	/^    virtual uint16_t hw_queues_count() { return 1; }$/;"	f	class:net::device
inc_csum_err	net/net.hh	/^            void inc_csum_err() {$/;"	f	struct:net::qp_stats::__anon2::__anon3
inc_no_mem	net/net.hh	/^            void inc_no_mem() {$/;"	f	struct:net::qp_stats::__anon2::__anon3
interface	net/net.hh	/^class interface {$/;"	c	namespace:net
l2receive	net/net.hh	/^    void l2receive(packet p) { _queues[engine().cpu_id()]->_rx_stream.produce(std::move(p)); }$/;"	f	class:net::device
l3_protocol	net/net.hh	/^class l3_protocol {$/;"	c	namespace:net
l3_rx_stream	net/net.hh	/^        l3_rx_stream(std::function<bool (forward_hash&, packet&, size_t)>&& fw) : ready(packet_stream.started()), forward(fw) {}$/;"	f	struct:net::interface::l3_rx_stream
l3_rx_stream	net/net.hh	/^    struct l3_rx_stream {$/;"	s	class:net::interface
l3packet	net/net.hh	/^    struct l3packet {$/;"	s	class:net::l3_protocol
last_bunch	net/net.hh	/^    uint64_t last_bunch; \/\/ number of packets in the last sent\/received bunch$/;"	m	struct:net::qp_stats_good
link_ready	net/net.hh	/^    virtual future<> link_ready() { return make_ready_future<>(); }$/;"	f	class:net::device
local_queue	net/net.hh	/^    qp& local_queue() { return queue_for_cpu(engine().cpu_id()); }$/;"	f	class:net::device
max_packet_len	net/net.hh	/^    uint16_t max_packet_len = net::ip_packet_len_max - net::eth_hdr_len;$/;"	m	struct:net::hw_features
mtu	net/net.hh	/^    uint16_t mtu = 1500;$/;"	m	struct:net::hw_features
net	net/net.hh	/^namespace net {$/;"	n
no_mem	net/net.hh	/^            uint64_t no_mem;       \/\/ Packets dropped due to allocation failure$/;"	m	struct:net::qp_stats::__anon2::__anon3
nr_frags	net/net.hh	/^    uint64_t nr_frags;   \/\/ total number of fragments$/;"	m	struct:net::qp_stats_good
operator []	net/net.hh	/^    const uint8_t& operator[](size_t idx) const {$/;"	f	class:net::forward_hash
p	net/net.hh	/^        packet p;$/;"	m	struct:net::l3_protocol::l3packet
packet_stream	net/net.hh	/^        stream<packet, ethernet_address> packet_stream;$/;"	m	struct:net::interface::l3_rx_stream
packets	net/net.hh	/^    uint64_t packets;    \/\/ total number of packets$/;"	m	struct:net::qp_stats_good
proto_num	net/net.hh	/^        eth_protocol_num proto_num;$/;"	m	struct:net::l3_protocol::l3packet
proxy_send	net/net.hh	/^    void proxy_send(packet p) {$/;"	f	class:net::qp
push_back	net/net.hh	/^    void push_back(uint16_t b) {$/;"	f	class:net::forward_hash
push_back	net/net.hh	/^    void push_back(uint32_t b) {$/;"	f	class:net::forward_hash
push_back	net/net.hh	/^    void push_back(uint8_t b) {$/;"	f	class:net::forward_hash
qp	net/net.hh	/^class qp {$/;"	c	namespace:net
qp_stats	net/net.hh	/^    qp_stats() {$/;"	f	struct:net::qp_stats
qp_stats	net/net.hh	/^struct qp_stats {$/;"	s	namespace:net
qp_stats_good	net/net.hh	/^struct qp_stats_good {$/;"	s	namespace:net
queue_for_cpu	net/net.hh	/^    qp& queue_for_cpu(unsigned cpu) { return *_queues[cpu]; }$/;"	f	class:net::device
ready	net/net.hh	/^        future<> ready;$/;"	m	struct:net::interface::l3_rx_stream
register_packet_provider	net/net.hh	/^    void register_packet_provider(l3_protocol::packet_provider_type func) {$/;"	f	class:net::interface
register_packet_provider	net/net.hh	/^    void register_packet_provider(packet_provider_type func) {$/;"	f	class:net::qp
rx	net/net.hh	/^    } rx;$/;"	m	struct:net::qp_stats	typeref:struct:net::qp_stats::__anon2
rx_csum_offload	net/net.hh	/^    bool rx_csum_offload = false;$/;"	m	struct:net::hw_features
rx_lro	net/net.hh	/^    bool rx_lro = false;$/;"	m	struct:net::hw_features
rx_start	net/net.hh	/^    virtual void rx_start() {};$/;"	f	class:net::qp
send	net/net.hh	/^    virtual uint32_t send(circular_buffer<packet>& p) {$/;"	f	class:net::qp
size	net/net.hh	/^    size_t size() const {$/;"	f	class:net::forward_hash
to	net/net.hh	/^        ethernet_address to;$/;"	m	struct:net::l3_protocol::l3packet
total	net/net.hh	/^            uint64_t total;        \/\/ total number of erroneous packets$/;"	m	struct:net::qp_stats::__anon2::__anon3
tx	net/net.hh	/^    } tx;$/;"	m	struct:net::qp_stats	typeref:struct:net::qp_stats::__anon4
tx_csum_ip_offload	net/net.hh	/^    bool tx_csum_ip_offload = false;$/;"	m	struct:net::hw_features
tx_csum_l4_offload	net/net.hh	/^    bool tx_csum_l4_offload = false;$/;"	m	struct:net::hw_features
tx_tso	net/net.hh	/^    bool tx_tso = false;$/;"	m	struct:net::hw_features
tx_ufo	net/net.hh	/^    bool tx_ufo = false;$/;"	m	struct:net::hw_features
update_copy_stats	net/net.hh	/^    void update_copy_stats(uint64_t nr_frags, uint64_t bytes) {$/;"	f	struct:net::qp_stats_good
update_frags_stats	net/net.hh	/^    void update_frags_stats(uint64_t nfrags, uint64_t nbytes) {$/;"	f	struct:net::qp_stats_good
update_pkts_bunch	net/net.hh	/^    void update_pkts_bunch(uint64_t count) {$/;"	f	struct:net::qp_stats_good
~device	net/net.hh	/^    virtual ~device() {};$/;"	f	class:net::device
_PACKET_DATA_SOURCE_HH	net/packet-data-source.hh	19;"	d
_cur_frag	net/packet-data-source.hh	/^    size_t _cur_frag = 0;$/;"	m	class:net::final
_p	net/packet-data-source.hh	/^    packet _p;$/;"	m	class:net::final
as_input_stream	net/packet-data-source.hh	/^input_stream<char> as_input_stream(packet&& p) {$/;"	f	namespace:net
final	net/packet-data-source.hh	/^class packet_data_source final : public data_source_impl {$/;"	c	namespace:net
kj_get	net/packet-data-source.hh	/^    virtual kj::Promise<temporary_buffer<char>> kj_get(size_t maxBytes = 8192){$/;"	f	class:net::final
net	net/packet-data-source.hh	/^namespace net {$/;"	n
packet_data_source	net/packet-data-source.hh	/^    explicit packet_data_source(net::packet&& p)$/;"	f	class:net::final
PACKET_UTIL_HH_	net/packet-util.hh	23;"	d
map	net/packet-util.hh	/^    std::map<Offset, packet> map;$/;"	m	class:net::packet_merger
merge	net/packet-util.hh	/^    void merge(Offset offset, packet p) {$/;"	f	class:net::packet_merger
net	net/packet-util.hh	/^namespace net {$/;"	n
packet_merger	net/packet-util.hh	/^class packet_merger {$/;"	c	namespace:net
default_nr_frags	net/packet.cc	/^constexpr size_t packet::default_nr_frags;$/;"	m	class:net::packet	file:
free_on_cpu	net/packet.cc	/^packet packet::free_on_cpu(unsigned cpu, std::function<void()> cb)$/;"	f	class:net::packet
internal_data_size	net/packet.cc	/^constexpr size_t packet::internal_data_size;$/;"	m	class:net::packet	file:
linearize	net/packet.cc	/^void packet::linearize(size_t at_frag, size_t desired_size) {$/;"	f	class:net::packet
net	net/packet.cc	/^namespace net {$/;"	n	file:
operator <<	net/packet.cc	/^std::ostream& operator<<(std::ostream& os, const packet& p) {$/;"	f	namespace:net
PACKET_HH_	net/packet.hh	23;"	d
_allocated_frags	net/packet.hh	/^        uint16_t _allocated_frags;$/;"	m	struct:net::final::impl
_data	net/packet.hh	/^        char _data[internal_data_size]; \/\/ only _frags[0] may use$/;"	m	struct:net::final::impl
_deleter	net/packet.hh	/^        deleter _deleter;$/;"	m	struct:net::final::impl
_finish	net/packet.hh	/^        fragment* _finish;$/;"	m	struct:net::final::pseudo_vector
_frags	net/packet.hh	/^        fragment _frags[];$/;"	m	struct:net::final::impl
_headroom	net/packet.hh	/^        unsigned _headroom = internal_data_size; \/\/ in _data$/;"	m	struct:net::final::impl
_impl	net/packet.hh	/^    std::unique_ptr<impl> _impl;$/;"	m	class:net::final
_len	net/packet.hh	/^        unsigned _len = 0;$/;"	m	struct:net::final::impl
_nr_frags	net/packet.hh	/^        uint16_t _nr_frags = 0;$/;"	m	struct:net::final::impl
_offload_info	net/packet.hh	/^        offload_info _offload_info;$/;"	m	struct:net::final::impl
_rss_hash	net/packet.hh	/^        std::experimental::optional<uint32_t> _rss_hash;$/;"	m	struct:net::final::impl
_start	net/packet.hh	/^        fragment* _start;$/;"	m	struct:net::final::pseudo_vector
allocate	net/packet.hh	/^        static std::unique_ptr<impl> allocate(size_t nr_frags) {$/;"	f	struct:net::final::impl
allocate_headroom	net/packet.hh	/^packet::allocate_headroom(size_t size) {$/;"	f	class:net::packet
allocate_if_needed	net/packet.hh	/^        static std::unique_ptr<impl> allocate_if_needed(std::unique_ptr<impl> old, size_t extra_frags) {$/;"	f	struct:net::final::impl
append	net/packet.hh	/^void packet::append(packet&& p) {$/;"	f	class:net::packet
base	net/packet.hh	/^    char* base;$/;"	m	struct:net::fragment
begin	net/packet.hh	/^        fragment* begin() { return _start; }$/;"	f	struct:net::final::pseudo_vector
copy	net/packet.hh	/^        static std::unique_ptr<impl> copy(impl* old) {$/;"	f	struct:net::final::impl
copy	net/packet.hh	/^        static std::unique_ptr<impl> copy(impl* old, size_t nr) {$/;"	f	struct:net::final::impl
copy_internal_fragment_to	net/packet.hh	/^        void copy_internal_fragment_to(impl* to) {$/;"	f	struct:net::final::impl
default_nr_frags	net/packet.hh	/^    static constexpr size_t default_nr_frags = 4;$/;"	m	class:net::final
end	net/packet.hh	/^        fragment* end() { return _finish; }$/;"	f	struct:net::final::pseudo_vector
final	net/packet.hh	/^class packet final {$/;"	c	namespace:net
frag	net/packet.hh	/^    fragment frag(unsigned idx) const { return _impl->_frags[idx]; }$/;"	f	class:net::final
frag	net/packet.hh	/^    fragment& frag(unsigned idx) { return _impl->_frags[idx]; }$/;"	f	class:net::final
fragment	net/packet.hh	/^struct fragment {$/;"	s	namespace:net
fragment_array	net/packet.hh	/^    fragment* fragment_array() const { return _impl->_frags; }$/;"	f	class:net::final
fragments	net/packet.hh	/^        pseudo_vector fragments() { return { _frags, _nr_frags }; }$/;"	f	struct:net::final::impl
fragments	net/packet.hh	/^    pseudo_vector fragments() const { return { _impl->_frags, _impl->_nr_frags }; }$/;"	f	class:net::final
from_static_data	net/packet.hh	/^    static packet from_static_data(const char* data, size_t len) {$/;"	f	class:net::final
get_header	net/packet.hh	/^Header* packet::get_header(size_t offset) {$/;"	f	class:net::packet
get_header	net/packet.hh	/^char* packet::get_header(size_t offset, size_t size) {$/;"	f	class:net::packet
impl	net/packet.hh	/^    struct impl {$/;"	s	class:net::final
impl	net/packet.hh	/^packet::impl::impl(fragment frag, size_t nr_frags)$/;"	f	class:net::packet::impl
impl	net/packet.hh	/^packet::impl::impl(size_t nr_frags)$/;"	f	class:net::packet::impl
internal_data_size	net/packet.hh	/^    static constexpr size_t internal_data_size = 128 - 16;$/;"	m	class:net::final
ip_hdr_len	net/packet.hh	/^    uint8_t ip_hdr_len = 20;$/;"	m	struct:net::offload_info
len	net/packet.hh	/^    unsigned len() const { return _impl->_len; }$/;"	f	class:net::final
linearize	net/packet.hh	/^    void linearize() { return linearize(0, len()); }$/;"	f	class:net::final
memory	net/packet.hh	/^    unsigned memory() const { return len() +  sizeof(packet::impl); }$/;"	f	class:net::final
move	net/packet.hh	/^    : _impl(std::move(x._impl)) {$/;"	f	namespace:net
needs_csum	net/packet.hh	/^    bool needs_csum = false;$/;"	m	struct:net::offload_info
needs_ip_csum	net/packet.hh	/^    bool needs_ip_csum = false;$/;"	m	struct:net::offload_info
net	net/packet.hh	/^namespace net {$/;"	n
noexcept	net/packet.hh	/^    packet(packet&& x) noexcept;$/;"	m	class:net::final
nr_frags	net/packet.hh	/^    unsigned nr_frags() const { return _impl->_nr_frags; }$/;"	f	class:net::final
offload_info	net/packet.hh	/^    class offload_info offload_info() { return _impl->_offload_info; }$/;"	f	class:net::final
offload_info	net/packet.hh	/^struct offload_info {$/;"	s	namespace:net
offload_info_ref	net/packet.hh	/^    class offload_info& offload_info_ref() { return _impl->_offload_info; }$/;"	f	class:net::final
operator =	net/packet.hh	/^    packet& operator=(packet&& x) {$/;"	f	class:net::final
operator []	net/packet.hh	/^        fragment& operator[](size_t idx) { return _start[idx]; }$/;"	f	struct:net::final::pseudo_vector
operator delete	net/packet.hh	/^        void operator delete(void* ptr) {$/;"	f	struct:net::final::impl
operator delete	net/packet.hh	/^        void operator delete(void* ptr, size_t nr_frags) {$/;"	f	struct:net::final::impl
operator new	net/packet.hh	/^        void* operator new(size_t size, size_t nr_frags = default_nr_frags) {$/;"	f	struct:net::final::impl
packet	net/packet.hh	/^    packet(std::unique_ptr<impl>&& impl) : _impl(std::move(impl)) {}$/;"	f	class:net::final
packet	net/packet.hh	/^packet::packet()$/;"	f	class:net::packet
packet	net/packet.hh	/^packet::packet(Iterator begin, Iterator end, Deleter del) {$/;"	f	class:net::packet
packet	net/packet.hh	/^packet::packet(Iterator begin, Iterator end, deleter del) {$/;"	f	class:net::packet
packet	net/packet.hh	/^packet::packet(const char* data, size_t size) : packet(fragment{const_cast<char*>(data), size}) {$/;"	f	class:net::packet
packet	net/packet.hh	/^packet::packet(fragment frag) : _impl(new impl(frag)) {$/;"	f	class:net::packet
packet	net/packet.hh	/^packet::packet(fragment frag, Deleter d) : packet(frag, make_deleter(deleter(), std::move(d))) {}$/;"	f	class:net::packet
packet	net/packet.hh	/^packet::packet(fragment frag, Deleter d, packet&& x)$/;"	f	class:net::packet
packet	net/packet.hh	/^packet::packet(fragment frag, deleter d)$/;"	f	class:net::packet
packet	net/packet.hh	/^packet::packet(fragment frag, packet&& x)$/;"	f	class:net::packet
packet	net/packet.hh	/^packet::packet(packet&& x, Deleter d)$/;"	f	class:net::packet
packet	net/packet.hh	/^packet::packet(packet&& x, fragment frag)$/;"	f	class:net::packet
packet	net/packet.hh	/^packet::packet(packet&& x, fragment frag, Deleter d)$/;"	f	class:net::packet
packet	net/packet.hh	/^packet::packet(packet&& x, fragment frag, deleter d)$/;"	f	class:net::packet
packet	net/packet.hh	/^packet::packet(packet&& x, temporary_buffer<char> buf)$/;"	f	class:net::packet
packet	net/packet.hh	/^packet::packet(size_t nr_frags)$/;"	f	class:net::packet
packet	net/packet.hh	/^packet::packet(std::vector<fragment> frag, Deleter d)$/;"	f	class:net::packet
packet	net/packet.hh	/^packet::packet(std::vector<fragment> frag, deleter d)$/;"	f	class:net::packet
prepend_header	net/packet.hh	/^packet::prepend_header(size_t extra_size) {$/;"	f	class:net::packet
prepend_uninitialized_header	net/packet.hh	/^char* packet::prepend_uninitialized_header(size_t size) {$/;"	f	class:net::packet
protocol	net/packet.hh	/^    ip_protocol_num protocol = ip_protocol_num::unused;$/;"	m	struct:net::offload_info
pseudo_vector	net/packet.hh	/^        pseudo_vector(fragment* start, size_t nr)$/;"	f	struct:net::final::pseudo_vector
pseudo_vector	net/packet.hh	/^    struct pseudo_vector {$/;"	s	class:net::final
reassembled	net/packet.hh	/^    bool reassembled = false;$/;"	m	struct:net::offload_info
reserve	net/packet.hh	/^    void reserve(int n_frags) {$/;"	f	class:net::final
reset	net/packet.hh	/^    void reset() { _impl.reset(); }$/;"	f	class:net::final
rss_hash	net/packet.hh	/^    std::experimental::optional<uint32_t> rss_hash() {$/;"	f	class:net::final
set_offload_info	net/packet.hh	/^    void set_offload_info(class offload_info oi) { _impl->_offload_info = oi; }$/;"	f	class:net::final
set_rss_hash	net/packet.hh	/^    std::experimental::optional<uint32_t> set_rss_hash(uint32_t hash) {$/;"	f	class:net::final
share	net/packet.hh	/^packet packet::share() {$/;"	f	class:net::packet
share	net/packet.hh	/^packet packet::share(size_t offset, size_t len) {$/;"	f	class:net::packet
size	net/packet.hh	/^    size_t size;$/;"	m	struct:net::fragment
tcp_hdr_len	net/packet.hh	/^    uint8_t tcp_hdr_len = 20;$/;"	m	struct:net::offload_info
trim_back	net/packet.hh	/^void packet::trim_back(size_t how_much) {$/;"	f	class:net::packet
trim_front	net/packet.hh	/^void packet::trim_front(size_t how_much) {$/;"	f	class:net::packet
tso_seg_size	net/packet.hh	/^    uint16_t tso_seg_size = 0;$/;"	m	struct:net::offload_info
udp_hdr_len	net/packet.hh	/^    uint8_t udp_hdr_len = 8;$/;"	m	struct:net::offload_info
unuse_internal_data	net/packet.hh	/^        void unuse_internal_data() {$/;"	f	struct:net::final::impl
using_internal_data	net/packet.hh	/^        bool using_internal_data() const {$/;"	f	struct:net::final::impl
vlan_tci	net/packet.hh	/^    std::experimental::optional<uint16_t> vlan_tci;$/;"	m	struct:net::offload_info
MAX_DATAGRAM_SIZE	net/posix-stack.cc	/^    static constexpr int MAX_DATAGRAM_SIZE = 65507;$/;"	m	class:net::posix_udp_channel	file:
_address	net/posix-stack.cc	/^    ipv4_addr _address;$/;"	m	class:net::posix_udp_channel	file:
_buffer	net/posix-stack.cc	/^        char* _buffer;$/;"	m	struct:net::posix_udp_channel::recv_ctx	file:
_closed	net/posix-stack.cc	/^    bool _closed;$/;"	m	class:net::posix_udp_channel	file:
_cmsg	net/posix-stack.cc	/^        cmsg_with_pktinfo _cmsg;$/;"	m	struct:net::posix_udp_channel::recv_ctx	file:
_dst	net/posix-stack.cc	/^        socket_address _dst;$/;"	m	struct:net::posix_udp_channel::send_ctx	file:
_dst	net/posix-stack.cc	/^    ipv4_addr _dst;$/;"	m	class:net::posix_datagram	file:
_fd	net/posix-stack.cc	/^    pollable_fd _fd;$/;"	m	class:net::final	file:
_fd	net/posix-stack.cc	/^    std::unique_ptr<pollable_fd> _fd;$/;"	m	class:net::posix_udp_channel	file:
_hdr	net/posix-stack.cc	/^        struct msghdr _hdr;$/;"	m	struct:net::posix_udp_channel::recv_ctx	typeref:struct:net::posix_udp_channel::recv_ctx::msghdr	file:
_hdr	net/posix-stack.cc	/^        struct msghdr _hdr;$/;"	m	struct:net::posix_udp_channel::send_ctx	typeref:struct:net::posix_udp_channel::send_ctx::msghdr	file:
_iov	net/posix-stack.cc	/^        struct iovec _iov;$/;"	m	struct:net::posix_udp_channel::recv_ctx	typeref:struct:net::posix_udp_channel::recv_ctx::iovec	file:
_iovecs	net/posix-stack.cc	/^        std::vector<struct iovec> _iovecs;$/;"	m	struct:net::posix_udp_channel::send_ctx	file:
_p	net/posix-stack.cc	/^        packet _p;$/;"	m	struct:net::posix_udp_channel::send_ctx	file:
_p	net/posix-stack.cc	/^    packet _p;$/;"	m	class:net::posix_datagram	file:
_recv	net/posix-stack.cc	/^    recv_ctx _recv;$/;"	m	class:net::posix_udp_channel	file:
_send	net/posix-stack.cc	/^    send_ctx _send;$/;"	m	class:net::posix_udp_channel	file:
_src	net/posix-stack.cc	/^    ipv4_addr _src;$/;"	m	class:net::posix_datagram	file:
_src_addr	net/posix-stack.cc	/^        socket_address _src_addr;$/;"	m	struct:net::posix_udp_channel::recv_ctx	file:
abort_accept	net/posix-stack.cc	/^posix_ap_server_socket_impl::abort_accept() {$/;"	f	class:net::posix_ap_server_socket_impl
abort_accept	net/posix-stack.cc	/^posix_reuseport_server_socket_impl::abort_accept() {$/;"	f	class:net::posix_reuseport_server_socket_impl
abort_accept	net/posix-stack.cc	/^posix_server_socket_impl::abort_accept() {$/;"	f	class:net::posix_server_socket_impl
accept	net/posix-stack.cc	/^future<connected_socket, socket_address> posix_ap_server_socket_impl::accept() {$/;"	f	class:net::posix_ap_server_socket_impl
accept	net/posix-stack.cc	/^posix_reuseport_server_socket_impl::accept() {$/;"	f	class:net::posix_reuseport_server_socket_impl
accept	net/posix-stack.cc	/^posix_server_socket_impl::accept() {$/;"	f	class:net::posix_server_socket_impl
cmsg_with_pktinfo	net/posix-stack.cc	/^struct cmsg_with_pktinfo {$/;"	s	namespace:net	file:
conn_q	net/posix-stack.cc	/^thread_local std::unordered_multimap<::sockaddr_in, posix_ap_server_socket_impl::connection> posix_ap_server_socket_impl::conn_q;$/;"	m	class:net::posix_ap_server_socket_impl	file:
connect	net/posix-stack.cc	/^posix_ap_network_stack::connect(socket_address sa, socket_address local) {$/;"	f	class:net::posix_ap_network_stack
connect	net/posix-stack.cc	/^posix_network_stack::connect(socket_address sa, socket_address local) {$/;"	f	class:net::posix_network_stack
final	net/posix-stack.cc	/^class posix_connected_socket_impl final : public connected_socket_impl {$/;"	c	namespace:net	file:
get	net/posix-stack.cc	/^posix_data_source_impl::get() {$/;"	f	class:net::posix_data_source_impl
kj_accept	net/posix-stack.cc	/^kj::Promise<  std::pair<connected_socket, socket_address> > posix_ap_server_socket_impl::kj_accept() {$/;"	f	class:net::posix_ap_server_socket_impl
kj_accept	net/posix-stack.cc	/^posix_reuseport_server_socket_impl::kj_accept() {$/;"	f	class:net::posix_reuseport_server_socket_impl
kj_accept	net/posix-stack.cc	/^posix_server_socket_impl::kj_accept() {$/;"	f	class:net::posix_server_socket_impl
kj_connect	net/posix-stack.cc	/^posix_ap_network_stack::kj_connect(socket_address sa, socket_address local) {$/;"	f	class:net::posix_ap_network_stack
kj_connect	net/posix-stack.cc	/^posix_network_stack::kj_connect(socket_address sa, socket_address local) {$/;"	f	class:net::posix_network_stack
kj_get	net/posix-stack.cc	/^posix_data_source_impl::kj_get(size_t maxBytes) {$/;"	f	class:net::posix_data_source_impl
kj_put	net/posix-stack.cc	/^posix_data_sink_impl::kj_put(packet p) {$/;"	f	class:net::posix_data_sink_impl
kj_put	net/posix-stack.cc	/^posix_data_sink_impl::kj_put(temporary_buffer<char> buf) {$/;"	f	class:net::posix_data_sink_impl
kj_receive	net/posix-stack.cc	/^posix_udp_channel::kj_receive() {$/;"	f	class:net::posix_udp_channel
kj_send	net/posix-stack.cc	/^kj::Promise<void> posix_udp_channel::kj_send(ipv4_addr dst, const char *message) {$/;"	f	class:net::posix_udp_channel
kj_send	net/posix-stack.cc	/^kj::Promise<void> posix_udp_channel::kj_send(ipv4_addr dst, packet p) {$/;"	f	class:net::posix_udp_channel
listen	net/posix-stack.cc	/^posix_ap_network_stack::listen(socket_address sa, listen_options opt) {$/;"	f	class:net::posix_ap_network_stack
listen	net/posix-stack.cc	/^posix_network_stack::listen(socket_address sa, listen_options opt) {$/;"	f	class:net::posix_network_stack
make_udp_channel	net/posix-stack.cc	/^posix_network_stack::make_udp_channel(ipv4_addr addr) {$/;"	f	class:net::posix_network_stack
move_connected_socket	net/posix-stack.cc	/^void  posix_ap_server_socket_impl::move_connected_socket(socket_address sa, pollable_fd fd, socket_address addr) {$/;"	f	class:net::posix_ap_server_socket_impl
net	net/posix-stack.cc	/^namespace net {$/;"	n	file:
override	net/posix-stack.cc	/^    virtual future<udp_datagram> receive() override;$/;"	m	class:net::posix_udp_channel	file:
override	net/posix-stack.cc	/^    virtual kj::Promise<udp_datagram> kj_receive() override;$/;"	m	class:net::posix_udp_channel	file:
override	net/posix-stack.cc	/^    virtual kj::Promise<void> kj_send(ipv4_addr dst, const char *msg) override;$/;"	m	class:net::posix_udp_channel	file:
override	net/posix-stack.cc	/^    virtual kj::Promise<void> kj_send(ipv4_addr dst, packet p) override;$/;"	m	class:net::posix_udp_channel	file:
pktinfo	net/posix-stack.cc	/^    struct in_pktinfo pktinfo;$/;"	m	struct:net::cmsg_with_pktinfo	typeref:struct:net::cmsg_with_pktinfo::in_pktinfo	file:
posix_connected_socket_impl	net/posix-stack.cc	/^    explicit posix_connected_socket_impl(pollable_fd fd) : _fd(std::move(fd)) {}$/;"	f	class:net::final	file:
posix_data_sink	net/posix-stack.cc	/^data_sink posix_data_sink(pollable_fd& fd) {$/;"	f	namespace:net
posix_data_source	net/posix-stack.cc	/^data_source posix_data_source(pollable_fd& fd) {$/;"	f	namespace:net
posix_datagram	net/posix-stack.cc	/^    posix_datagram(ipv4_addr src, ipv4_addr dst, packet p) : _src(src), _dst(dst), _p(std::move(p)) {}$/;"	f	class:net::posix_datagram
posix_datagram	net/posix-stack.cc	/^class posix_datagram : public udp_datagram_impl {$/;"	c	namespace:net	file:
posix_udp_channel	net/posix-stack.cc	/^    posix_udp_channel(ipv4_addr bind_address)$/;"	f	class:net::posix_udp_channel
posix_udp_channel	net/posix-stack.cc	/^class posix_udp_channel : public udp_channel_impl {$/;"	c	namespace:net	file:
prepare	net/posix-stack.cc	/^        void prepare() {$/;"	f	struct:net::posix_udp_channel::recv_ctx
prepare	net/posix-stack.cc	/^        void prepare(ipv4_addr dst, packet p) {$/;"	f	struct:net::posix_udp_channel::send_ctx
put	net/posix-stack.cc	/^posix_data_sink_impl::put(packet p) {$/;"	f	class:net::posix_data_sink_impl
put	net/posix-stack.cc	/^posix_data_sink_impl::put(temporary_buffer<char> buf) {$/;"	f	class:net::posix_data_sink_impl
receive	net/posix-stack.cc	/^posix_udp_channel::receive() {$/;"	f	class:net::posix_udp_channel
recv_ctx	net/posix-stack.cc	/^        recv_ctx() {$/;"	f	struct:net::posix_udp_channel::recv_ctx
recv_ctx	net/posix-stack.cc	/^    struct recv_ctx {$/;"	s	class:net::posix_udp_channel	file:
send	net/posix-stack.cc	/^future<> posix_udp_channel::send(ipv4_addr dst, const char *message) {$/;"	f	class:net::posix_udp_channel
send	net/posix-stack.cc	/^future<> posix_udp_channel::send(ipv4_addr dst, packet p) {$/;"	f	class:net::posix_udp_channel
send_ctx	net/posix-stack.cc	/^        send_ctx() {$/;"	f	struct:net::posix_udp_channel::send_ctx
send_ctx	net/posix-stack.cc	/^    struct send_ctx {$/;"	s	class:net::posix_udp_channel	file:
sockets	net/posix-stack.cc	/^thread_local std::unordered_map<::sockaddr_in, promise<connected_socket, socket_address>> posix_ap_server_socket_impl::sockets;$/;"	m	class:net::posix_ap_server_socket_impl	file:
to_iovec	net/posix-stack.cc	/^std::vector<iovec> to_iovec(std::vector<temporary_buffer<char>>& buf_vec) {$/;"	f	namespace:net
to_iovec	net/posix-stack.cc	/^std::vector<struct iovec> to_iovec(const packet& p) {$/;"	f	namespace:net
~posix_udp_channel	net/posix-stack.cc	/^    virtual ~posix_udp_channel() {};$/;"	f	class:net::posix_udp_channel
POSIX_STACK_HH_	net/posix-stack.hh	23;"	d
_buf	net/posix-stack.hh	/^    temporary_buffer<char> _buf;$/;"	m	class:net::final
_buf_size	net/posix-stack.hh	/^    size_t _buf_size;$/;"	m	class:net::final
_fd	net/posix-stack.hh	/^    pollable_fd& _fd;$/;"	m	class:net::final
_fd	net/posix-stack.hh	/^    pollable_fd& _fd;$/;"	m	class:net::posix_data_sink_impl
_lfd	net/posix-stack.hh	/^    pollable_fd _lfd;$/;"	m	class:net::posix_reuseport_server_socket_impl
_lfd	net/posix-stack.hh	/^    pollable_fd _lfd;$/;"	m	class:net::posix_server_socket_impl
_p	net/posix-stack.hh	/^    packet _p;$/;"	m	class:net::posix_data_sink_impl
_reuseport	net/posix-stack.hh	/^    const bool _reuseport;$/;"	m	class:net::posix_ap_network_stack
_reuseport	net/posix-stack.hh	/^    const bool _reuseport;$/;"	m	class:net::posix_network_stack
_sa	net/posix-stack.hh	/^    socket_address _sa;$/;"	m	class:net::posix_ap_server_socket_impl
_sa	net/posix-stack.hh	/^    socket_address _sa;$/;"	m	class:net::posix_reuseport_server_socket_impl
_sa	net/posix-stack.hh	/^    socket_address _sa;$/;"	m	class:net::posix_server_socket_impl
addr	net/posix-stack.hh	/^        socket_address addr;$/;"	m	struct:net::posix_ap_server_socket_impl::connection
conn_q	net/posix-stack.hh	/^    static thread_local std::unordered_multimap<::sockaddr_in, connection> conn_q;$/;"	m	class:net::posix_ap_server_socket_impl
connection	net/posix-stack.hh	/^        connection(pollable_fd xfd, socket_address xaddr) : fd(std::move(xfd)), addr(xaddr) {}$/;"	f	struct:net::posix_ap_server_socket_impl::connection
connection	net/posix-stack.hh	/^    struct connection {$/;"	s	class:net::posix_ap_server_socket_impl
create	net/posix-stack.hh	/^    static future<std::unique_ptr<network_stack>> create(boost::program_options::variables_map opts) {$/;"	f	class:net::posix_ap_network_stack
create	net/posix-stack.hh	/^    static future<std::unique_ptr<network_stack>> create(boost::program_options::variables_map opts) {$/;"	f	class:net::posix_network_stack
fd	net/posix-stack.hh	/^        pollable_fd fd;$/;"	m	struct:net::posix_ap_server_socket_impl::connection
final	net/posix-stack.hh	/^class posix_data_source_impl final : public data_source_impl {$/;"	c	namespace:net
net	net/posix-stack.hh	/^namespace net {$/;"	n
override	net/posix-stack.hh	/^    future<> put(packet p) override;$/;"	m	class:net::posix_data_sink_impl
override	net/posix-stack.hh	/^    future<> put(temporary_buffer<char> buf) override;$/;"	m	class:net::posix_data_sink_impl
override	net/posix-stack.hh	/^    kj::Promise<void> kj_put(packet p) override;$/;"	m	class:net::posix_data_sink_impl
override	net/posix-stack.hh	/^    kj::Promise<void> kj_put(temporary_buffer<char> buf) override;$/;"	m	class:net::posix_data_sink_impl
override	net/posix-stack.hh	/^    virtual future<connected_socket> connect(socket_address sa, socket_address local) override;$/;"	m	class:net::posix_ap_network_stack
override	net/posix-stack.hh	/^    virtual future<connected_socket> connect(socket_address sa, socket_address local) override;$/;"	m	class:net::posix_network_stack
override	net/posix-stack.hh	/^    virtual future<temporary_buffer<char>> get() override;$/;"	m	class:net::final
override	net/posix-stack.hh	/^    virtual kj::Promise<connected_socket> kj_connect(socket_address sa, socket_address local = socket_address(::sockaddr_in{AF_INET, INADDR_ANY, 0}))  override;$/;"	m	class:net::posix_ap_network_stack
override	net/posix-stack.hh	/^    virtual kj::Promise<connected_socket> kj_connect(socket_address sa, socket_address local = socket_address(::sockaddr_in{AF_INET, INADDR_ANY, 0}))  override;$/;"	m	class:net::posix_network_stack
override	net/posix-stack.hh	/^    virtual kj::Promise<temporary_buffer<char>> kj_get(size_t maxBytes = 8192) override;$/;"	m	class:net::final
override	net/posix-stack.hh	/^    virtual net::udp_channel make_udp_channel(ipv4_addr addr) override;$/;"	m	class:net::posix_network_stack
override	net/posix-stack.hh	/^    virtual server_socket listen(socket_address sa, listen_options opts) override;$/;"	m	class:net::posix_ap_network_stack
override	net/posix-stack.hh	/^    virtual server_socket listen(socket_address sa, listen_options opts) override;$/;"	m	class:net::posix_network_stack
override	net/posix-stack.hh	/^    virtual void abort_accept() override;$/;"	m	class:net::posix_ap_server_socket_impl
override	net/posix-stack.hh	/^    virtual void abort_accept() override;$/;"	m	class:net::posix_reuseport_server_socket_impl
override	net/posix-stack.hh	/^    virtual void abort_accept() override;$/;"	m	class:net::posix_server_socket_impl
posix_ap_network_stack	net/posix-stack.hh	/^    posix_ap_network_stack(boost::program_options::variables_map opts) : posix_network_stack(std::move(opts)), _reuseport(engine().posix_reuseport_available()) {}$/;"	f	class:net::posix_ap_network_stack
posix_ap_network_stack	net/posix-stack.hh	/^class posix_ap_network_stack : public posix_network_stack {$/;"	c	namespace:net
posix_ap_server_socket_impl	net/posix-stack.hh	/^    explicit posix_ap_server_socket_impl(socket_address sa) : _sa(sa) {}$/;"	f	class:net::posix_ap_server_socket_impl
posix_ap_server_socket_impl	net/posix-stack.hh	/^class posix_ap_server_socket_impl : public server_socket_impl {$/;"	c	namespace:net
posix_data_sink_impl	net/posix-stack.hh	/^    explicit posix_data_sink_impl(pollable_fd& fd) : _fd(fd) {}$/;"	f	class:net::posix_data_sink_impl
posix_data_sink_impl	net/posix-stack.hh	/^class posix_data_sink_impl : public data_sink_impl {$/;"	c	namespace:net
posix_data_source_impl	net/posix-stack.hh	/^    explicit posix_data_source_impl(pollable_fd& fd, size_t buf_size = 8192)$/;"	f	class:net::final
posix_network_stack	net/posix-stack.hh	/^    explicit posix_network_stack(boost::program_options::variables_map opts) : _reuseport(engine().posix_reuseport_available()) {}$/;"	f	class:net::posix_network_stack
posix_network_stack	net/posix-stack.hh	/^class posix_network_stack : public network_stack {$/;"	c	namespace:net
posix_reuseport_server_socket_impl	net/posix-stack.hh	/^    explicit posix_reuseport_server_socket_impl(socket_address sa, pollable_fd lfd) : _sa(sa), _lfd(std::move(lfd)) {}$/;"	f	class:net::posix_reuseport_server_socket_impl
posix_reuseport_server_socket_impl	net/posix-stack.hh	/^class posix_reuseport_server_socket_impl : public server_socket_impl {$/;"	c	namespace:net
posix_server_socket_impl	net/posix-stack.hh	/^    explicit posix_server_socket_impl(socket_address sa, pollable_fd lfd) : _sa(sa), _lfd(std::move(lfd)) {}$/;"	f	class:net::posix_server_socket_impl
posix_server_socket_impl	net/posix-stack.hh	/^class posix_server_socket_impl : public server_socket_impl {$/;"	c	namespace:net
sockets	net/posix-stack.hh	/^    static thread_local std::unordered_map<::sockaddr_in, promise<connected_socket, socket_address>> sockets;$/;"	m	class:net::posix_ap_server_socket_impl
_cpu	net/proxy.cc	/^    unsigned _cpu;$/;"	m	class:net::proxy_net_device	file:
_dev	net/proxy.cc	/^    device* _dev;$/;"	m	class:net::proxy_net_device	file:
_moving	net/proxy.cc	/^    std::vector<packet> _moving;$/;"	m	class:net::proxy_net_device	file:
_send_depth	net/proxy.cc	/^    size_t _send_depth = 0;$/;"	m	class:net::proxy_net_device	file:
_send_queue_length	net/proxy.cc	/^    static constexpr size_t _send_queue_length = 128;$/;"	m	class:net::proxy_net_device	file:
create_proxy_net_device	net/proxy.cc	/^std::unique_ptr<qp> create_proxy_net_device(unsigned master_cpu, device* dev) {$/;"	f	namespace:net
net	net/proxy.cc	/^namespace net {$/;"	n	file:
override	net/proxy.cc	/^    virtual uint32_t send(circular_buffer<packet>& p) override;$/;"	m	class:net::proxy_net_device	file:
proxy_net_device	net/proxy.cc	/^class proxy_net_device : public qp {$/;"	c	namespace:net	file:
proxy_net_device	net/proxy.cc	/^proxy_net_device::proxy_net_device(unsigned cpu, device* dev) :$/;"	f	class:net::proxy_net_device
send	net/proxy.cc	/^uint32_t proxy_net_device::send(circular_buffer<packet>& p)$/;"	f	class:net::proxy_net_device
PROXY_HH_	net/proxy.hh	19;"	d
net	net/proxy.hh	/^namespace net {$/;"	n
NET_TCP_STACK_HH	net/tcp-stack.hh	25;"	d
net	net/tcp-stack.hh	/^namespace net {$/;"	n
fill	net/tcp.cc	/^uint8_t tcp_option::fill(tcp_hdr* th, uint8_t options_size) {$/;"	f	class:net::tcp_option
forward	net/tcp.cc	/^bool ipv4_tcp::forward(forward_hash& out_hash_data, packet& p, size_t off) {$/;"	f	class:net::ipv4_tcp
get_size	net/tcp.cc	/^uint8_t tcp_option::get_size(bool syn_on, bool ack_on) {$/;"	f	class:net::tcp_option
ipv4_tcp	net/tcp.cc	/^ipv4_tcp::ipv4_tcp(ipv4& inet)$/;"	f	class:net::ipv4_tcp
kj_tcpv4_connect	net/tcp.cc	/^kj_tcpv4_connect(tcp<ipv4_traits>& tcpv4, socket_address sa) {$/;"	f	namespace:net
net	net/tcp.cc	/^namespace net {$/;"	n	file:
parse	net/tcp.cc	/^void tcp_option::parse(uint8_t* beg, uint8_t* end) {$/;"	f	class:net::tcp_option
received	net/tcp.cc	/^void ipv4_tcp::received(packet p, ipv4_address from, ipv4_address to) {$/;"	f	class:net::ipv4_tcp
tcpv4_connect	net/tcp.cc	/^tcpv4_connect(tcp<ipv4_traits>& tcpv4, socket_address sa) {$/;"	f	namespace:net
tcpv4_listen	net/tcp.cc	/^tcpv4_listen(tcp<ipv4_traits>& tcpv4, uint16_t port, listen_options opts) {$/;"	f	namespace:net
~ipv4_tcp	net/tcp.cc	/^ipv4_tcp::~ipv4_tcp() {$/;"	f	class:net::ipv4_tcp
CLOSED	net/tcp.hh	/^        static constexpr tcp_state CLOSED         = tcp_state::CLOSED;$/;"	m	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
CLOSED	net/tcp.hh	/^    CLOSED          = (1 << 0),$/;"	m	class:net::tcp_state
CLOSE_WAIT	net/tcp.hh	/^        static constexpr tcp_state CLOSE_WAIT     = tcp_state::CLOSE_WAIT;$/;"	m	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
CLOSE_WAIT	net/tcp.hh	/^    CLOSE_WAIT      = (1 << 7),$/;"	m	class:net::tcp_state
CLOSING	net/tcp.hh	/^        static constexpr tcp_state CLOSING        = tcp_state::CLOSING;$/;"	m	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
CLOSING	net/tcp.hh	/^    CLOSING         = (1 << 8),$/;"	m	class:net::tcp_state
CRYPTOPP_ENABLE_NAMESPACE_WEAK	net/tcp.hh	49;"	d
ESTABLISHED	net/tcp.hh	/^        static constexpr tcp_state ESTABLISHED    = tcp_state::ESTABLISHED;$/;"	m	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
ESTABLISHED	net/tcp.hh	/^    ESTABLISHED     = (1 << 4),$/;"	m	class:net::tcp_state
FIN_WAIT_1	net/tcp.hh	/^        static constexpr tcp_state FIN_WAIT_1     = tcp_state::FIN_WAIT_1;$/;"	m	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
FIN_WAIT_1	net/tcp.hh	/^    FIN_WAIT_1      = (1 << 5),$/;"	m	class:net::tcp_state
FIN_WAIT_2	net/tcp.hh	/^        static constexpr tcp_state FIN_WAIT_2     = tcp_state::FIN_WAIT_2;$/;"	m	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
FIN_WAIT_2	net/tcp.hh	/^    FIN_WAIT_2      = (1 << 6),$/;"	m	class:net::tcp_state
Fulfiller	net/tcp.hh	/^typedef kj::Own< kj::PromiseFulfiller<void> > Fulfiller;$/;"	t	class:net::tcp_state::tcp_option::option_kind
LAST_ACK	net/tcp.hh	/^        static constexpr tcp_state LAST_ACK       = tcp_state::LAST_ACK;$/;"	m	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
LAST_ACK	net/tcp.hh	/^    LAST_ACK        = (1 << 9),$/;"	m	class:net::tcp_state
LISTEN	net/tcp.hh	/^        static constexpr tcp_state LISTEN         = tcp_state::LISTEN;$/;"	m	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
LISTEN	net/tcp.hh	/^    LISTEN          = (1 << 1),$/;"	m	class:net::tcp_state
SYN_RECEIVED	net/tcp.hh	/^        static constexpr tcp_state SYN_RECEIVED   = tcp_state::SYN_RECEIVED;$/;"	m	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
SYN_RECEIVED	net/tcp.hh	/^    SYN_RECEIVED    = (1 << 3),$/;"	m	class:net::tcp_state
SYN_SENT	net/tcp.hh	/^        static constexpr tcp_state SYN_SENT       = tcp_state::SYN_SENT;$/;"	m	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
SYN_SENT	net/tcp.hh	/^    SYN_SENT        = (1 << 2),$/;"	m	class:net::tcp_state
TCP_HH_	net/tcp.hh	23;"	d
TIME_WAIT	net/tcp.hh	/^        static constexpr tcp_state TIME_WAIT      = tcp_state::TIME_WAIT;$/;"	m	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
TIME_WAIT	net/tcp.hh	/^    TIME_WAIT       = (1 << 10)$/;"	m	class:net::tcp_state
_all_data_acked_promise	net/tcp.hh	/^            std::experimental::optional<promise<>> _all_data_acked_promise;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::send
_conn	net/tcp.hh	/^        connection* _conn = nullptr;$/;"	m	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
_connect_done	net/tcp.hh	/^        promise<> _connect_done;$/;"	m	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
_data_received_promise	net/tcp.hh	/^            std::experimental::optional<promise<>> _data_received_promise;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::receive
_delayed_ack	net/tcp.hh	/^        timer<lowres_clock> _delayed_ack;$/;"	m	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
_foreign_ip	net/tcp.hh	/^        ipaddr _foreign_ip;$/;"	m	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
_foreign_port	net/tcp.hh	/^        uint16_t _foreign_port;$/;"	m	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
_isn_secret	net/tcp.hh	/^        static isn_secret _isn_secret;$/;"	m	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
_isn_secret	net/tcp.hh	/^typename tcp<InetTraits>::tcb::isn_secret tcp<InetTraits>::tcb::_isn_secret;$/;"	m	class:net::tcp_state::tcp_option::option_kind::tcp::tcb::tcp::tcb
_local_ip	net/tcp.hh	/^        ipaddr _local_ip;$/;"	m	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
_local_mss	net/tcp.hh	/^    uint16_t _local_mss;$/;"	m	class:net::tcp_state::tcp_option::option_kind::option_len
_local_port	net/tcp.hh	/^        uint16_t _local_port;$/;"	m	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
_local_win_scale	net/tcp.hh	/^    uint8_t _local_win_scale = 0;$/;"	m	class:net::tcp_state::tcp_option::option_kind::option_len
_max_nr_retransmit	net/tcp.hh	/^constexpr uint16_t tcp<InetTraits>::tcb::_max_nr_retransmit;$/;"	m	class:net::tcp_state::tcp_option::option_kind::tcp::tcb::tcp::tcb
_mss_received	net/tcp.hh	/^    bool _mss_received = false;$/;"	m	class:net::tcp_state::tcp_option::option_kind::option_len
_nr_full_seg_received	net/tcp.hh	/^        uint16_t _nr_full_seg_received = 0;$/;"	m	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
_option	net/tcp.hh	/^        tcp_option _option;$/;"	m	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
_packetq	net/tcp.hh	/^        circular_buffer<typename InetTraits::l4packet> _packetq;$/;"	m	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
_persist	net/tcp.hh	/^        timer<lowres_clock> _persist;$/;"	m	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
_poll_active	net/tcp.hh	/^        bool _poll_active = false;$/;"	m	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
_rcv	net/tcp.hh	/^        } _rcv;$/;"	m	class:net::tcp_state::tcp_option::option_kind::tcp::tcb	typeref:struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::receive
_remote_mss	net/tcp.hh	/^    uint16_t _remote_mss = 536;$/;"	m	class:net::tcp_state::tcp_option::option_kind::option_len
_remote_win_scale	net/tcp.hh	/^    uint8_t _remote_win_scale = 0;$/;"	m	class:net::tcp_state::tcp_option::option_kind::option_len
_retransmit	net/tcp.hh	/^        timer<lowres_clock> _retransmit;$/;"	m	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
_rto_clk_granularity	net/tcp.hh	/^constexpr std::chrono::milliseconds tcp<InetTraits>::tcb::_rto_clk_granularity;$/;"	m	class:net::tcp_state::tcp_option::option_kind::tcp::tcb::tcp::tcb
_rto_max	net/tcp.hh	/^constexpr std::chrono::milliseconds tcp<InetTraits>::tcb::_rto_max;$/;"	m	class:net::tcp_state::tcp_option::option_kind::tcp::tcb::tcp::tcb
_rto_min	net/tcp.hh	/^constexpr std::chrono::milliseconds tcp<InetTraits>::tcb::_rto_min;$/;"	m	class:net::tcp_state::tcp_option::option_kind::tcp::tcb::tcp::tcb
_sack_received	net/tcp.hh	/^    bool _sack_received = false;$/;"	m	class:net::tcp_state::tcp_option::option_kind::option_len
_snd	net/tcp.hh	/^        } _snd;$/;"	m	class:net::tcp_state::tcp_option::option_kind::tcp::tcb	typeref:struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::send
_state	net/tcp.hh	/^        tcp_state _state = CLOSED;$/;"	m	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
_tcp	net/tcp.hh	/^        tcp& _tcp;$/;"	m	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
_timestamps_received	net/tcp.hh	/^    bool _timestamps_received = false;$/;"	m	class:net::tcp_state::tcp_option::option_kind::option_len
_win_scale_received	net/tcp.hh	/^    bool _win_scale_received = false;$/;"	m	class:net::tcp_state::tcp_option::option_kind::option_len
_window_opened	net/tcp.hh	/^            promise<> _window_opened;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::send
abort_reader	net/tcp.hh	/^tcp<InetTraits>::tcb::abort_reader() {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb::tcp::tcb
ack	net/tcp.hh	/^    packed<tcp_seq> ack;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp_hdr
adjust_endianness	net/tcp.hh	/^        void adjust_endianness(Adjuster a) { a(mss); }$/;"	f	struct:net::tcp_state::tcp_option::option_kind::option_len::mss
adjust_endianness	net/tcp.hh	/^        void adjust_endianness(Adjuster a) { a(t1, t2); }$/;"	f	struct:net::tcp_state::tcp_option::option_kind::option_len::timestamps
adjust_endianness	net/tcp.hh	/^    void adjust_endianness(Adjuster a) { a(src_port, dst_port, seq, ack, window, checksum, urgent); }$/;"	f	struct:net::tcp_state::tcp_option::option_kind::tcp_hdr
align	net/tcp.hh	/^    static const uint8_t align = 4;$/;"	m	class:net::tcp_state::tcp_option::option_kind::option_len
can_send	net/tcp.hh	/^        uint32_t can_send() {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
checksum	net/tcp.hh	/^    packed<uint16_t> checksum;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp_hdr
cleanup	net/tcp.hh	/^void tcp<InetTraits>::tcb::cleanup() {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb::tcp::tcb
clear_delayed_ack	net/tcp.hh	/^void tcp<InetTraits>::tcb::clear_delayed_ack() {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb::tcp::tcb
close	net/tcp.hh	/^void tcp<InetTraits>::tcb::close() {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb::tcp::tcb
close_read	net/tcp.hh	/^void tcp<InetTraits>::connection::close_read() {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb::tcp::connection
close_write	net/tcp.hh	/^void tcp<InetTraits>::connection::close_write() {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb::tcp::connection
closed	net/tcp.hh	/^            bool closed = false;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::send
connect	net/tcp.hh	/^future<typename tcp<InetTraits>::connection> tcp<InetTraits>::connect(socket_address sa) {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb::tcp
connect	net/tcp.hh	/^void tcp<InetTraits>::tcb::connect() {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb::tcp::tcb
connect_done	net/tcp.hh	/^        future<> connect_done() {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
cwnd	net/tcp.hh	/^            uint32_t cwnd;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::send
data	net/tcp.hh	/^            std::deque<packet> data;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::receive
data	net/tcp.hh	/^            std::deque<unacked_segment> data;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::send
data_len	net/tcp.hh	/^            uint16_t data_len;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::unacked_segment
data_offset	net/tcp.hh	/^    uint8_t data_offset : 4;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp_hdr
data_segment_acked	net/tcp.hh	/^uint32_t tcp<InetTraits>::tcb::data_segment_acked(tcp_seq seg_ack) {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb::tcp::tcb
dst_port	net/tcp.hh	/^    packed<uint16_t> dst_port;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp_hdr
dupacks	net/tcp.hh	/^            uint16_t dupacks = 0;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::send
eol	net/tcp.hh	/^    enum class option_kind: uint8_t { mss = 2, win_scale = 3, sack = 4, timestamps = 8,  nop = 1, eol = 0 };$/;"	m	class:net::tcp_state::tcp_option::option_kind
eol	net/tcp.hh	/^    enum class option_len:  uint8_t { mss = 4, win_scale = 3, sack = 2, timestamps = 10, nop = 1, eol = 1 };$/;"	m	class:net::tcp_state::tcp_option::option_kind::option_len
eol	net/tcp.hh	/^    struct eol {$/;"	s	class:net::tcp_state::tcp_option::option_kind::option_len
f_ack	net/tcp.hh	/^    uint8_t f_ack : 1;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp_hdr
f_fin	net/tcp.hh	/^    uint8_t f_fin : 1;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp_hdr
f_psh	net/tcp.hh	/^    uint8_t f_psh : 1;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp_hdr
f_rst	net/tcp.hh	/^    uint8_t f_rst : 1;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp_hdr
f_syn	net/tcp.hh	/^    uint8_t f_syn : 1;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp_hdr
f_urg	net/tcp.hh	/^    uint8_t f_urg : 1;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp_hdr
fast_retransmit	net/tcp.hh	/^void tcp<InetTraits>::tcb::fast_retransmit() {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb::tcp::tcb
fin_retransmit	net/tcp.hh	/^            unsigned fin_retransmit = 0;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::send
first_rto_sample	net/tcp.hh	/^            bool first_rto_sample = true;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::send
flight_size	net/tcp.hh	/^        uint32_t flight_size() {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
forward	net/tcp.hh	/^bool tcp<InetTraits>::forward(forward_hash& out_hash_data, packet& p, size_t off) {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb::tcp
get_isn	net/tcp.hh	/^tcp_seq tcp<InetTraits>::tcb::get_isn() {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb::tcp::tcb
get_packet	net/tcp.hh	/^std::experimental::optional<typename InetTraits::l4packet> tcp<InetTraits>::tcb::get_packet() {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb::tcp::tcb
get_transmit_packet	net/tcp.hh	/^packet tcp<InetTraits>::tcb::get_transmit_packet() {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb::tcp::tcb
hton	net/tcp.hh	/^inline tcp_seq hton(tcp_seq s) {$/;"	f	class:net::tcp_state::tcp_option::option_kind
init_from_options	net/tcp.hh	/^void tcp<InetTraits>::tcb::init_from_options(tcp_hdr* th, uint8_t* opt_start, uint8_t* opt_end) {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb::tcp::tcb
initial	net/tcp.hh	/^            tcp_seq initial;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::receive
initial	net/tcp.hh	/^            tcp_seq initial;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::send
input_handle_listen_state	net/tcp.hh	/^void tcp<InetTraits>::tcb::input_handle_listen_state(tcp_hdr* th, packet p) {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb::tcp::tcb
input_handle_other_state	net/tcp.hh	/^void tcp<InetTraits>::tcb::input_handle_other_state(tcp_hdr* th, packet p) {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb::tcp::tcb
input_handle_syn_sent_state	net/tcp.hh	/^void tcp<InetTraits>::tcb::input_handle_syn_sent_state(tcp_hdr* th, packet p) {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb::tcp::tcb
insert_out_of_order	net/tcp.hh	/^void tcp<InetTraits>::tcb::insert_out_of_order(tcp_seq seg, packet p) {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb::tcp::tcb
isn_secret	net/tcp.hh	/^            isn_secret () {$/;"	f	struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::isn_secret
isn_secret	net/tcp.hh	/^        struct isn_secret {$/;"	s	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
key	net/tcp.hh	/^            uint32_t key[16];$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::isn_secret
kind	net/tcp.hh	/^        option_kind kind = option_kind::eol;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::option_len::eol
kind	net/tcp.hh	/^        option_kind kind = option_kind::mss;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::option_len::mss
kind	net/tcp.hh	/^        option_kind kind = option_kind::nop;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::option_len::nop
kind	net/tcp.hh	/^        option_kind kind = option_kind::sack;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::option_len::sack
kind	net/tcp.hh	/^        option_kind kind = option_kind::timestamps;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::option_len::timestamps
kind	net/tcp.hh	/^        option_kind kind = option_kind::win_scale;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::option_len::win_scale
kj__all_data_acked_promise	net/tcp.hh	/^            Fulfiller kj__all_data_acked_promise;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::send
kj__data_received_promise	net/tcp.hh	/^            Fulfiller kj__data_received_promise;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::receive
kj__window_opened	net/tcp.hh	/^            Fulfiller kj__window_opened;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::send
kj_connect	net/tcp.hh	/^kj::Promise<typename tcp<InetTraits>::connection> tcp<InetTraits>::kj_connect(socket_address sa) {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb::tcp
kj_connect_done	net/tcp.hh	/^        kj::Promise<void> kj_connect_done() {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
kj_poll_tcb	net/tcp.hh	/^kj::Promise<void> tcp<InetTraits>::kj_poll_tcb(ipaddr to, lw_shared_ptr<tcb> tcb) {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb::tcp
kj_send	net/tcp.hh	/^kj::Promise<void> tcp<InetTraits>::tcb::kj_send(packet p) {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb::tcp::tcb
kj_wait_for_all_data_acked	net/tcp.hh	/^kj::Promise<void> tcp<InetTraits>::tcb::kj_wait_for_all_data_acked() {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb::tcp::tcb
kj_wait_for_data	net/tcp.hh	/^kj::Promise<void> tcp<InetTraits>::tcb::kj_wait_for_data() {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb::tcp::tcb
len	net/tcp.hh	/^        option_len len = option_len::mss;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::option_len::mss
len	net/tcp.hh	/^        option_len len = option_len::sack;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::option_len::sack
len	net/tcp.hh	/^        option_len len = option_len::timestamps;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::option_len::timestamps
len	net/tcp.hh	/^        option_len len = option_len::win_scale;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::option_len::win_scale
limited_transfer	net/tcp.hh	/^            uint32_t limited_transfer = 0;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::send
local_mss	net/tcp.hh	/^        uint16_t local_mss() {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
make_seq	net/tcp.hh	/^inline tcp_seq make_seq(uint32_t raw) { return tcp_seq{raw}; }$/;"	f	class:net::tcp_state::tcp_option::option_kind
merge_out_of_order	net/tcp.hh	/^bool tcp<InetTraits>::tcb::merge_out_of_order() {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb::tcp::tcb
mss	net/tcp.hh	/^            uint16_t mss;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::receive
mss	net/tcp.hh	/^            uint16_t mss;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::send
mss	net/tcp.hh	/^        packed<uint16_t> mss;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::option_len::mss
mss	net/tcp.hh	/^    enum class option_kind: uint8_t { mss = 2, win_scale = 3, sack = 4, timestamps = 8,  nop = 1, eol = 0 };$/;"	m	class:net::tcp_state::tcp_option::option_kind
mss	net/tcp.hh	/^    enum class option_len:  uint8_t { mss = 4, win_scale = 3, sack = 2, timestamps = 10, nop = 1, eol = 1 };$/;"	m	class:net::tcp_state::tcp_option::option_kind::option_len
mss	net/tcp.hh	/^    struct mss {$/;"	s	class:net::tcp_state::tcp_option::option_kind::option_len
net	net/tcp.hh	/^namespace net {$/;"	n
next	net/tcp.hh	/^            tcp_seq next;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::receive
next	net/tcp.hh	/^            tcp_seq next;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::send
nop	net/tcp.hh	/^    enum class option_kind: uint8_t { mss = 2, win_scale = 3, sack = 4, timestamps = 8,  nop = 1, eol = 0 };$/;"	m	class:net::tcp_state::tcp_option::option_kind
nop	net/tcp.hh	/^    enum class option_len:  uint8_t { mss = 4, win_scale = 3, sack = 2, timestamps = 10, nop = 1, eol = 1 };$/;"	m	class:net::tcp_state::tcp_option::option_kind::option_len
nop	net/tcp.hh	/^    struct nop {$/;"	s	class:net::tcp_state::tcp_option::option_kind::option_len
nr_transmits	net/tcp.hh	/^            unsigned nr_transmits;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::unacked_segment
ntoh	net/tcp.hh	/^inline tcp_seq ntoh(tcp_seq s) {$/;"	f	class:net::tcp_state::tcp_option::option_kind
operator !=	net/tcp.hh	/^inline bool operator!=(tcp_seq s, tcp_seq q) { return !(s == q); }$/;"	f	class:net::tcp_state::tcp_option::option_kind
operator +	net/tcp.hh	/^inline tcp_seq operator+(tcp_seq s, int32_t n) { return s += n; }$/;"	f	class:net::tcp_state::tcp_option::option_kind
operator +=	net/tcp.hh	/^inline tcp_seq& operator+=(tcp_seq& s, int32_t n) { s.raw += n; return s; }$/;"	f	class:net::tcp_state::tcp_option::option_kind
operator +=	net/tcp.hh	/^inline uint8_t& operator+=(uint8_t& x, tcp_option::option_len len) { x += uint8_t(len); return x; }$/;"	f	class:net::tcp_state::tcp_option::option_kind
operator +=	net/tcp.hh	/^inline uint8_t*& operator+=(uint8_t*& x, tcp_option::option_len len) { x += uint8_t(len); return x; }$/;"	f	class:net::tcp_state::tcp_option::option_kind
operator -	net/tcp.hh	/^inline int32_t operator-(tcp_seq s, tcp_seq q) { return s.raw - q.raw; }$/;"	f	class:net::tcp_state::tcp_option::option_kind
operator -	net/tcp.hh	/^inline tcp_seq operator-(tcp_seq s, int32_t n) { return s -= n; }$/;"	f	class:net::tcp_state::tcp_option::option_kind
operator -=	net/tcp.hh	/^inline tcp_seq& operator-=(tcp_seq& s, int32_t n) { s.raw -= n; return s; }$/;"	f	class:net::tcp_state::tcp_option::option_kind
operator <	net/tcp.hh	/^inline bool operator<(tcp_seq s, tcp_seq q) { return s - q < 0; }$/;"	f	class:net::tcp_state::tcp_option::option_kind
operator <<	net/tcp.hh	/^std::ostream& operator<<(std::ostream& os, tcp_seq s) {$/;"	f	class:net::tcp_state::tcp_option::option_kind
operator <=	net/tcp.hh	/^inline bool operator<=(tcp_seq s, tcp_seq q) { return !(s > q); }$/;"	f	class:net::tcp_state::tcp_option::option_kind
operator ==	net/tcp.hh	/^inline bool operator==(tcp_seq s, tcp_seq q)  { return s.raw == q.raw; }$/;"	f	class:net::tcp_state::tcp_option::option_kind
operator >	net/tcp.hh	/^inline bool operator>(tcp_seq s, tcp_seq q) { return q < s; }$/;"	f	class:net::tcp_state::tcp_option::option_kind
operator >=	net/tcp.hh	/^inline bool operator>=(tcp_seq s, tcp_seq q) { return !(s < q); }$/;"	f	class:net::tcp_state::tcp_option::option_kind
operator |	net/tcp.hh	/^inline tcp_state operator|(tcp_state s1, tcp_state s2) {$/;"	f	class:net::tcp_state
option_kind	net/tcp.hh	/^    enum class option_kind: uint8_t { mss = 2, win_scale = 3, sack = 4, timestamps = 8,  nop = 1, eol = 0 };$/;"	c	struct:net::tcp_state::tcp_option
option_len	net/tcp.hh	/^    enum class option_len:  uint8_t { mss = 4, win_scale = 3, sack = 2, timestamps = 10, nop = 1, eol = 1 };$/;"	c	class:net::tcp_state::tcp_option::option_kind
out_of_order	net/tcp.hh	/^            packet_merger<tcp_seq> out_of_order;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::receive
output	net/tcp.hh	/^        void output() {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
output_one	net/tcp.hh	/^void tcp<InetTraits>::tcb::output_one(bool data_retransmit) {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb::tcp::tcb
p	net/tcp.hh	/^            packet p;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::unacked_segment
partial_ack	net/tcp.hh	/^            uint32_t partial_ack = 0;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::send
persist	net/tcp.hh	/^void tcp<InetTraits>::tcb::persist() {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb::tcp::tcb
poll_tcb	net/tcp.hh	/^future<> tcp<InetTraits>::poll_tcb(ipaddr to, lw_shared_ptr<tcb> tcb) {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb::tcp
queue_packet	net/tcp.hh	/^        void queue_packet(packet p) {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
queued_len	net/tcp.hh	/^            uint32_t queued_len = 0;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::send
raw	net/tcp.hh	/^    uint32_t raw;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp_seq
read	net/tcp.hh	/^packet tcp<InetTraits>::tcb::read() {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb::tcp::tcb
receive	net/tcp.hh	/^        struct receive {$/;"	s	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
received	net/tcp.hh	/^void tcp<InetTraits>::received(packet p, ipaddr from, ipaddr to) {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb::tcp
recover	net/tcp.hh	/^            tcp_seq recover;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::send
remove_from_tcbs	net/tcp.hh	/^        void remove_from_tcbs() {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
respond_with_reset	net/tcp.hh	/^void tcp<InetTraits>::respond_with_reset(tcp_hdr* rth, ipaddr local_ip, ipaddr foreign_ip) {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb::tcp
respond_with_reset	net/tcp.hh	/^void tcp<InetTraits>::tcb::respond_with_reset(tcp_hdr* rth) {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb::tcp::tcb
retransmit	net/tcp.hh	/^void tcp<InetTraits>::tcb::retransmit() {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb::tcp::tcb
retransmit_one	net/tcp.hh	/^        void retransmit_one() {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
rsvd1	net/tcp.hh	/^    uint8_t rsvd1 : 4;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp_hdr
rsvd2	net/tcp.hh	/^    uint8_t rsvd2 : 2;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp_hdr
rttvar	net/tcp.hh	/^            std::chrono::milliseconds rttvar;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::send
sack	net/tcp.hh	/^    enum class option_kind: uint8_t { mss = 2, win_scale = 3, sack = 4, timestamps = 8,  nop = 1, eol = 0 };$/;"	m	class:net::tcp_state::tcp_option::option_kind
sack	net/tcp.hh	/^    enum class option_len:  uint8_t { mss = 4, win_scale = 3, sack = 2, timestamps = 10, nop = 1, eol = 1 };$/;"	m	class:net::tcp_state::tcp_option::option_kind::option_len
sack	net/tcp.hh	/^    struct sack {$/;"	s	class:net::tcp_state::tcp_option::option_kind::option_len
segment_acceptable	net/tcp.hh	/^bool tcp<InetTraits>::tcb::segment_acceptable(tcp_seq seg_seq, unsigned seg_len) {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb::tcp::tcb
send	net/tcp.hh	/^        struct send {$/;"	s	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
send	net/tcp.hh	/^future<> tcp<InetTraits>::tcb::send(packet p) {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb::tcp::tcb
send_packet_without_tcb	net/tcp.hh	/^void tcp<InetTraits>::send_packet_without_tcb(ipaddr from, ipaddr to, packet p) {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb::tcp
seq	net/tcp.hh	/^    packed<tcp_seq> seq;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp_hdr
shift	net/tcp.hh	/^        uint8_t shift;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::option_len::win_scale
should_send_ack	net/tcp.hh	/^bool tcp<InetTraits>::tcb::should_send_ack(uint16_t seg_len) {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb::tcp::tcb
signal_data_received	net/tcp.hh	/^        void signal_data_received() {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
src_port	net/tcp.hh	/^    packed<uint16_t> src_port;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp_hdr
srtt	net/tcp.hh	/^            std::chrono::milliseconds srtt;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::send
ssthresh	net/tcp.hh	/^            uint32_t ssthresh;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::send
start_persist_timer	net/tcp.hh	/^        void start_persist_timer() {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
start_persist_timer	net/tcp.hh	/^        void start_persist_timer(clock_type::time_point now) {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
start_retransmit_timer	net/tcp.hh	/^        void start_retransmit_timer() {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
start_retransmit_timer	net/tcp.hh	/^        void start_retransmit_timer(clock_type::time_point now) {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
state	net/tcp.hh	/^        tcp_state& state() {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
stop_persist_timer	net/tcp.hh	/^        void stop_persist_timer() {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
stop_retransmit_timer	net/tcp.hh	/^        void stop_retransmit_timer() {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
syn_retransmit	net/tcp.hh	/^            unsigned syn_retransmit = 0;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::send
syn_tx_time	net/tcp.hh	/^            clock_type::time_point syn_tx_time;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::send
t1	net/tcp.hh	/^        packed<uint32_t> t1;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::option_len::timestamps
t2	net/tcp.hh	/^        packed<uint32_t> t2;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::option_len::timestamps
tcb	net/tcp.hh	/^    class tcb : public enable_lw_shared_from_this<tcb> {$/;"	c	class:net::tcp_state::tcp_option::option_kind::tcp
tcb	net/tcp.hh	/^tcp<InetTraits>::tcb::tcb(tcp& t, connid id)$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb::tcp::tcb
tcp	net/tcp.hh	/^class tcp {$/;"	c	class:net::tcp_state::tcp_option::option_kind
tcp	net/tcp.hh	/^tcp<InetTraits>::tcp(inet_type& inet) : _inet(inet), _e(_rd()) {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb::tcp
tcp_connect_error	net/tcp.hh	/^inline auto tcp_connect_error() {$/;"	f	namespace:net
tcp_debug	net/tcp.hh	/^void tcp_debug(const char* fmt, Args&&... args) {$/;"	f	class:net::tcp_state
tcp_error	net/tcp.hh	/^inline auto tcp_error(int err) {$/;"	f	namespace:net
tcp_hdr	net/tcp.hh	/^struct tcp_hdr {$/;"	s	class:net::tcp_state::tcp_option::option_kind
tcp_option	net/tcp.hh	/^struct tcp_option {$/;"	s	class:net::tcp_state
tcp_refused_error	net/tcp.hh	/^inline auto tcp_refused_error() {$/;"	f	namespace:net
tcp_reset_error	net/tcp.hh	/^inline auto tcp_reset_error() {$/;"	f	namespace:net
tcp_seq	net/tcp.hh	/^struct tcp_seq {$/;"	s	class:net::tcp_state::tcp_option::option_kind
tcp_state	net/tcp.hh	/^enum class tcp_state : uint16_t {$/;"	c	namespace:net
timestamps	net/tcp.hh	/^    enum class option_kind: uint8_t { mss = 2, win_scale = 3, sack = 4, timestamps = 8,  nop = 1, eol = 0 };$/;"	m	class:net::tcp_state::tcp_option::option_kind
timestamps	net/tcp.hh	/^    enum class option_len:  uint8_t { mss = 4, win_scale = 3, sack = 2, timestamps = 10, nop = 1, eol = 1 };$/;"	m	class:net::tcp_state::tcp_option::option_kind::option_len
timestamps	net/tcp.hh	/^    struct timestamps {$/;"	s	class:net::tcp_state::tcp_option::option_kind::option_len
trim_receive_data_after_window	net/tcp.hh	/^void tcp<InetTraits>::tcb::trim_receive_data_after_window() {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb::tcp::tcb
tx_time	net/tcp.hh	/^            clock_type::time_point tx_time;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::unacked_segment
unacked_segment	net/tcp.hh	/^        struct unacked_segment {$/;"	s	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
unacknowledged	net/tcp.hh	/^            tcp_seq unacknowledged;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::send
unsent	net/tcp.hh	/^            std::deque<packet> unsent;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::send
unsent_len	net/tcp.hh	/^            uint32_t unsent_len = 0;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::send
update_cwnd	net/tcp.hh	/^void tcp<InetTraits>::tcb::update_cwnd(uint32_t acked_bytes) {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb::tcp::tcb
update_rto	net/tcp.hh	/^void tcp<InetTraits>::tcb::update_rto(clock_type::time_point tx_time) {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb::tcp::tcb
urgent	net/tcp.hh	/^            tcp_seq urgent;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::receive
urgent	net/tcp.hh	/^            tcp_seq urgent;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::send
urgent	net/tcp.hh	/^    packed<uint16_t> urgent;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp_hdr
user_queue_space	net/tcp.hh	/^            semaphore user_queue_space = {212992};$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::send
wait_for_all_data_acked	net/tcp.hh	/^future<> tcp<InetTraits>::tcb::wait_for_all_data_acked() {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb::tcp::tcb
wait_for_data	net/tcp.hh	/^future<> tcp<InetTraits>::tcb::wait_for_data() {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb::tcp::tcb
win_scale	net/tcp.hh	/^    enum class option_kind: uint8_t { mss = 2, win_scale = 3, sack = 4, timestamps = 8,  nop = 1, eol = 0 };$/;"	m	class:net::tcp_state::tcp_option::option_kind
win_scale	net/tcp.hh	/^    enum class option_len:  uint8_t { mss = 4, win_scale = 3, sack = 2, timestamps = 10, nop = 1, eol = 1 };$/;"	m	class:net::tcp_state::tcp_option::option_kind::option_len
win_scale	net/tcp.hh	/^    struct win_scale {$/;"	s	class:net::tcp_state::tcp_option::option_kind::option_len
window	net/tcp.hh	/^            uint32_t window;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::receive
window	net/tcp.hh	/^            uint32_t window;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::send
window	net/tcp.hh	/^    packed<uint16_t> window;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp_hdr
window_probe	net/tcp.hh	/^            bool window_probe = false;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::send
window_scale	net/tcp.hh	/^            uint8_t window_scale;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::receive
window_scale	net/tcp.hh	/^            uint8_t window_scale;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::send
wl1	net/tcp.hh	/^            tcp_seq wl1;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::send
wl2	net/tcp.hh	/^            tcp_seq wl2;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::send
~connection	net/tcp.hh	/^tcp<InetTraits>::connection::~connection() {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb::tcp::connection
TOEPLITZ_HH_	net/toeplitz.hh	45;"	d
rss_keysize	net/toeplitz.hh	/^constexpr size_t rss_keysize = 40;$/;"	v
rsskey	net/toeplitz.hh	/^static const rss_key_type rsskey = { {$/;"	v
toeplitz_hash	net/toeplitz.hh	/^toeplitz_hash(const rss_key_type& key, const T& data)$/;"	f
_closed	net/udp.cc	/^    bool _closed;$/;"	m	class:net::ipv4_udp_impl::native_channel	file:
_dst	net/udp.cc	/^    ipv4_addr _dst;$/;"	m	class:net::ipv4_udp_impl::native_datagram	file:
_p	net/udp.cc	/^    packet _p;$/;"	m	class:net::ipv4_udp_impl::native_datagram	file:
_proto	net/udp.cc	/^    ipv4_udp& _proto;$/;"	m	class:net::ipv4_udp_impl::native_channel	file:
_reg	net/udp.cc	/^    ipv4_udp::registration _reg;$/;"	m	class:net::ipv4_udp_impl::native_channel	file:
_src	net/udp.cc	/^    ipv4_addr _src;$/;"	m	class:net::ipv4_udp_impl::native_datagram	file:
_state	net/udp.cc	/^    lw_shared_ptr<udp_channel_state> _state;$/;"	m	class:net::ipv4_udp_impl::native_channel	file:
default_queue_size	net/udp.cc	/^const int ipv4_udp::default_queue_size = 1024;$/;"	m	class:net::ipv4_udp	file:
forward	net/udp.cc	/^bool ipv4_udp::forward(forward_hash& out_hash_data, packet& p, size_t off)$/;"	f	class:net::ipv4_udp
ipv4_udp	net/udp.cc	/^ipv4_udp::ipv4_udp(ipv4& inet)$/;"	f	class:net::ipv4_udp
ipv4_udp_impl	net/udp.cc	/^namespace ipv4_udp_impl {$/;"	n	namespace:net	file:
is_closed	net/udp.cc	/^    virtual bool is_closed() const {$/;"	f	class:net::ipv4_udp_impl::native_channel
make_channel	net/udp.cc	/^ipv4_udp::make_channel(ipv4_addr addr) {$/;"	f	class:net::ipv4_udp
native_channel	net/udp.cc	/^    native_channel(ipv4_udp &proto, ipv4_udp::registration reg, lw_shared_ptr<udp_channel_state> state)$/;"	f	class:net::ipv4_udp_impl::native_channel
native_channel	net/udp.cc	/^class native_channel : public udp_channel_impl {$/;"	c	namespace:net::ipv4_udp_impl	file:
native_datagram	net/udp.cc	/^    native_datagram(ipv4_address src, ipv4_address dst, packet p)$/;"	f	class:net::ipv4_udp_impl::native_datagram
native_datagram	net/udp.cc	/^class native_datagram : public udp_datagram_impl {$/;"	c	namespace:net::ipv4_udp_impl	file:
net	net/udp.cc	/^namespace net {$/;"	n	file:
next_port	net/udp.cc	/^uint16_t ipv4_udp::next_port(uint16_t port) {$/;"	f	class:net::ipv4_udp
received	net/udp.cc	/^void ipv4_udp::received(packet p, ipv4_address from, ipv4_address to)$/;"	f	class:net::ipv4_udp
send	net/udp.cc	/^void ipv4_udp::send(uint16_t src_port, ipv4_addr dst, packet &&p, lw_shared_ptr<udp_channel_state> channel)$/;"	f	class:net::ipv4_udp
to_ipv4_addr	net/udp.cc	/^to_ipv4_addr(ipv4_address a, uint16_t port) {$/;"	f	namespace:net::ipv4_udp_impl
UDP_HH_	net/udp.hh	24;"	d
_queue	net/udp.hh	/^    queue<udp_datagram> _queue;$/;"	m	struct:net::udp_channel_state
_user_queue_space	net/udp.hh	/^    semaphore _user_queue_space = {212992};$/;"	m	struct:net::udp_channel_state
adjust_endianness	net/udp.hh	/^    auto adjust_endianness(Adjuster a) {$/;"	f	struct:net::udp_hdr
cksum	net/udp.hh	/^    packed<uint16_t> cksum;$/;"	m	struct:net::udp_hdr
complete_send	net/udp.hh	/^    void complete_send(size_t len) { _user_queue_space.signal(len); }$/;"	f	struct:net::udp_channel_state
dst_port	net/udp.hh	/^    packed<uint16_t> dst_port;$/;"	m	struct:net::udp_hdr
kj_wait_for_send_buffer	net/udp.hh	/^    kj::Promise<void> kj_wait_for_send_buffer(size_t len) { return _user_queue_space.kj_wait(len); }$/;"	f	struct:net::udp_channel_state
len	net/udp.hh	/^    packed<uint16_t> len;$/;"	m	struct:net::udp_hdr
net	net/udp.hh	/^namespace net {$/;"	n
src_port	net/udp.hh	/^    packed<uint16_t> src_port;$/;"	m	struct:net::udp_hdr
udp_channel_state	net/udp.hh	/^    udp_channel_state(size_t queue_size) : _queue(queue_size) {}$/;"	f	struct:net::udp_channel_state
udp_channel_state	net/udp.hh	/^struct udp_channel_state {$/;"	s	namespace:net
udp_hdr	net/udp.hh	/^struct udp_hdr {$/;"	s	namespace:net
wait_for_send_buffer	net/udp.hh	/^    future<> wait_for_send_buffer(size_t len) { return _user_queue_space.wait(len); }$/;"	f	struct:net::udp_channel_state
VIRTIO_INTERFACE_HH_	net/virtio-interface.hh	24;"	d
VIRTIO_NET_F_CSUM	net/virtio-interface.hh	113;"	d
VIRTIO_NET_F_CTRL_GUEST_OFFLOADS	net/virtio-interface.hh	115;"	d
VIRTIO_NET_F_CTRL_MAC_ADDR	net/virtio-interface.hh	132;"	d
VIRTIO_NET_F_CTRL_RX	net/virtio-interface.hh	128;"	d
VIRTIO_NET_F_CTRL_VLAN	net/virtio-interface.hh	129;"	d
VIRTIO_NET_F_CTRL_VQ	net/virtio-interface.hh	127;"	d
VIRTIO_NET_F_GUEST_ANNOUNCE	net/virtio-interface.hh	130;"	d
VIRTIO_NET_F_GUEST_CSUM	net/virtio-interface.hh	114;"	d
VIRTIO_NET_F_GUEST_ECN	net/virtio-interface.hh	119;"	d
VIRTIO_NET_F_GUEST_TSO4	net/virtio-interface.hh	117;"	d
VIRTIO_NET_F_GUEST_TSO6	net/virtio-interface.hh	118;"	d
VIRTIO_NET_F_GUEST_UFO	net/virtio-interface.hh	120;"	d
VIRTIO_NET_F_HOST_ECN	net/virtio-interface.hh	123;"	d
VIRTIO_NET_F_HOST_TSO4	net/virtio-interface.hh	121;"	d
VIRTIO_NET_F_HOST_TSO6	net/virtio-interface.hh	122;"	d
VIRTIO_NET_F_HOST_UFO	net/virtio-interface.hh	124;"	d
VIRTIO_NET_F_MAC	net/virtio-interface.hh	116;"	d
VIRTIO_NET_F_MQ	net/virtio-interface.hh	131;"	d
VIRTIO_NET_F_MRG_RXBUF	net/virtio-interface.hh	125;"	d
VIRTIO_NET_F_STATUS	net/virtio-interface.hh	126;"	d
VIRTIO_RING_F_EVENT_IDX	net/virtio-interface.hh	84;"	d
VIRTIO_RING_F_INDIRECT_DESC	net/virtio-interface.hh	78;"	d
VRING_AVAIL_F_NO_INTERRUPT	net/virtio-interface.hh	75;"	d
VRING_DESC_F_INDIRECT	net/virtio-interface.hh	66;"	d
VRING_DESC_F_NEXT	net/virtio-interface.hh	62;"	d
VRING_DESC_F_WRITE	net/virtio-interface.hh	64;"	d
VRING_USED_F_NO_NOTIFY	net/virtio-interface.hh	71;"	d
_LINUX_VIRTIO_RING_H	net/virtio-interface.hh	27;"	d
_avail	net/virtio.cc	/^    avail _avail;$/;"	m	class:virtio::vring	file:
_avail_added_since_kick	net/virtio.cc	/^        uint16_t _avail_added_since_kick = 0;$/;"	m	struct:virtio::vring::avail	file:
_avail_event	net/virtio.cc	/^    std::atomic<uint16_t>* _avail_event;$/;"	m	class:virtio::vring	file:
_available_descriptors	net/virtio.cc	/^    semaphore _available_descriptors = { 0 };$/;"	m	class:virtio::vring	file:
_buffer_chains	net/virtio.cc	/^    std::unique_ptr<BufferChain[]> _buffer_chains;$/;"	m	class:virtio::vring	file:
_buffers	net/virtio.cc	/^        std::vector<std::unique_ptr<char[], free_deleter>> _buffers;$/;"	m	class:virtio::qp::rxq	file:
_complete	net/virtio.cc	/^    Completion _complete;$/;"	m	class:virtio::vring	file:
_config	net/virtio.cc	/^    ring_config _config;$/;"	m	class:virtio::vring	file:
_descs	net/virtio.cc	/^    desc* _descs;$/;"	m	class:virtio::vring	file:
_dev	net/virtio.cc	/^        qp& _dev;$/;"	m	class:virtio::qp::rxq	file:
_dev	net/virtio.cc	/^        qp& _dev;$/;"	m	class:virtio::qp::txq	file:
_dev	net/virtio.cc	/^    device* _dev;$/;"	m	class:virtio::qp	file:
_features	net/virtio.cc	/^    uint64_t _features;$/;"	m	class:virtio::device	file:
_flags	net/virtio.cc	/^        flags _flags;$/;"	m	class:virtio::vring::desc	file:
_flags	net/virtio.cc	/^        std::atomic<uint16_t> _flags;$/;"	m	struct:virtio::vring::avail_layout	file:
_flags	net/virtio.cc	/^        std::atomic<uint16_t> _flags;$/;"	m	struct:virtio::vring::used_layout	file:
_fragments	net/virtio.cc	/^        std::vector<fragment> _fragments;$/;"	m	class:virtio::qp::rxq	file:
_free_head	net/virtio.cc	/^    int _free_head = -1;$/;"	m	class:virtio::vring	file:
_free_last	net/virtio.cc	/^    int _free_last = -1;$/;"	m	class:virtio::vring	file:
_head	net/virtio.cc	/^        uint16_t _head = 0;$/;"	m	struct:virtio::vring::avail	file:
_header_len	net/virtio.cc	/^    size_t _header_len;$/;"	m	class:virtio::qp	file:
_hw_features	net/virtio.cc	/^    net::hw_features _hw_features;$/;"	m	class:virtio::device	file:
_id	net/virtio.cc	/^        uint32_t _id;$/;"	m	struct:virtio::vring::used_elem	file:
_idx	net/virtio.cc	/^        std::atomic<uint16_t> _idx;$/;"	m	struct:virtio::vring::avail_layout	file:
_idx	net/virtio.cc	/^        std::atomic<uint16_t> _idx;$/;"	m	struct:virtio::vring::used_layout	file:
_kick	net/virtio.cc	/^    writeable_eventfd _kick;$/;"	m	class:virtio::notifier_vhost	file:
_len	net/virtio.cc	/^        uint32_t _len;$/;"	m	class:virtio::vring::desc	file:
_len	net/virtio.cc	/^        uint32_t _len;$/;"	m	struct:virtio::vring::used_elem	file:
_mac	net/virtio.cc	/^    ethernet_address _mac;$/;"	m	class:virtio::qp_osv	file:
_next	net/virtio.cc	/^        uint16_t _next;$/;"	m	class:virtio::vring::desc	file:
_notifier	net/virtio.cc	/^    std::unique_ptr<notifier> _notifier;$/;"	m	class:virtio::vring	file:
_opts	net/virtio.cc	/^    boost::program_options::variables_map _opts;$/;"	m	class:virtio::device	file:
_packets	net/virtio.cc	/^        std::vector<packet_as_buffer_chain> _packets;$/;"	m	class:virtio::qp::txq	file:
_paddr	net/virtio.cc	/^        phys _paddr;$/;"	m	class:virtio::vring::desc	file:
_poller	net/virtio.cc	/^    reactor::poller _poller;$/;"	m	class:virtio::vring	file:
_q_index	net/virtio.cc	/^    uint16_t _q_index;$/;"	m	class:virtio::notifier_osv	file:
_remaining_buffers	net/virtio.cc	/^        unsigned _remaining_buffers = 0;$/;"	m	class:virtio::qp::rxq	file:
_ring	net/virtio.cc	/^        uint16_t _ring[];$/;"	m	struct:virtio::vring::avail_layout	file:
_ring	net/virtio.cc	/^        vring<packet_as_buffer_chain, complete> _ring;$/;"	m	class:virtio::qp::txq	file:
_ring	net/virtio.cc	/^        vring<single_buffer, complete> _ring;$/;"	m	class:virtio::qp::rxq	file:
_rxq	net/virtio.cc	/^    rxq _rxq;$/;"	m	class:virtio::qp	file:
_rxq_storage	net/virtio.cc	/^    std::unique_ptr<char[], free_deleter> _rxq_storage;$/;"	m	class:virtio::qp	file:
_shared	net/virtio.cc	/^        avail_layout* _shared;$/;"	m	struct:virtio::vring::avail	file:
_shared	net/virtio.cc	/^        used_layout* _shared;$/;"	m	struct:virtio::vring::used	file:
_tail	net/virtio.cc	/^        uint16_t _tail = 0;$/;"	m	struct:virtio::vring::used	file:
_txq	net/virtio.cc	/^    txq _txq;$/;"	m	class:virtio::qp	file:
_txq_storage	net/virtio.cc	/^    std::unique_ptr<char[], free_deleter> _txq_storage;$/;"	m	class:virtio::qp	file:
_used	net/virtio.cc	/^    used _used;$/;"	m	class:virtio::vring	file:
_used_elements	net/virtio.cc	/^        used_elem _used_elements[];$/;"	m	struct:virtio::vring::used_layout	file:
_used_event	net/virtio.cc	/^    std::atomic<uint16_t>* _used_event;$/;"	m	class:virtio::vring	file:
_vhost_fd	net/virtio.cc	/^    file_desc _vhost_fd;$/;"	m	class:virtio::qp_vhost	file:
_virtio	net/virtio.cc	/^    osv::assigned_virtio &_virtio;$/;"	m	class:virtio::notifier_osv	file:
_virtio	net/virtio.cc	/^    osv::assigned_virtio &_virtio;$/;"	m	class:virtio::qp_osv	file:
addr	net/virtio.cc	/^    phys addr;$/;"	m	struct:virtio::buffer	file:
allocate_desc	net/virtio.cc	/^vring<BufferChain, Completion>::allocate_desc() {$/;"	f	class:virtio::vring
avail	net/virtio.cc	/^    char* avail;$/;"	m	struct:virtio::ring_config	file:
avail	net/virtio.cc	/^    struct avail {$/;"	s	class:virtio::vring	file:
avail	net/virtio.cc	/^vring<BufferChain, Completion>::avail::avail(ring_config conf)$/;"	f	class:virtio::vring::avail
avail_layout	net/virtio.cc	/^    struct avail_layout {$/;"	s	class:virtio::vring	file:
available_descriptors	net/virtio.cc	/^    semaphore& available_descriptors() { return _available_descriptors; }$/;"	f	class:virtio::vring
begin	net/virtio.cc	/^            auto begin() {$/;"	f	struct:virtio::qp::txq::packet_as_buffer_chain
buf	net/virtio.cc	/^            std::unique_ptr<char[], free_deleter> buf;$/;"	m	struct:virtio::qp::rxq::buffer_and_virt	file:
buffer	net/virtio.cc	/^struct buffer {$/;"	s	namespace:virtio	file:
buffer_and_virt	net/virtio.cc	/^        struct buffer_and_virt : buffer {$/;"	s	class:virtio::qp::rxq	file:
bunch	net/virtio.cc	/^            void bunch(uint64_t c) {$/;"	f	struct:virtio::qp::rxq::complete
bunch	net/virtio.cc	/^            void bunch(uint64_t c) {}$/;"	f	struct:virtio::qp::txq::complete
common_config	net/virtio.cc	/^void qp::common_config(ring_config& r) {$/;"	f	class:virtio::qp
complete	net/virtio.cc	/^        struct complete {$/;"	s	class:virtio::qp::rxq	file:
complete	net/virtio.cc	/^        struct complete {$/;"	s	class:virtio::qp::txq	file:
complete_buffer	net/virtio.cc	/^qp::rxq::complete_buffer(single_buffer&& bc, size_t len) {$/;"	f	class:virtio::qp::rxq
config_ring_size	net/virtio.cc	/^static size_t config_ring_size(boost::program_options::variables_map &opts) {$/;"	f	namespace:virtio
create_virtio_net_device	net/virtio.cc	/^std::unique_ptr<net::device> create_virtio_net_device(boost::program_options::variables_map opts) {$/;"	f
csum_offset	net/virtio.cc	/^        uint16_t csum_offset;$/;"	m	struct:virtio::qp::net_hdr	file:
csum_start	net/virtio.cc	/^        uint16_t csum_start;$/;"	m	struct:virtio::qp::net_hdr	file:
debug_mode_adjust_fragments	net/virtio.cc	/^qp::rxq::debug_mode_adjust_fragments() {$/;"	f	class:virtio::qp::rxq
desc	net/virtio.cc	/^    class desc {$/;"	c	class:virtio::vring	file:
descs	net/virtio.cc	/^    char* descs;$/;"	m	struct:virtio::ring_config	file:
device	net/virtio.cc	/^    device(boost::program_options::variables_map opts)$/;"	f	class:virtio::device
device	net/virtio.cc	/^class device : public net::device {$/;"	c	namespace:virtio	file:
do_complete	net/virtio.cc	/^bool vring<BufferChain, Completion>::do_complete() {$/;"	f	class:virtio::vring
end	net/virtio.cc	/^            auto end() {$/;"	f	struct:virtio::qp::txq::packet_as_buffer_chain
event_index	net/virtio.cc	/^    bool event_index;$/;"	m	struct:virtio::ring_config	file:
features	net/virtio.cc	/^    uint64_t features() {$/;"	f	class:virtio::device
flags	net/virtio.cc	/^        struct flags {$/;"	s	class:virtio::vring::desc	file:
flags	net/virtio.cc	/^        struct flags {$/;"	s	struct:virtio::vring::avail_layout	file:
flags_reserved	net/virtio.cc	/^        uint8_t flags_reserved : 7;$/;"	m	struct:virtio::qp::net_hdr	file:
fragment_to_buffer	net/virtio.cc	/^        static buffer fragment_to_buffer(fragment f) {$/;"	f	class:virtio::qp::txq	file:
get_len	net/virtio.cc	/^        uint32_t get_len() { return _len; }$/;"	f	class:virtio::vring::desc
get_virtio_net_options_description	net/virtio.cc	/^get_virtio_net_options_description()$/;"	f
getconfig	net/virtio.cc	/^        const ring_config& getconfig() {$/;"	f	class:virtio::qp::rxq
getconfig	net/virtio.cc	/^        const ring_config& getconfig() {$/;"	f	class:virtio::qp::txq
getconfig	net/virtio.cc	/^    const ring_config& getconfig() {$/;"	f	class:virtio::vring
gso_ecn	net/virtio.cc	/^        enum { gso_none = 0, gso_tcpv4 = 1, gso_udp = 3, gso_tcpv6 = 4, gso_ecn = 0x80 };$/;"	e	enum:virtio::qp::net_hdr::__anon7	file:
gso_none	net/virtio.cc	/^        enum { gso_none = 0, gso_tcpv4 = 1, gso_udp = 3, gso_tcpv6 = 4, gso_ecn = 0x80 };$/;"	e	enum:virtio::qp::net_hdr::__anon7	file:
gso_size	net/virtio.cc	/^        uint16_t gso_size;$/;"	m	struct:virtio::qp::net_hdr	file:
gso_tcpv4	net/virtio.cc	/^        enum { gso_none = 0, gso_tcpv4 = 1, gso_udp = 3, gso_tcpv6 = 4, gso_ecn = 0x80 };$/;"	e	enum:virtio::qp::net_hdr::__anon7	file:
gso_tcpv6	net/virtio.cc	/^        enum { gso_none = 0, gso_tcpv4 = 1, gso_udp = 3, gso_tcpv6 = 4, gso_ecn = 0x80 };$/;"	e	enum:virtio::qp::net_hdr::__anon7	file:
gso_type	net/virtio.cc	/^        uint8_t gso_type;$/;"	m	struct:virtio::qp::net_hdr	file:
gso_udp	net/virtio.cc	/^        enum { gso_none = 0, gso_tcpv4 = 1, gso_udp = 3, gso_tcpv6 = 4, gso_ecn = 0x80 };$/;"	e	enum:virtio::qp::net_hdr::__anon7	file:
has_next	net/virtio.cc	/^            uint16_t has_next : 1;$/;"	m	struct:virtio::vring::desc::flags	file:
hdr_len	net/virtio.cc	/^        uint16_t hdr_len;$/;"	m	struct:virtio::qp::net_hdr	file:
hw_features	net/virtio.cc	/^    net::hw_features hw_features() {$/;"	f	class:virtio::device
indirect	net/virtio.cc	/^            uint16_t indirect : 1;$/;"	m	struct:virtio::vring::desc::flags	file:
indirect	net/virtio.cc	/^    bool indirect;$/;"	m	struct:virtio::ring_config	file:
init_local_queue	net/virtio.cc	/^std::unique_ptr<net::qp> device::init_local_queue(boost::program_options::variables_map opts, uint16_t qid) {$/;"	f	class:virtio::device
kick	net/virtio.cc	/^    void kick() {$/;"	f	class:virtio::vring	file:
len	net/virtio.cc	/^    uint32_t len;$/;"	m	struct:virtio::buffer	file:
mask	net/virtio.cc	/^    size_t mask() { return size() - 1; }$/;"	f	class:virtio::vring	file:
masked	net/virtio.cc	/^    size_t masked(size_t idx) { return idx & mask(); }$/;"	f	class:virtio::vring	file:
mergable_buffers	net/virtio.cc	/^    bool mergable_buffers;$/;"	m	struct:virtio::ring_config	file:
needs_csum	net/virtio.cc	/^        uint8_t needs_csum : 1;$/;"	m	struct:virtio::qp::net_hdr	file:
net_hdr	net/virtio.cc	/^    struct net_hdr {$/;"	s	class:virtio::qp	file:
net_hdr_mrg	net/virtio.cc	/^    struct net_hdr_mrg : net_hdr {$/;"	s	class:virtio::qp	file:
next_idx	net/virtio.cc	/^        uint16_t next_idx() { return _next; }$/;"	f	class:virtio::vring::desc
no_interrupts	net/virtio.cc	/^            uint16_t no_interrupts : 1;$/;"	m	struct:virtio::vring::avail_layout::flags	file:
no_notify	net/virtio.cc	/^            no_notify = 1$/;"	e	enum:virtio::vring::used_layout::__anon6	file:
notifications_disabled	net/virtio.cc	/^    bool notifications_disabled() {$/;"	f	class:virtio::vring	file:
notifier	net/virtio.cc	/^class notifier {$/;"	c	namespace:virtio	file:
notifier_osv	net/virtio.cc	/^    notifier_osv(osv::assigned_virtio &virtio, uint16_t q_index)$/;"	f	class:virtio::notifier_osv
notifier_osv	net/virtio.cc	/^class notifier_osv : public notifier {$/;"	c	namespace:virtio	file:
notifier_vhost	net/virtio.cc	/^    notifier_vhost(writeable_eventfd &&kick)$/;"	f	class:virtio::notifier_vhost
notifier_vhost	net/virtio.cc	/^class notifier_vhost : public notifier {$/;"	c	namespace:virtio	file:
num_buffers	net/virtio.cc	/^        uint16_t num_buffers;$/;"	m	struct:virtio::qp::net_hdr_mrg	file:
operator ()	net/virtio.cc	/^            void operator()(packet_as_buffer_chain&& bc, size_t len) {$/;"	f	struct:virtio::qp::txq::complete
operator ()	net/virtio.cc	/^            void operator()(single_buffer&& bc, size_t len) {$/;"	f	struct:virtio::qp::rxq::complete
override	net/virtio.cc	/^    virtual std::unique_ptr<net::qp> init_local_queue(boost::program_options::variables_map opts, uint16_t qid) override;$/;"	m	class:virtio::device	file:
override	net/virtio.cc	/^    virtual uint32_t send(circular_buffer<packet>& p) override;$/;"	m	class:virtio::qp	file:
override	net/virtio.cc	/^    virtual void rx_start() override;$/;"	m	class:virtio::qp	file:
p	net/virtio.cc	/^            packet p;$/;"	m	struct:virtio::qp::txq::packet_as_buffer_chain	file:
packet_as_buffer_chain	net/virtio.cc	/^        struct packet_as_buffer_chain {$/;"	s	class:virtio::qp::txq	file:
post	net/virtio.cc	/^qp::txq::post(circular_buffer<packet>& pb) {$/;"	f	class:virtio::qp::txq
post	net/virtio.cc	/^void vring<BufferChain, Completion>::post(Iterator begin, Iterator end) {$/;"	f	class:virtio::vring
prepare_buffers	net/virtio.cc	/^qp::rxq::prepare_buffers() {$/;"	f	class:virtio::qp::rxq
q	net/virtio.cc	/^            rxq& q;$/;"	m	struct:virtio::qp::rxq::complete	file:
q	net/virtio.cc	/^            txq& q;$/;"	m	struct:virtio::qp::txq::complete	file:
qp	net/virtio.cc	/^class qp : public net::qp {$/;"	c	namespace:virtio	file:
qp	net/virtio.cc	/^qp::qp(device* dev, size_t rx_ring_size, size_t tx_ring_size)$/;"	f	class:virtio::qp
qp_osv	net/virtio.cc	/^class qp_osv : public qp {$/;"	c	namespace:virtio	file:
qp_osv	net/virtio.cc	/^qp_osv::qp_osv(device *dev, osv::assigned_virtio &virtio,$/;"	f	class:virtio::qp_osv
qp_vhost	net/virtio.cc	/^class qp_vhost : public qp {$/;"	c	namespace:virtio	file:
qp_vhost	net/virtio.cc	/^qp_vhost::qp_vhost(device *dev, boost::program_options::variables_map opts)$/;"	f	class:virtio::qp_vhost
ring_config	net/virtio.cc	/^struct ring_config {$/;"	s	namespace:virtio	file:
run	net/virtio.cc	/^        void run() {$/;"	f	class:virtio::qp::rxq
rx_start	net/virtio.cc	/^qp::rx_start() {$/;"	f	class:virtio::qp
rxq	net/virtio.cc	/^    class rxq  {$/;"	c	class:virtio::qp	file:
rxq	net/virtio.cc	/^qp::rxq::rxq(qp& dev, ring_config config)$/;"	f	class:virtio::qp::rxq
rxq_config	net/virtio.cc	/^ring_config qp::rxq_config(size_t rx_ring_size) {$/;"	f	class:virtio::qp
send	net/virtio.cc	/^qp::send(circular_buffer<packet>& p) {$/;"	f	class:virtio::qp
set_notifier	net/virtio.cc	/^        void set_notifier(std::unique_ptr<notifier> notifier) {$/;"	f	class:virtio::qp::rxq
set_notifier	net/virtio.cc	/^        void set_notifier(std::unique_ptr<notifier> notifier) {$/;"	f	class:virtio::qp::txq
set_notifier	net/virtio.cc	/^    void set_notifier(std::unique_ptr<notifier> notifier) {$/;"	f	class:virtio::vring
setup	net/virtio.cc	/^void vring<BufferChain, Completion>::setup() {$/;"	f	class:virtio::vring
setup_features	net/virtio.cc	/^    uint64_t setup_features() {$/;"	f	class:virtio::device	file:
size	net/virtio.cc	/^    int size() { return _config.size; }$/;"	f	class:virtio::vring
size	net/virtio.cc	/^    unsigned size;$/;"	m	struct:virtio::ring_config	file:
txq	net/virtio.cc	/^    class txq {$/;"	c	class:virtio::qp	file:
txq	net/virtio.cc	/^qp::txq::txq(qp& dev, ring_config config)$/;"	f	class:virtio::qp::txq
txq_config	net/virtio.cc	/^ring_config qp::txq_config(size_t tx_ring_size) {$/;"	f	class:virtio::qp
update_rx_count	net/virtio.cc	/^        void update_rx_count(uint64_t c) {$/;"	f	class:virtio::qp::rxq
used	net/virtio.cc	/^    char* used;$/;"	m	struct:virtio::ring_config	file:
used	net/virtio.cc	/^    struct used {$/;"	s	class:virtio::vring	file:
used	net/virtio.cc	/^vring<BufferChain, Completion>::used::used(ring_config conf)$/;"	f	class:virtio::vring::used
used_elem	net/virtio.cc	/^    struct used_elem {$/;"	s	class:virtio::vring	file:
used_layout	net/virtio.cc	/^    struct used_layout {$/;"	s	class:virtio::vring	file:
virt_to_phys	net/virtio.cc	/^phys virt_to_phys(void* p) {$/;"	f	namespace:virtio
virtio	net/virtio.cc	/^namespace virtio {$/;"	n	file:
virtio_buffer	net/virtio.cc	/^static std::unique_ptr<char[], free_deleter> virtio_buffer(size_t size) {$/;"	f	namespace:virtio
vring	net/virtio.cc	/^class vring {$/;"	c	namespace:virtio	file:
vring	net/virtio.cc	/^vring<BufferChain, Completion>::vring(ring_config conf, Completion complete)$/;"	f	class:virtio::vring
vring_storage_size	net/virtio.cc	/^size_t qp::vring_storage_size(size_t ring_size) {$/;"	f	class:virtio::qp
wake_notifier_wait	net/virtio.cc	/^        void wake_notifier_wait() {$/;"	f	class:virtio::qp::rxq
wake_notifier_wait	net/virtio.cc	/^        void wake_notifier_wait() {$/;"	f	class:virtio::qp::txq
wake_notifier_wait	net/virtio.cc	/^    void wake_notifier_wait() {$/;"	f	class:virtio::vring
wake_wait	net/virtio.cc	/^    virtual void wake_wait() {$/;"	f	class:virtio::notifier
writeable	net/virtio.cc	/^            uint16_t writeable : 1;$/;"	m	struct:virtio::vring::desc::flags	file:
writeable	net/virtio.cc	/^    bool writeable;$/;"	m	struct:virtio::buffer	file:
~notifier	net/virtio.cc	/^    virtual ~notifier() {$/;"	f	class:virtio::notifier
VIRTIO_HH_	net/virtio.hh	23;"	d
_backend	net/xenfront.cc	/^    std::string _backend;$/;"	m	class:xen::xenfront_qp	file:
_dev	net/xenfront.cc	/^    xenfront_device* _dev;$/;"	m	class:xen::xenfront_qp	file:
_device_str	net/xenfront.cc	/^    std::string _device_str;$/;"	m	class:xen::xenfront_device	file:
_evtchn	net/xenfront.cc	/^    evtchn   *_evtchn;$/;"	m	class:xen::xenfront_qp	file:
_features	net/xenfront.cc	/^    std::unordered_map<std::string, int> _features;$/;"	m	class:xen::xenfront_qp	file:
_gntalloc	net/xenfront.cc	/^    gntalloc *_gntalloc;$/;"	m	class:xen::xenfront_qp	file:
_hw_address	net/xenfront.cc	/^    ethernet_address _hw_address;$/;"	m	class:xen::xenfront_device	file:
_hw_features	net/xenfront.cc	/^    net::hw_features _hw_features;$/;"	m	class:xen::xenfront_device	file:
_otherend	net/xenfront.cc	/^    unsigned _otherend;$/;"	m	class:xen::xenfront_qp	file:
_rx_evtchn	net/xenfront.cc	/^    port _rx_evtchn;$/;"	m	class:xen::xenfront_qp	file:
_rx_refs	net/xenfront.cc	/^    grant_head *_rx_refs;$/;"	m	class:xen::xenfront_qp	file:
_rx_ring	net/xenfront.cc	/^    front_ring<rx> _rx_ring;$/;"	m	class:xen::xenfront_qp	file:
_supported_features	net/xenfront.cc	/^    static std::unordered_map<std::string, std::string> _supported_features;$/;"	m	class:xen::xenfront_qp	file:
_supported_features	net/xenfront.cc	/^xenfront_qp::_supported_features = {$/;"	m	class:xen::xenfront_qp	file:
_tx_evtchn	net/xenfront.cc	/^    port _tx_evtchn;$/;"	m	class:xen::xenfront_qp	file:
_tx_refs	net/xenfront.cc	/^    grant_head *_tx_refs;$/;"	m	class:xen::xenfront_qp	file:
_tx_ring	net/xenfront.cc	/^    front_ring<tx> _tx_ring;$/;"	m	class:xen::xenfront_qp	file:
_userspace	net/xenfront.cc	/^    bool _userspace;$/;"	m	class:xen::xenfront_device	file:
_xenstore	net/xenfront.cc	/^    xenstore* _xenstore = xenstore::instance();$/;"	m	class:xen::xenfront_device	file:
alloc_one_rx_reference	net/xenfront.cc	/^void xenfront_qp::alloc_one_rx_reference(unsigned index) {$/;"	f	class:xen::xenfront_qp
alloc_rx_references	net/xenfront.cc	/^future<> xenfront_qp::alloc_rx_references() {$/;"	f	class:xen::xenfront_qp
bind_rx_evtchn	net/xenfront.cc	/^port xenfront_qp::bind_rx_evtchn(bool split) {$/;"	f	class:xen::xenfront_qp
bind_tx_evtchn	net/xenfront.cc	/^port xenfront_qp::bind_tx_evtchn(bool split) {$/;"	f	class:xen::xenfront_qp
create_xenfront_net_device	net/xenfront.cc	/^std::unique_ptr<net::device> create_xenfront_net_device(boost::program_options::variables_map opts, bool userspace) {$/;"	f	namespace:xen
free_index	net/xenfront.cc	/^void front_ring<T>::entries::free_index(unsigned id) {$/;"	f	class:xen::front_ring::entries
get_index	net/xenfront.cc	/^unsigned front_ring<T>::entries::get_index() {$/;"	f	class:xen::front_ring::entries
get_xenfront_net_options_description	net/xenfront.cc	/^get_xenfront_net_options_description() {$/;"	f	namespace:xen
handle_tx_completions	net/xenfront.cc	/^future<> xenfront_qp::handle_tx_completions() {$/;"	f	class:xen::xenfront_qp
has_room	net/xenfront.cc	/^future<> front_ring<T>::entries::has_room() {$/;"	f	class:xen::front_ring::entries
inc_rx_error_count	net/xenfront.cc	/^    void inc_rx_error_count() { ++_stats.rx.bad.total; }$/;"	f	class:xen::xenfront_qp
init_local_queue	net/xenfront.cc	/^std::unique_ptr<qp> xenfront_device::init_local_queue(boost::program_options::variables_map opts, uint16_t qid) {$/;"	f	class:xen::xenfront_device
override	net/xenfront.cc	/^    virtual future<> send(packet p) override;$/;"	m	class:xen::xenfront_qp	file:
override	net/xenfront.cc	/^    virtual std::unique_ptr<qp> init_local_queue(boost::program_options::variables_map opts, uint16_t qid) override;$/;"	m	class:xen::xenfront_device	file:
override	net/xenfront.cc	/^    virtual void rx_start() override;$/;"	m	class:xen::xenfront_qp	file:
path	net/xenfront.cc	/^    std::string path(std::string s) { return _dev->path(s); }$/;"	f	class:xen::xenfront_qp	file:
path	net/xenfront.cc	/^    std::string path(std::string s) { return _device_str + "\/" + s; }$/;"	f	class:xen::xenfront_device
process_ring	net/xenfront.cc	/^void front_ring<T>::process_ring(std::function<bool (gntref &entry, T& el)> func, grant_head *refs)$/;"	f	class:xen::front_ring
queue_rx_packet	net/xenfront.cc	/^future<> xenfront_qp::queue_rx_packet()$/;"	f	class:xen::xenfront_qp
rmb	net/xenfront.cc	202;"	d	file:
rx_start	net/xenfront.cc	/^xenfront_qp::rx_start() {$/;"	f	class:xen::xenfront_qp
send	net/xenfront.cc	/^xenfront_qp::send(packet _p) {$/;"	f	class:xen::xenfront_qp
wmb	net/xenfront.cc	203;"	d	file:
xen	net/xenfront.cc	/^namespace xen {$/;"	n	file:
xenfront_device	net/xenfront.cc	/^    xenfront_device(boost::program_options::variables_map opts, bool userspace)$/;"	f	class:xen::xenfront_device
xenfront_device	net/xenfront.cc	/^class xenfront_device : public device {$/;"	c	namespace:xen	file:
xenfront_qp	net/xenfront.cc	/^class xenfront_qp : public net::qp {$/;"	c	namespace:xen	file:
xenfront_qp	net/xenfront.cc	/^xenfront_qp::xenfront_qp(xenfront_device* dev, boost::program_options::variables_map opts)$/;"	f	class:xen::xenfront_qp
~xenfront_qp	net/xenfront.cc	/^xenfront_qp::~xenfront_qp() {$/;"	f	class:xen::xenfront_qp
XENFRONT_HH_	net/xenfront.hh	23;"	d
_available	net/xenfront.hh	/^        semaphore _available = { front_ring::nr_ents };$/;"	m	class:xen::front_ring::entries
_dev	net/xenfront.hh	/^    xenfront_qp& _dev;$/;"	m	class:xen::front_ring
_entries	net/xenfront.hh	/^        std::array<gntref, front_ring<T>::nr_ents> _entries;$/;"	m	class:xen::front_ring::entries
_ids	net/xenfront.hh	/^        std::queue<unsigned, circular_buffer<unsigned>> _ids;$/;"	m	class:xen::front_ring::entries
_next_idx	net/xenfront.hh	/^        std::atomic<uint32_t> _next_idx = { 0 };$/;"	m	class:xen::front_ring::entries
_ring	net/xenfront.hh	/^        front_ring<T> *_ring;$/;"	m	class:xen::front_ring::entries
_ring	net/xenfront.hh	/^    T _ring[1];$/;"	m	class:xen::sring
_sring	net/xenfront.hh	/^    sring<T> *_sring;$/;"	m	class:xen::front_ring
csum_blank	net/xenfront.hh	/^        uint16_t csum_blank : 1;$/;"	m	struct:xen::netif_tx_request::__anon8
data_validated	net/xenfront.hh	/^        uint16_t data_validated : 1;$/;"	m	struct:xen::netif_tx_request::__anon8
dump	net/xenfront.hh	/^    void dump() {$/;"	f	class:xen::front_ring
dump	net/xenfront.hh	/^    void dump() {$/;"	f	class:xen::sring
dump	net/xenfront.hh	/^    void dump(const char *str, netif_rx_response &r) {$/;"	f	class:xen::front_ring
dump	net/xenfront.hh	/^    void dump(const char *str, netif_tx_response &r) {$/;"	f	class:xen::front_ring
entries	net/xenfront.hh	/^        entries(front_ring<T> *ring) : _ring(ring) {}$/;"	f	class:xen::front_ring::entries
entries	net/xenfront.hh	/^    class entries {$/;"	c	class:xen::front_ring
entries	net/xenfront.hh	/^    entries entries;$/;"	m	class:xen::front_ring
extra_info	net/xenfront.hh	/^        uint16_t extra_info : 1;$/;"	m	struct:xen::netif_tx_request::__anon8
flags	net/xenfront.hh	/^    uint16_t flags;        \/* NETRXF_* *\/$/;"	m	struct:xen::netif_rx_response
flags	net/xenfront.hh	/^    } flags;$/;"	m	struct:xen::netif_tx_request	typeref:struct:xen::netif_tx_request::__anon8
front_ring	net/xenfront.hh	/^    front_ring(gntref r, xenfront_qp& dev)$/;"	f	class:xen::front_ring
front_ring	net/xenfront.hh	/^class front_ring {$/;"	c	namespace:xen
gref	net/xenfront.hh	/^    uint32_t gref;$/;"	m	struct:xen::netif_rx_request
gref	net/xenfront.hh	/^    uint32_t gref;$/;"	m	struct:xen::netif_tx_request
id	net/xenfront.hh	/^    uint16_t id;$/;"	m	struct:xen::netif_rx_request
id	net/xenfront.hh	/^    uint16_t id;$/;"	m	struct:xen::netif_rx_response
id	net/xenfront.hh	/^    uint16_t id;$/;"	m	struct:xen::netif_tx_request
id	net/xenfront.hh	/^    uint16_t id;$/;"	m	struct:xen::netif_tx_response
idx	net/xenfront.hh	/^    static uint32_t idx(int i) { return i & (nr_ents - 1); }$/;"	f	class:xen::front_ring
more_data	net/xenfront.hh	/^        uint16_t more_data : 1;$/;"	m	struct:xen::netif_tx_request::__anon8
netif_rx_request	net/xenfront.hh	/^struct netif_rx_request {$/;"	s	namespace:xen
netif_rx_response	net/xenfront.hh	/^struct netif_rx_response {$/;"	s	namespace:xen
netif_tx_request	net/xenfront.hh	/^struct netif_tx_request {$/;"	s	namespace:xen
netif_tx_response	net/xenfront.hh	/^struct netif_tx_response {$/;"	s	namespace:xen
nr_ents	net/xenfront.hh	/^    static constexpr uint32_t nr_ents = 256; \/* FIXME : DYN *\/$/;"	m	class:xen::front_ring
offset	net/xenfront.hh	/^    uint16_t offset;       \/* Offset in page of start of received packet  *\/$/;"	m	struct:xen::netif_rx_response
offset	net/xenfront.hh	/^    uint16_t offset;$/;"	m	struct:xen::netif_tx_request
operator []	net/xenfront.hh	/^        gntref& operator[](std::size_t i) { return _entries[_ring->idx(i)]; }$/;"	f	class:xen::front_ring::entries
operator []	net/xenfront.hh	/^    T& operator[](std::size_t i) { return _sring->_ring[idx(i)]; }$/;"	f	class:xen::front_ring
pad	net/xenfront.hh	/^        uint16_t pad : 12;$/;"	m	struct:xen::netif_tx_request::__anon8
pad	net/xenfront.hh	/^    uint8_t  pad[48] = { 0 };$/;"	m	class:xen::sring
ref	net/xenfront.hh	/^    int32_t  ref = -1;$/;"	m	class:xen::front_ring
req	net/xenfront.hh	/^    struct netif_rx_request  req;$/;"	m	union:xen::rx	typeref:struct:xen::rx::netif_rx_request
req	net/xenfront.hh	/^    struct netif_tx_request  req;$/;"	m	union:xen::tx	typeref:struct:xen::tx::netif_tx_request
req_event	net/xenfront.hh	/^    uint32_t req_event = 1;$/;"	m	class:xen::sring
req_prod	net/xenfront.hh	/^    uint32_t req_prod = 0;$/;"	m	class:xen::sring
req_prod_pvt	net/xenfront.hh	/^    uint32_t req_prod_pvt = 0;$/;"	m	class:xen::front_ring
rsp	net/xenfront.hh	/^    struct netif_rx_response rsp;$/;"	m	union:xen::rx	typeref:struct:xen::rx::netif_rx_response
rsp	net/xenfront.hh	/^    struct netif_tx_response rsp;$/;"	m	union:xen::tx	typeref:struct:xen::tx::netif_tx_response
rsp_cons	net/xenfront.hh	/^    uint32_t rsp_cons = 0;$/;"	m	class:xen::front_ring
rsp_event	net/xenfront.hh	/^    uint32_t rsp_event = 1;$/;"	m	class:xen::sring
rsp_prod	net/xenfront.hh	/^    uint32_t rsp_prod = 0;$/;"	m	class:xen::sring
rx	net/xenfront.hh	/^union rx {$/;"	u	namespace:xen
size	net/xenfront.hh	/^    uint16_t size;$/;"	m	struct:xen::netif_tx_request
sring	net/xenfront.hh	/^class sring {$/;"	c	namespace:xen
status	net/xenfront.hh	/^    int16_t  status;       \/* -ve: NETIF_RSP_* ; +ve: Rx'ed response size. *\/$/;"	m	struct:xen::netif_rx_response
status	net/xenfront.hh	/^    int16_t  status;$/;"	m	struct:xen::netif_tx_response
tx	net/xenfront.hh	/^union tx {$/;"	u	namespace:xen
xen	net/xenfront.hh	/^namespace xen {$/;"	n
no_wait	rpc/rpc.cc	/^  no_wait_type no_wait;$/;"	m	namespace:rpc	file:
rpc	rpc/rpc.cc	/^namespace rpc {$/;"	n	file:
SerializerConcept	rpc/rpc.hh	/^struct SerializerConcept {$/;"	s	namespace:rpc
_connected	rpc/rpc.hh	/^        promise<> _connected;$/;"	m	class:rpc::protocol::client
_error	rpc/rpc.hh	/^        bool _error = false;$/;"	m	class:rpc::protocol::connection
_fd	rpc/rpc.hh	/^        connected_socket _fd;$/;"	m	class:rpc::protocol::connection
_info	rpc/rpc.hh	/^            client_info _info;$/;"	m	class:rpc::protocol::server::connection
_logger	rpc/rpc.hh	/^    std::function<void(const sstring&)> _logger;$/;"	m	class:rpc::protocol
_message_id	rpc/rpc.hh	/^        id_type _message_id = 1;$/;"	m	class:rpc::protocol::client
_output_ready	rpc/rpc.hh	/^        future<> _output_ready = make_ready_future<>();$/;"	m	class:rpc::protocol::connection
_outstanding	rpc/rpc.hh	/^        std::unordered_map<id_type, std::unique_ptr<reply_handler_base>> _outstanding;$/;"	m	class:rpc::protocol::client
_proto	rpc/rpc.hh	/^        protocol& _proto;$/;"	m	class:rpc::protocol::connection
_proto	rpc/rpc.hh	/^        protocol& _proto;$/;"	m	class:rpc::protocol::server
_rcv_msg_id	rpc/rpc.hh	/^        id_type _rcv_msg_id = 0;$/;"	m	class:rpc::protocol::client
_read_buf	rpc/rpc.hh	/^        input_stream<char> _read_buf;$/;"	m	class:rpc::protocol::connection
_serializer	rpc/rpc.hh	/^    Serializer _serializer;$/;"	m	class:rpc::protocol
_server	rpc/rpc.hh	/^            server& _server;$/;"	m	class:rpc::protocol::server::connection
_stats	rpc/rpc.hh	/^        stats _stats;$/;"	m	class:rpc::protocol::client
_type	rpc/rpc.hh	/^            MsgType _type;$/;"	m	class:rpc::protocol::server::connection
_write_buf	rpc/rpc.hh	/^        output_stream<char> _write_buf;$/;"	m	class:rpc::protocol::connection
addr	rpc/rpc.hh	/^    socket_address addr;$/;"	m	struct:rpc::client_info
client	rpc/rpc.hh	/^    class client : public protocol::connection {$/;"	c	class:rpc::protocol
client_info	rpc/rpc.hh	/^struct client_info {$/;"	s	namespace:rpc
closed_error	rpc/rpc.hh	/^    closed_error() : error("connection is closed") {}$/;"	f	class:rpc::closed_error
closed_error	rpc/rpc.hh	/^class closed_error : public error {$/;"	c	namespace:rpc
connection	rpc/rpc.hh	/^        class connection : public protocol::connection, public enable_lw_shared_from_this<connection> {$/;"	c	class:rpc::protocol::server
connection	rpc/rpc.hh	/^        connection(connected_socket&& fd, protocol& proto) : _fd(std::move(fd)), _read_buf(_fd.input()), _write_buf(_fd.output()), _proto(proto) {}$/;"	f	class:rpc::protocol::connection
connection	rpc/rpc.hh	/^        connection(protocol& proto) : _proto(proto) {}$/;"	f	class:rpc::protocol::connection
connection	rpc/rpc.hh	/^    class connection {$/;"	c	class:rpc::protocol
error	rpc/rpc.hh	/^        bool error() { return _error; }$/;"	f	class:rpc::protocol::connection
error	rpc/rpc.hh	/^    error(const std::string& msg) : std::runtime_error(msg) {}$/;"	f	class:rpc::error
error	rpc/rpc.hh	/^class error : public std::runtime_error {$/;"	c	namespace:rpc
exception_received	rpc/rpc.hh	/^            counter_type exception_received = 0;$/;"	m	struct:rpc::protocol::client::stats
final	rpc/rpc.hh	/^        struct reply_handler final : reply_handler_base {$/;"	s	class:rpc::protocol::client
func	rpc/rpc.hh	/^            Func func;$/;"	m	struct:rpc::protocol::client::final
get_protocol	rpc/rpc.hh	/^        auto& get_protocol() { return _proto; }$/;"	f	class:rpc::protocol::connection
get_stats	rpc/rpc.hh	/^        stats get_stats() const {$/;"	f	class:rpc::protocol::client
get_stats_internal	rpc/rpc.hh	/^        stats& get_stats_internal() {$/;"	f	class:rpc::protocol::client
in	rpc/rpc.hh	/^        auto& in() { return _read_buf; }$/;"	f	class:rpc::protocol::connection
info	rpc/rpc.hh	/^            auto& info() { return _info; }$/;"	f	class:rpc::protocol::server::connection
log	rpc/rpc.hh	/^    void log(const client_info& info, id_type msg_id, const sstring& str) {$/;"	f	class:rpc::protocol
log	rpc/rpc.hh	/^    void log(const sstring& str) {$/;"	f	class:rpc::protocol
next_message_id	rpc/rpc.hh	/^        auto next_message_id() { return _message_id++; }$/;"	f	class:rpc::protocol::client
no_wait_type	rpc/rpc.hh	/^struct no_wait_type {};$/;"	s	namespace:rpc
out	rpc/rpc.hh	/^        auto& out() { return _write_buf; }$/;"	f	class:rpc::protocol::connection
out_ready	rpc/rpc.hh	/^        auto& out_ready() { return _output_ready; }$/;"	f	class:rpc::protocol::connection
pending	rpc/rpc.hh	/^            counter_type pending = 0;$/;"	m	struct:rpc::protocol::client::stats
protocol	rpc/rpc.hh	/^    protocol(Serializer&& serializer) : _serializer(std::forward<Serializer>(serializer)) {}$/;"	f	class:rpc::protocol
protocol	rpc/rpc.hh	/^class protocol {$/;"	c	namespace:rpc
register_receiver	rpc/rpc.hh	/^    void register_receiver(MsgType t, rpc_handler&& handler) {$/;"	f	class:rpc::protocol
reply	rpc/rpc.hh	/^            Reply reply;$/;"	m	struct:rpc::protocol::client::final
reply_handler	rpc/rpc.hh	/^            reply_handler(Func&& f) : func(std::move(f)) {}$/;"	f	struct:rpc::protocol::client::final
reply_handler_base	rpc/rpc.hh	/^        struct reply_handler_base {$/;"	s	class:rpc::protocol::client
rpc	rpc/rpc.hh	/^namespace rpc {$/;"	n
sent_messages	rpc/rpc.hh	/^            counter_type sent_messages = 0;$/;"	m	struct:rpc::protocol::client::stats
serializer	rpc/rpc.hh	/^        auto& serializer() { return _proto._serializer; }$/;"	f	class:rpc::protocol::connection
server	rpc/rpc.hh	/^    class server {$/;"	c	class:rpc::protocol
set_logger	rpc/rpc.hh	/^    void set_logger(std::function<void(const sstring&)> logger) {$/;"	f	class:rpc::protocol
stats	rpc/rpc.hh	/^        struct stats {$/;"	s	class:rpc::protocol::client
wait_for_reply	rpc/rpc.hh	/^        void wait_for_reply(id_type id, std::unique_ptr<reply_handler_base>&& h) {$/;"	f	class:rpc::protocol::client
wait_reply	rpc/rpc.hh	/^            counter_type wait_reply = 0;$/;"	m	struct:rpc::protocol::client::stats
~reply_handler	rpc/rpc.hh	/^            virtual ~reply_handler() {}$/;"	f	struct:rpc::protocol::client::final
~reply_handler_base	rpc/rpc.hh	/^            virtual ~reply_handler_base() {};$/;"	f	struct:rpc::protocol::client::reply_handler_base
U	rpc/rpc_impl.hh	/^        U() {}$/;"	f	union:rpc::in_message::U
U	rpc/rpc_impl.hh	/^        U() {}$/;"	f	union:rpc::reply_payload::U
U	rpc/rpc_impl.hh	/^    union U {$/;"	u	struct:rpc::in_message
U	rpc/rpc_impl.hh	/^    union U {$/;"	u	struct:rpc::reply_payload
accept	rpc/rpc_impl.hh	/^void protocol<Serializer, MsgType>::server::accept(server_socket&& ss) {$/;"	f	class:rpc::protocol::server
apply	rpc/rpc_impl.hh	/^inline future<std::unique_ptr<snd_reply<Serializer, MsgType, Ret>>> apply(Func& func, client_info& info, std::unique_ptr<in_message<MsgType, M...>>&& m) {$/;"	f	namespace:rpc
args	rpc/rpc_impl.hh	/^        args_type args;$/;"	m	union:rpc::in_message::U
args	rpc/rpc_impl.hh	/^    std::tuple<T...> args;$/;"	m	struct:rpc::out_message
assert_type	rpc/rpc_impl.hh	/^inline void assert_type() {$/;"	f	namespace:rpc
build_msg_type	rpc/rpc_impl.hh	/^struct build_msg_type<Ft, At&&> {$/;"	s	namespace:rpc
build_msg_type	rpc/rpc_impl.hh	/^struct build_msg_type<Ft, At&> {$/;"	s	namespace:rpc
client	rpc/rpc_impl.hh	/^protocol<Serializer, MsgType>::client::client(protocol<Serializer, MsgType>& proto, ipv4_addr addr, ipv4_addr local) : protocol<Serializer, MsgType>::connection(proto) {$/;"	f	class:rpc::protocol::client
client_type	rpc/rpc_impl.hh	/^class client_type {$/;"	c	namespace:rpc
client_type_helper	rpc/rpc_impl.hh	/^struct client_type_helper {$/;"	s	namespace:rpc
client_type_helper	rpc/rpc_impl.hh	/^struct client_type_helper<Ret, First, Args...> {$/;"	s	namespace:rpc
client_type_helper	rpc/rpc_impl.hh	/^struct client_type_helper<Ret, client_info, Args...> {$/;"	s	namespace:rpc
client_type_helper	rpc/rpc_impl.hh	/^struct client_type_helper<Ret, const client_info&, Args...> {$/;"	s	namespace:rpc
client_type_impl	rpc/rpc_impl.hh	/^struct client_type_impl<F, std::integer_sequence<std::size_t, I...>> {$/;"	s	namespace:rpc
connection	rpc/rpc_impl.hh	/^protocol<Serializer, MsgType>::server::connection::connection(protocol<Serializer, MsgType>::server& s, connected_socket&& fd, socket_address&& addr, protocol<Serializer, MsgType>& proto)$/;"	f	class:rpc::protocol::server::connection
deleter	rpc/rpc_impl.hh	/^    inline void deleter(std::index_sequence<I...>) {$/;"	f	struct:rpc::in_message
done	rpc/rpc_impl.hh	/^    bool done = false;$/;"	m	struct:rpc::rcv_reply_base
ex	rpc/rpc_impl.hh	/^    sstring ex;$/;"	m	struct:rpc::reply_payload_base
get_reply	rpc/rpc_impl.hh	/^    inline future<> get_reply(typename protocol<Serializer, MsgType>::client& dst) {$/;"	f	struct:rpc::rcv_reply
id	rpc/rpc_impl.hh	/^    id_type id = 0;$/;"	m	struct:rpc::out_message
id	rpc/rpc_impl.hh	/^    id_type id;$/;"	m	struct:rpc::snd_reply_base
in_message	rpc/rpc_impl.hh	/^struct in_message {$/;"	s	namespace:rpc
info	rpc/rpc_impl.hh	/^    static constexpr bool info = ctype::info; \/\/ true if client_info is a first parameter of rpc handler$/;"	m	class:rpc::client_type
info	rpc/rpc_impl.hh	/^    static constexpr bool info = false;$/;"	m	struct:rpc::client_type_helper
info	rpc/rpc_impl.hh	/^    static constexpr bool info = true;$/;"	m	struct:rpc::client_type_helper
lref_to_cref	rpc/rpc_impl.hh	/^auto lref_to_cref(T& x) {$/;"	f	namespace:rpc
lref_to_cref	rpc/rpc_impl.hh	/^auto lref_to_cref(T&& x) {$/;"	f	namespace:rpc
make_apply_args	rpc/rpc_impl.hh	/^inline auto make_apply_args(client_info& info, std::unique_ptr<in_message<MsgType, M...>>& m, std::enable_if_t<!Info, void*> = nullptr) {$/;"	f	namespace:rpc
make_apply_args	rpc/rpc_impl.hh	/^inline auto make_apply_args(client_info& info, std::unique_ptr<in_message<MsgType, M...>>& m, std::enable_if_t<Info, void*> = nullptr) {$/;"	f	namespace:rpc
make_client	rpc/rpc_impl.hh	/^auto protocol<Serializer, MsgType>::make_client(MsgType t) {$/;"	f	class:rpc::protocol
make_copyable_function	rpc/rpc_impl.hh	/^auto make_copyable_function(Func&& func, std::enable_if_t<!std::is_copy_constructible<std::decay_t<Func>>::value, void*> = nullptr) {$/;"	f	namespace:rpc
make_copyable_function	rpc/rpc_impl.hh	/^auto make_copyable_function(Func&& func, std::enable_if_t<std::is_copy_constructible<std::decay_t<Func>>::value, void*> = nullptr) {$/;"	f	namespace:rpc
make_send_exception	rpc/rpc_impl.hh	/^inline auto make_send_exception(Ex&& ex) {$/;"	f	namespace:rpc
make_send_exception_helper	rpc/rpc_impl.hh	/^template<typename Ex, typename... T> struct make_send_exception_helper {$/;"	s	namespace:rpc
make_send_exception_helper	rpc/rpc_impl.hh	/^template<typename Ex, typename... T> struct make_send_exception_helper<Ex, future<T...>> {$/;"	s	namespace:rpc
make_send_exception_helper	rpc/rpc_impl.hh	/^template<typename Ex> struct make_send_exception_helper<Ex, no_wait_type> {$/;"	s	namespace:rpc
make_send_exception_helper	rpc/rpc_impl.hh	/^template<typename Ex> struct make_send_exception_helper<Ex, void> {$/;"	s	namespace:rpc
marshall	rpc/rpc_impl.hh	/^inline std::enable_if_t<N != sizeof...(T), future<>> marshall(Serializer& serialize, output_stream<char>& out, std::tuple<T...>&& args) {$/;"	f	namespace:rpc
marshall	rpc/rpc_impl.hh	/^inline std::enable_if_t<N == sizeof...(T), future<>> marshall(Serializer&, output_stream<char>& out, std::tuple<T...>&&) {$/;"	f	namespace:rpc
operator ()	rpc/rpc_impl.hh	/^    auto operator()(Ex&& ex) {$/;"	f	struct:rpc::make_send_exception_helper
out_message	rpc/rpc_impl.hh	/^    out_message(MsgType xt, id_type xid, T&&... xargs) : t(xt), id(xid), args(std::forward<T>(xargs)...) {}$/;"	f	struct:rpc::out_message
out_message	rpc/rpc_impl.hh	/^struct out_message {$/;"	s	namespace:rpc
p	rpc/rpc_impl.hh	/^    promise<T...> p;$/;"	m	struct:rpc::rcv_reply_base
pad	rpc/rpc_impl.hh	/^        typename std::aligned_storage<sizeof(T), alignof(T)>::type pad;$/;"	m	union:rpc::reply_payload::U
process	rpc/rpc_impl.hh	/^future<> protocol<Serializer, MsgType>::server::connection::process() {$/;"	f	class:rpc::protocol::server::connection
rcv_reply	rpc/rpc_impl.hh	/^struct rcv_reply : rcv_reply_base<T, T> {$/;"	s	namespace:rpc
rcv_reply	rpc/rpc_impl.hh	/^struct rcv_reply<Serializer, MsgType, future<>> : rcv_reply<Serializer, MsgType, void> {};$/;"	s	namespace:rpc
rcv_reply	rpc/rpc_impl.hh	/^struct rcv_reply<Serializer, MsgType, future<T...>> : rcv_reply_base<std::tuple<T...>, T...> {$/;"	s	namespace:rpc
rcv_reply	rpc/rpc_impl.hh	/^struct rcv_reply<Serializer, MsgType, void> : rcv_reply_base<void, void> {$/;"	s	namespace:rpc
rcv_reply_base	rpc/rpc_impl.hh	/^struct rcv_reply_base : reply_payload<Payload> {$/;"	s	namespace:rpc
ready	rpc/rpc_impl.hh	/^    bool ready[sizeof...(T)] = {};$/;"	m	struct:rpc::in_message
recv_helper	rpc/rpc_impl.hh	/^auto recv_helper(std::index_sequence<I...>, Func&& func) {$/;"	f	namespace:rpc
ref_tuple	rpc/rpc_impl.hh	/^inline std::tuple<T&...> ref_tuple(std::tuple<T...>& t) {$/;"	f	namespace:rpc
ref_tuple_impl	rpc/rpc_impl.hh	/^inline std::tuple<T&...> ref_tuple_impl(std::tuple<T...>& t, std::index_sequence<I...>) {$/;"	f	namespace:rpc
register_handler	rpc/rpc_impl.hh	/^auto protocol<Serializer, MsgType>::register_handler(MsgType t, Func&& func) {$/;"	f	class:rpc::protocol
reply	rpc/rpc_impl.hh	/^    inline future<> reply(typename protocol<Serializer, MsgType>::server::connection& client) {$/;"	f	struct:rpc::snd_reply
reply	rpc/rpc_impl.hh	/^inline future<> reply(std::unique_ptr<snd_reply<Serializer, MsgType, Ret>>& r, typename protocol<Serializer, MsgType>::server::connection& client) {$/;"	f	namespace:rpc
reply_payload	rpc/rpc_impl.hh	/^struct reply_payload : reply_payload_base {$/;"	s	namespace:rpc
reply_payload	rpc/rpc_impl.hh	/^struct reply_payload<void> : reply_payload_base {$/;"	s	namespace:rpc
reply_payload_base	rpc/rpc_impl.hh	/^struct reply_payload_base {$/;"	s	namespace:rpc
rpc	rpc/rpc_impl.hh	/^namespace rpc {$/;"	n
send_ex	rpc/rpc_impl.hh	/^    inline future<> send_ex(typename protocol<Serializer, MsgType>::server::connection& client) {$/;"	f	struct:rpc::snd_reply
send_ex	rpc/rpc_impl.hh	/^    inline future<> send_ex(typename protocol<Serializer, MsgType>::server::connection& client) {$/;"	f	struct:rpc::snd_reply_base
send_helper	rpc/rpc_impl.hh	/^auto send_helper(MsgType t, std::index_sequence<I...>) {$/;"	f	namespace:rpc
server	rpc/rpc_impl.hh	/^protocol<Serializer, MsgType>::server::server(protocol<Serializer, MsgType>& proto, ipv4_addr addr) : _proto(proto) {$/;"	f	class:rpc::protocol::server
set_ready	rpc/rpc_impl.hh	/^    void set_ready(std::size_t n) {$/;"	f	struct:rpc::in_message
set_val	rpc/rpc_impl.hh	/^    inline void set_val(std::tuple<>&& val) {$/;"	f	struct:rpc::snd_reply
set_val	rpc/rpc_impl.hh	/^    inline void set_val(std::tuple<T...>&& val) {$/;"	f	struct:rpc::snd_reply
set_val	rpc/rpc_impl.hh	/^    inline void set_val(std::tuple<T>&& val) {$/;"	f	struct:rpc::snd_reply
set_val	rpc/rpc_impl.hh	/^    inline void set_val(std::tuple<no_wait_type>&& val) {$/;"	f	struct:rpc::snd_reply
set_value	rpc/rpc_impl.hh	/^    void set_value(V&&... v) {$/;"	f	struct:rpc::rcv_reply_base
snd_reply	rpc/rpc_impl.hh	/^    snd_reply(id_type xid) : snd_reply_base<Serializer, MsgType, T>(xid) {}$/;"	f	struct:rpc::snd_reply
snd_reply	rpc/rpc_impl.hh	/^    snd_reply(id_type xid) : snd_reply_base<Serializer, MsgType, no_wait_type>(xid) {}$/;"	f	struct:rpc::snd_reply
snd_reply	rpc/rpc_impl.hh	/^    snd_reply(id_type xid) : snd_reply_base<Serializer, MsgType, std::tuple<T...>>(xid) {}$/;"	f	struct:rpc::snd_reply
snd_reply	rpc/rpc_impl.hh	/^    snd_reply(id_type xid) : snd_reply_base<Serializer, MsgType, void>(xid) {}$/;"	f	struct:rpc::snd_reply
snd_reply	rpc/rpc_impl.hh	/^struct snd_reply : snd_reply_base<Serializer, MsgType, T> {$/;"	s	namespace:rpc
snd_reply	rpc/rpc_impl.hh	/^struct snd_reply<Serializer, MsgType, future<T...>> : snd_reply_base<Serializer, MsgType, std::tuple<T...>> {$/;"	s	namespace:rpc
snd_reply	rpc/rpc_impl.hh	/^struct snd_reply<Serializer, MsgType, no_wait_type> : snd_reply_base<Serializer, MsgType, no_wait_type> {$/;"	s	namespace:rpc
snd_reply	rpc/rpc_impl.hh	/^struct snd_reply<Serializer, MsgType, void> : snd_reply_base<Serializer, MsgType, void> {$/;"	s	namespace:rpc
snd_reply_base	rpc/rpc_impl.hh	/^    snd_reply_base(id_type xid) : id(xid) {}$/;"	f	struct:rpc::snd_reply_base
snd_reply_base	rpc/rpc_impl.hh	/^struct snd_reply_base : reply_payload<Payload> {$/;"	s	namespace:rpc
storage	rpc/rpc_impl.hh	/^        typename std::aligned_storage<sizeof(args_type), alignof(args_type)>::type storage;$/;"	m	union:rpc::in_message::U
t	rpc/rpc_impl.hh	/^    MsgType t;$/;"	m	struct:rpc::out_message
type	rpc/rpc_impl.hh	/^    typedef Ft type;$/;"	t	struct:rpc::build_msg_type
type	rpc/rpc_impl.hh	/^    typedef Ft& type;$/;"	t	struct:rpc::build_msg_type
u	rpc/rpc_impl.hh	/^    } u;$/;"	m	struct:rpc::in_message	typeref:union:rpc::in_message::U
u	rpc/rpc_impl.hh	/^    } u;$/;"	m	struct:rpc::reply_payload	typeref:union:rpc::reply_payload::U
unmarshall	rpc/rpc_impl.hh	/^inline future<> unmarshall(Serializer& deserializer, input_stream<char>& in, std::tuple<T&...>&& args) {$/;"	f	namespace:rpc
unmarshall	rpc/rpc_impl.hh	/^inline std::enable_if_t<N != sizeof...(T), future<>> unmarshall(Serializer& deserialize, input_stream<char>& in, std::tuple<T&...>&& args, ArgReady&& argready) {$/;"	f	namespace:rpc
unmarshall	rpc/rpc_impl.hh	/^inline std::enable_if_t<N == sizeof...(T), future<>> unmarshall(Serializer&, input_stream<char>&, std::tuple<T&...>&&, ArgReady&& argready) {$/;"	f	namespace:rpc
v	rpc/rpc_impl.hh	/^        T v;$/;"	m	union:rpc::reply_payload::U
v_set	rpc/rpc_impl.hh	/^    bool v_set = false; \/\/ set it to true when U::v is valid object$/;"	m	struct:rpc::reply_payload
value_set	rpc/rpc_impl.hh	/^    void value_set() {$/;"	f	struct:rpc::reply_payload
value_set	rpc/rpc_impl.hh	/^    void value_set() {}$/;"	f	struct:rpc::reply_payload
value_set	rpc/rpc_impl.hh	/^    void value_set(T&& v) {$/;"	f	struct:rpc::reply_payload
wait_for_reply	rpc/rpc_impl.hh	/^inline auto wait_for_reply(typename protocol<Serializer, MsgType>::client& dst, id_type msg_id, future<> sent, std::enable_if_t<!std::is_same<Ret, no_wait_type>::value, void*> = nullptr) {$/;"	f	namespace:rpc
wait_for_reply	rpc/rpc_impl.hh	/^inline auto wait_for_reply(typename protocol<Serializer, MsgType>::client& dst, id_type msg_id, future<>&& sent, std::enable_if_t<std::is_same<Ret, no_wait_type>::value, void*> = nullptr) {$/;"	f	namespace:rpc
~U	rpc/rpc_impl.hh	/^        ~U() {}$/;"	f	union:rpc::in_message::U
~U	rpc/rpc_impl.hh	/^        ~U() {}$/;"	f	union:rpc::reply_payload::U
~in_message	rpc/rpc_impl.hh	/^    ~in_message() {$/;"	f	struct:rpc::in_message
~rcv_reply_base	rpc/rpc_impl.hh	/^    ~rcv_reply_base() {$/;"	f	struct:rpc::rcv_reply_base
~reply_payload	rpc/rpc_impl.hh	/^    ~reply_payload() {$/;"	f	struct:rpc::reply_payload
Alarm	test.py	/^class Alarm(Exception):$/;"	c
alarm_handler	test.py	/^def alarm_handler(signum, frame):$/;"	f
boost_tests	test.py	/^boost_tests = [$/;"	v
last_len	test.py	/^last_len = 0$/;"	v
other_tests	test.py	/^other_tests = [$/;"	v
print_status_short	test.py	/^def print_status_short(msg):$/;"	f
print_status_verbose	test.py	/^print_status_verbose = print$/;"	v
allocation	tests/allocator_test.cc	/^    allocation(size_t n, char poison) : n(n), data(new char[n]), poison(poison) {$/;"	f	struct:allocation
allocation	tests/allocator_test.cc	/^struct allocation {$/;"	s	file:
data	tests/allocator_test.cc	/^    std::unique_ptr<char[]> data;$/;"	m	struct:allocation	file:
main	tests/allocator_test.cc	/^int main(int ac, char** av) {$/;"	f
n	tests/allocator_test.cc	/^    size_t n;$/;"	m	struct:allocation	file:
noexcept	tests/allocator_test.cc	/^    allocation(allocation&& x) noexcept = default;$/;"	m	struct:allocation	file:
operator =	tests/allocator_test.cc	/^    allocation& operator=(allocation&& x) {$/;"	f	struct:allocation
poison	tests/allocator_test.cc	/^    char poison;$/;"	m	struct:allocation	file:
test_aligned_allocator	tests/allocator_test.cc	/^void test_aligned_allocator() {$/;"	f
verify	tests/allocator_test.cc	/^    void verify() {$/;"	f	struct:allocation
~allocation	tests/allocator_test.cc	/^    ~allocation() {$/;"	f	struct:allocation
f	tests/blkdiscard_test.cc	/^    file f;$/;"	m	struct:file_test	file:
file_test	tests/blkdiscard_test.cc	/^    file_test(file&& f) : f(std::move(f)) {}$/;"	f	struct:file_test
file_test	tests/blkdiscard_test.cc	/^struct file_test {$/;"	s	file:
main	tests/blkdiscard_test.cc	/^int main(int ac, char** av) {$/;"	f
sem	tests/blkdiscard_test.cc	/^    semaphore sem = { 0 };$/;"	m	struct:file_test	file:
main	tests/directory_test.cc	/^int main(int ac, char** av) {$/;"	f
X	tests/distributed_test.cc	/^struct X {$/;"	s	file:
Y	tests/distributed_test.cc	/^    Y(sstring s) : s(std::move(s)) {}$/;"	f	struct:Y
Y	tests/distributed_test.cc	/^struct Y {$/;"	s	file:
cpu_id_squared	tests/distributed_test.cc	/^    int cpu_id_squared() const {$/;"	f	struct:X
do_with_distributed	tests/distributed_test.cc	/^future<> do_with_distributed(Func&& func) {$/;"	f
echo	tests/distributed_test.cc	/^    sstring echo(sstring arg) {$/;"	f	struct:X
main	tests/distributed_test.cc	/^int main(int argc, char** argv) {$/;"	f
s	tests/distributed_test.cc	/^    sstring s;$/;"	m	struct:Y	file:
stop	tests/distributed_test.cc	/^    future<> stop() { return make_ready_future<>(); }$/;"	f	struct:X
stop	tests/distributed_test.cc	/^    future<> stop() { return make_ready_future<>(); }$/;"	f	struct:Y
test_constructor_argument_is_passed_to_each_core	tests/distributed_test.cc	/^future<> test_constructor_argument_is_passed_to_each_core() {$/;"	f
test_functor_version	tests/distributed_test.cc	/^future<> test_functor_version() {$/;"	f
test_map_reduce	tests/distributed_test.cc	/^future<> test_map_reduce() {$/;"	f
test_that_each_core_gets_the_arguments	tests/distributed_test.cc	/^future<> test_that_each_core_gets_the_arguments() {$/;"	f
dump_packet	tests/echotest.cc	/^void dump_packet(const packet& p) {$/;"	f
echo_packet	tests/echotest.cc	/^future<> echo_packet(net::qp& netif, packet p) {$/;"	f
main	tests/echotest.cc	/^int main(int ac, char** av) {$/;"	f
usage	tests/echotest.cc	/^void usage()$/;"	f
_cv	tests/exchanger.hh	/^    std::condition_variable _cv;$/;"	m	class:exchanger
_element	tests/exchanger.hh	/^    std::experimental::optional<T> _element;$/;"	m	class:exchanger
_exception	tests/exchanger.hh	/^    std::exception_ptr _exception;$/;"	m	class:exchanger
_mutex	tests/exchanger.hh	/^    std::mutex _mutex;$/;"	m	class:exchanger
exchanger	tests/exchanger.hh	/^class exchanger {$/;"	c
give	tests/exchanger.hh	/^    void give(T value) {$/;"	f	class:exchanger
interrupt	tests/exchanger.hh	/^    void interrupt(Exception e) {$/;"	f	class:exchanger
interrupt_ptr	tests/exchanger.hh	/^    void interrupt_ptr(std::exception_ptr e) {$/;"	f	class:exchanger
take	tests/exchanger.hh	/^    T take() {$/;"	f	class:exchanger
f	tests/fileiotest.cc	/^    file f;$/;"	m	struct:file_test	file:
file_test	tests/fileiotest.cc	/^    file_test(file&& f) : f(std::move(f)) {}$/;"	f	struct:file_test
file_test	tests/fileiotest.cc	/^struct file_test {$/;"	s	file:
main	tests/fileiotest.cc	/^int main(int ac, char** av) {$/;"	f
par	tests/fileiotest.cc	/^    semaphore par = { 1000 };$/;"	m	struct:file_test	file:
sem	tests/fileiotest.cc	/^    semaphore sem = { 0 };$/;"	m	struct:file_test	file:
BOOST_AUTO_TEST_CASE	tests/foreign_ptr_test.cc	/^BOOST_AUTO_TEST_CASE(make_foreign_ptr_from_lw_shared_ptr) {$/;"	f
BOOST_AUTO_TEST_CASE	tests/foreign_ptr_test.cc	/^BOOST_AUTO_TEST_CASE(make_foreign_ptr_from_shared_ptr) {$/;"	f
SEASTAR_TEST_CASE	tests/fstream_test.cc	/^SEASTAR_TEST_CASE(test_fstream) {$/;"	f
SEASTAR_TEST_CASE	tests/fstream_test.cc	/^SEASTAR_TEST_CASE(test_fstream_unaligned) {$/;"	f
in	tests/fstream_test.cc	/^    input_stream<char> in;$/;"	m	struct:reader	file:
out	tests/fstream_test.cc	/^    output_stream<char> out;$/;"	m	struct:writer	file:
reader	tests/fstream_test.cc	/^    reader(file f) : in(make_file_input_stream($/;"	f	struct:reader
reader	tests/fstream_test.cc	/^struct reader {$/;"	s	file:
writer	tests/fstream_test.cc	/^    writer(file f) : out(make_file_output_stream($/;"	f	struct:writer
writer	tests/fstream_test.cc	/^struct writer {$/;"	s	file:
SEASTAR_TEST_CASE	tests/futures_test.cc	/^SEASTAR_TEST_CASE(test_bare_value_can_be_returned_from_callback) {$/;"	f
SEASTAR_TEST_CASE	tests/futures_test.cc	/^SEASTAR_TEST_CASE(test_broken_semaphore) {$/;"	f
SEASTAR_TEST_CASE	tests/futures_test.cc	/^SEASTAR_TEST_CASE(test_exception_can_be_thrown_from_do_until_body) {$/;"	f
SEASTAR_TEST_CASE	tests/futures_test.cc	/^SEASTAR_TEST_CASE(test_exception_from_finally_fails_the_target) {$/;"	f
SEASTAR_TEST_CASE	tests/futures_test.cc	/^SEASTAR_TEST_CASE(test_exception_from_finally_fails_the_target_on_already_resolved) {$/;"	f
SEASTAR_TEST_CASE	tests/futures_test.cc	/^SEASTAR_TEST_CASE(test_exception_thrown_from_then_wrapped_causes_future_to_fail) {$/;"	f
SEASTAR_TEST_CASE	tests/futures_test.cc	/^SEASTAR_TEST_CASE(test_exception_thrown_from_then_wrapped_causes_future_to_fail__async_case) {$/;"	f
SEASTAR_TEST_CASE	tests/futures_test.cc	/^SEASTAR_TEST_CASE(test_failing_intermediate_promise_should_fail_the_master_future) {$/;"	f
SEASTAR_TEST_CASE	tests/futures_test.cc	/^SEASTAR_TEST_CASE(test_finally_is_called_on_success_and_failure) {$/;"	f
SEASTAR_TEST_CASE	tests/futures_test.cc	/^SEASTAR_TEST_CASE(test_finally_is_called_on_success_and_failure__not_ready_to_armed) {$/;"	f
SEASTAR_TEST_CASE	tests/futures_test.cc	/^SEASTAR_TEST_CASE(test_future_forwarding__not_ready_to_armed) {$/;"	f
SEASTAR_TEST_CASE	tests/futures_test.cc	/^SEASTAR_TEST_CASE(test_future_forwarding__not_ready_to_unarmed) {$/;"	f
SEASTAR_TEST_CASE	tests/futures_test.cc	/^SEASTAR_TEST_CASE(test_future_forwarding__ready_to_armed) {$/;"	f
SEASTAR_TEST_CASE	tests/futures_test.cc	/^SEASTAR_TEST_CASE(test_future_forwarding__ready_to_unarmed) {$/;"	f
SEASTAR_TEST_CASE	tests/futures_test.cc	/^SEASTAR_TEST_CASE(test_future_forwarding__ready_to_unarmed_soon_to_be_dead) {$/;"	f
SEASTAR_TEST_CASE	tests/futures_test.cc	/^SEASTAR_TEST_CASE(test_map_reduce) {$/;"	f
SEASTAR_TEST_CASE	tests/futures_test.cc	/^SEASTAR_TEST_CASE(test_sleep) {$/;"	f
SEASTAR_TEST_CASE	tests/futures_test.cc	/^SEASTAR_TEST_CASE(test_when_all_iterator_range) {$/;"	f
expected_exception	tests/futures_test.cc	/^    expected_exception() : runtime_error("expected") {}$/;"	f	class:expected_exception
expected_exception	tests/futures_test.cc	/^class expected_exception : std::runtime_error {$/;"	c	file:
forward_dead_unarmed_promise_with_dead_future_to	tests/futures_test.cc	/^static void forward_dead_unarmed_promise_with_dead_future_to(promise<>& p) {$/;"	f	file:
SEASTAR_TEST_CASE	tests/httpd.cc	/^SEASTAR_TEST_CASE(test_decode_url) {$/;"	f
SEASTAR_TEST_CASE	tests/httpd.cc	/^SEASTAR_TEST_CASE(test_formatter)$/;"	f
SEASTAR_TEST_CASE	tests/httpd.cc	/^SEASTAR_TEST_CASE(test_match_rule)$/;"	f
SEASTAR_TEST_CASE	tests/httpd.cc	/^SEASTAR_TEST_CASE(test_param_matcher)$/;"	f
SEASTAR_TEST_CASE	tests/httpd.cc	/^SEASTAR_TEST_CASE(test_reply)$/;"	f
SEASTAR_TEST_CASE	tests/httpd.cc	/^SEASTAR_TEST_CASE(test_routes) {$/;"	f
SEASTAR_TEST_CASE	tests/httpd.cc	/^SEASTAR_TEST_CASE(test_str_matcher)$/;"	f
SEASTAR_TEST_CASE	tests/httpd.cc	/^SEASTAR_TEST_CASE(test_transformer) {$/;"	f
handl	tests/httpd.cc	/^class handl : public httpd::handler_base {$/;"	c	file:
handle	tests/httpd.cc	/^    virtual future<std::unique_ptr<reply> > handle(const sstring& path,$/;"	f	class:handl
main	tests/ip_test.cc	/^int main(int ac, char** av) {$/;"	f
dump_arp_packets	tests/l3_test.cc	/^void dump_arp_packets(l3_protocol& proto) {$/;"	f
main	tests/l3_test.cc	/^int main(int ac, char** av) {$/;"	f
count	tests/linecount.cc	/^    size_t count = 0;$/;"	m	struct:reader	file:
is	tests/linecount.cc	/^    input_stream<char> is;$/;"	m	struct:reader	file:
main	tests/linecount.cc	/^int main(int ac, char** av) {$/;"	f
operator ()	tests/linecount.cc	/^    future<unconsumed_remainder> operator()(temporary_buffer<char> data) {$/;"	f	struct:reader
reader	tests/linecount.cc	/^    reader(file f) : is(make_file_input_stream($/;"	f	struct:reader
reader	tests/linecount.cc	/^struct reader {$/;"	s	file:
args	tests/memcached/test.py	/^    args = parser.parse_args()$/;"	v
parser	tests/memcached/test.py	/^    parser = argparse.ArgumentParser(description="Seastar test runner")$/;"	v
run	tests/memcached/test.py	/^def run(args, cmd):$/;"	f
SEASTAR_TEST_CASE	tests/memcached/test_ascii_parser.cc	/^SEASTAR_TEST_CASE(test_catches_errors_in_get) {$/;"	f
SEASTAR_TEST_CASE	tests/memcached/test_ascii_parser.cc	/^SEASTAR_TEST_CASE(test_empty_data_is_parsed) {$/;"	f
SEASTAR_TEST_CASE	tests/memcached/test_ascii_parser.cc	/^SEASTAR_TEST_CASE(test_get_parsing) {$/;"	f
SEASTAR_TEST_CASE	tests/memcached/test_ascii_parser.cc	/^SEASTAR_TEST_CASE(test_incomplete_command_is_an_error) {$/;"	f
SEASTAR_TEST_CASE	tests/memcached/test_ascii_parser.cc	/^SEASTAR_TEST_CASE(test_multiple_requests_in_one_stream) {$/;"	f
SEASTAR_TEST_CASE	tests/memcached/test_ascii_parser.cc	/^SEASTAR_TEST_CASE(test_not_enough_data_is_an_error) {$/;"	f
SEASTAR_TEST_CASE	tests/memcached/test_ascii_parser.cc	/^SEASTAR_TEST_CASE(test_parser_returns_eof_state_when_no_command_follows) {$/;"	f
SEASTAR_TEST_CASE	tests/memcached/test_ascii_parser.cc	/^SEASTAR_TEST_CASE(test_parsing_of_split_data) {$/;"	f
SEASTAR_TEST_CASE	tests/memcached/test_ascii_parser.cc	/^SEASTAR_TEST_CASE(test_set_command_is_parsed) {$/;"	f
SEASTAR_TEST_CASE	tests/memcached/test_ascii_parser.cc	/^SEASTAR_TEST_CASE(test_superflous_data_is_an_error) {$/;"	f
SEASTAR_TEST_CASE	tests/memcached/test_ascii_parser.cc	/^SEASTAR_TEST_CASE(test_u32_parsing) {$/;"	f
as_strings	tests/memcached/test_ascii_parser.cc	/^static std::vector<sstring> as_strings(std::vector<item_key>& keys) {$/;"	f	file:
for_each_fragment_size	tests/memcached/test_ascii_parser.cc	/^auto for_each_fragment_size = [] (auto&& func) {$/;"	v
make_input_stream	tests/memcached/test_ascii_parser.cc	/^static auto make_input_stream(packet&& p) {$/;"	f	file:
make_packet	tests/memcached/test_ascii_parser.cc	/^static packet make_packet(std::vector<std::string> chunks, size_t buffer_size) {$/;"	f	file:
parse	tests/memcached/test_ascii_parser.cc	/^static auto parse(packet&& p) {$/;"	f	file:
MemcacheTest	tests/memcached/test_memcached.py	/^class MemcacheTest(unittest.TestCase):$/;"	c
TcpSpecificTests	tests/memcached/test_memcached.py	/^class TcpSpecificTests(MemcacheTest):$/;"	c
TestCommands	tests/memcached/test_memcached.py	/^class TestCommands(MemcacheTest):$/;"	c
TimeoutError	tests/memcached/test_memcached.py	/^class TimeoutError(Exception):$/;"	c
UdpSpecificTests	tests/memcached/test_memcached.py	/^class UdpSpecificTests(MemcacheTest):$/;"	c
args	tests/memcached/test_memcached.py	/^    args = parser.parse_args()$/;"	v
args	tests/memcached/test_memcached.py	/^args = None$/;"	v
assertHasKey	tests/memcached/test_memcached.py	/^    def assertHasKey(self, key):$/;"	m	class:MemcacheTest
assertNoKey	tests/memcached/test_memcached.py	/^    def assertNoKey(self, key):$/;"	m	class:MemcacheTest
call	tests/memcached/test_memcached.py	/^        call = tcp_call$/;"	v
call	tests/memcached/test_memcached.py	/^        call = udp_call$/;"	v
call	tests/memcached/test_memcached.py	/^    def call(msg):$/;"	f	function:tcp_connection
call	tests/memcached/test_memcached.py	/^call = None$/;"	v
delete	tests/memcached/test_memcached.py	/^    def delete(self, key):$/;"	m	class:MemcacheTest
flush	tests/memcached/test_memcached.py	/^    def flush(self):$/;"	m	class:MemcacheTest
getItemVersion	tests/memcached/test_memcached.py	/^    def getItemVersion(self, key):$/;"	m	class:MemcacheTest
getStat	tests/memcached/test_memcached.py	/^    def getStat(self, name, call_fn=None):$/;"	m	class:MemcacheTest
loader	tests/memcached/test_memcached.py	/^    loader = unittest.TestLoader()$/;"	v
parser	tests/memcached/test_memcached.py	/^    parser = argparse.ArgumentParser(description="memcache protocol tests")$/;"	v
recv_all	tests/memcached/test_memcached.py	/^def recv_all(s):$/;"	f
result	tests/memcached/test_memcached.py	/^    result = runner.run(suite)$/;"	v
runner	tests/memcached/test_memcached.py	/^    runner = unittest.TextTestRunner()$/;"	v
server_addr	tests/memcached/test_memcached.py	/^    server_addr = (host, int(port))$/;"	v
server_addr	tests/memcached/test_memcached.py	/^server_addr = None$/;"	v
set	tests/memcached/test_memcached.py	/^    def set(self, key, value, flags=0, expiry=0):$/;"	m	class:MemcacheTest
setKey	tests/memcached/test_memcached.py	/^    def setKey(self, key):$/;"	m	class:MemcacheTest
slow	tests/memcached/test_memcached.py	/^def slow(f):$/;"	f
suite	tests/memcached/test_memcached.py	/^    suite = unittest.TestSuite()$/;"	v
tcp_call	tests/memcached/test_memcached.py	/^def tcp_call(msg, timeout=1):$/;"	f
tcp_connection	tests/memcached/test_memcached.py	/^def tcp_connection(timeout=1):$/;"	f
tearDown	tests/memcached/test_memcached.py	/^    def tearDown(self):$/;"	m	class:MemcacheTest
test_add	tests/memcached/test_memcached.py	/^    def test_add(self):$/;"	m	class:TestCommands
test_add_no_reply	tests/memcached/test_memcached.py	/^    def test_add_no_reply(self):$/;"	m	class:TcpSpecificTests
test_basic_commands	tests/memcached/test_memcached.py	/^    def test_basic_commands(self):$/;"	m	class:TestCommands
test_cas_and_gets	tests/memcached/test_memcached.py	/^    def test_cas_and_gets(self):$/;"	m	class:TestCommands
test_cas_noreply	tests/memcached/test_memcached.py	/^    def test_cas_noreply(self):$/;"	m	class:TcpSpecificTests
test_connection_statistics	tests/memcached/test_memcached.py	/^    def test_connection_statistics(self):$/;"	m	class:TcpSpecificTests
test_curr_items_stat	tests/memcached/test_memcached.py	/^    def test_curr_items_stat(self):$/;"	m	class:TestCommands
test_decr	tests/memcached/test_memcached.py	/^    def test_decr(self):$/;"	m	class:TestCommands
test_delete_no_reply	tests/memcached/test_memcached.py	/^    def test_delete_no_reply(self):$/;"	m	class:TcpSpecificTests
test_error_handling	tests/memcached/test_memcached.py	/^    def test_error_handling(self):$/;"	m	class:TestCommands
test_expiry	tests/memcached/test_memcached.py	/^    def test_expiry(self):$/;"	m	class:TestCommands
test_expiry_at_epoch_time	tests/memcached/test_memcached.py	/^    def test_expiry_at_epoch_time(self):$/;"	m	class:TestCommands
test_flush_all	tests/memcached/test_memcached.py	/^    def test_flush_all(self):$/;"	m	class:TestCommands
test_flush_all_no_reply	tests/memcached/test_memcached.py	/^    def test_flush_all_no_reply(self):$/;"	m	class:TcpSpecificTests
test_flush_all_with_timeout_flushes_all_keys_even_those_set_after_flush	tests/memcached/test_memcached.py	/^    def test_flush_all_with_timeout_flushes_all_keys_even_those_set_after_flush(self):$/;"	m	class:TestCommands
test_flushing_in_the_past	tests/memcached/test_memcached.py	/^    def test_flushing_in_the_past(self):$/;"	m	class:TestCommands
test_how_stats_change_with_different_commands	tests/memcached/test_memcached.py	/^    def test_how_stats_change_with_different_commands(self):$/;"	m	class:TestCommands
test_immediate_flush_cancels_delayed_flush	tests/memcached/test_memcached.py	/^    def test_immediate_flush_cancels_delayed_flush(self):$/;"	m	class:TestCommands
test_incomplete_command_results_in_error	tests/memcached/test_memcached.py	/^    def test_incomplete_command_results_in_error(self):$/;"	m	class:TcpSpecificTests
test_incr	tests/memcached/test_memcached.py	/^    def test_incr(self):$/;"	m	class:TestCommands
test_incr_and_decr_on_invalid_input	tests/memcached/test_memcached.py	/^    def test_incr_and_decr_on_invalid_input(self):$/;"	m	class:TestCommands
test_keys_set_after_flush_remain	tests/memcached/test_memcached.py	/^    def test_keys_set_after_flush_remain(self):$/;"	m	class:TestCommands
test_large_response_is_split_into_mtu_chunks	tests/memcached/test_memcached.py	/^    def test_large_response_is_split_into_mtu_chunks(self):$/;"	m	class:UdpSpecificTests
test_memcache_does_not_crash_when_flushing_with_already_expred_items	tests/memcached/test_memcached.py	/^    def test_memcache_does_not_crash_when_flushing_with_already_expred_items(self):$/;"	m	class:TestCommands
test_multiple_keys_in_get	tests/memcached/test_memcached.py	/^    def test_multiple_keys_in_get(self):$/;"	m	class:TestCommands
test_recovers_from_errors_in_the_stream	tests/memcached/test_memcached.py	/^    def test_recovers_from_errors_in_the_stream(self):$/;"	m	class:TcpSpecificTests
test_replace	tests/memcached/test_memcached.py	/^    def test_replace(self):$/;"	m	class:TestCommands
test_replace_no_reply	tests/memcached/test_memcached.py	/^    def test_replace_no_reply(self):$/;"	m	class:TcpSpecificTests
test_response_spanning_many_datagrams	tests/memcached/test_memcached.py	/^    def test_response_spanning_many_datagrams(self):$/;"	m	class:TestCommands
test_set_no_reply	tests/memcached/test_memcached.py	/^    def test_set_no_reply(self):$/;"	m	class:TcpSpecificTests
test_stream_closed_results_in_error	tests/memcached/test_memcached.py	/^    def test_stream_closed_results_in_error(self):$/;"	m	class:TcpSpecificTests
test_subsequent_flush_is_merged	tests/memcached/test_memcached.py	/^    def test_subsequent_flush_is_merged(self):$/;"	m	class:TestCommands
test_unsuccesful_parsing_does_not_leave_data_behind	tests/memcached/test_memcached.py	/^    def test_unsuccesful_parsing_does_not_leave_data_behind(self):$/;"	m	class:TcpSpecificTests
test_version	tests/memcached/test_memcached.py	/^    def test_version(self):$/;"	m	class:TestCommands
udp_call	tests/memcached/test_memcached.py	/^def udp_call(msg, **kwargs):$/;"	f
udp_call_for_fragments	tests/memcached/test_memcached.py	/^def udp_call_for_fragments(msg, timeout=1):$/;"	f
wait_for_memcache_tcp	tests/memcached/test_memcached.py	/^def wait_for_memcache_tcp(timeout=4):$/;"	f
wait_for_memcache_udp	tests/memcached/test_memcached.py	/^def wait_for_memcache_udp(timeout=4):$/;"	f
wrapper	tests/memcached/test_memcached.py	/^    def wrapper(self):$/;"	f	function:slow
SEASTAR_TEST_CASE	tests/output_stream_test.cc	/^SEASTAR_TEST_CASE(test_flush_on_empty_buffer_does_not_push_empty_packet_down_stream) {$/;"	f
SEASTAR_TEST_CASE	tests/output_stream_test.cc	/^SEASTAR_TEST_CASE(test_splitting) {$/;"	f
SEASTAR_TEST_CASE	tests/output_stream_test.cc	/^SEASTAR_TEST_CASE(test_splitting_with_trimming) {$/;"	f
_size	tests/output_stream_test.cc	/^    size_t _size;$/;"	m	struct:stream_maker	file:
_trim	tests/output_stream_test.cc	/^    bool _trim = false;$/;"	m	struct:stream_maker	file:
assert_split	tests/output_stream_test.cc	/^future<> assert_split(StreamConstructor stream_maker, std::initializer_list<T> write_calls,$/;"	f
operator ()	tests/output_stream_test.cc	/^    lw_shared_ptr<output_stream<char>> operator()(data_sink sink) {$/;"	f	struct:stream_maker
size	tests/output_stream_test.cc	/^    stream_maker size(size_t size) && {$/;"	f	struct:stream_maker
stream_maker	tests/output_stream_test.cc	/^struct stream_maker {$/;"	s	file:
to_sstring	tests/output_stream_test.cc	/^static sstring to_sstring(const packet& p) {$/;"	f	file:
trim	tests/output_stream_test.cc	/^    stream_maker trim(bool do_trim) && {$/;"	f	struct:stream_maker
main	tests/rpc.cc	/^int main(int ac, char** av) {$/;"	f
operator ()	tests/rpc.cc	/^    inline auto operator()(input_stream<char>& in, T& v, std::enable_if_t<!std::is_pod<T>::value, void*> = nullptr) {$/;"	f	struct:serializer
operator ()	tests/rpc.cc	/^    inline auto operator()(input_stream<char>& in, T& v, std::enable_if_t<std::is_pod<T>::value, void*> = nullptr) {$/;"	f	struct:serializer
operator ()	tests/rpc.cc	/^    inline auto operator()(input_stream<char>& in, sstring& v) {$/;"	f	struct:serializer
operator ()	tests/rpc.cc	/^    inline auto operator()(output_stream<char>& out, T&& v, std::enable_if_t<!std::is_pod<std::remove_reference_t<T>>::value, void*> = nullptr) {$/;"	f	struct:serializer
operator ()	tests/rpc.cc	/^    inline auto operator()(output_stream<char>& out, T&& v, std::enable_if_t<std::is_pod<std::remove_reference_t<T>>::value, void*> = nullptr) {$/;"	f	struct:serializer
operator ()	tests/rpc.cc	/^    inline auto operator()(output_stream<char>& out, sstring& v) {$/;"	f	struct:serializer
serializer	tests/rpc.cc	/^struct serializer {$/;"	s	file:
SEASTAR_TEST_CASE	tests/semaphore_test.cc	/^SEASTAR_TEST_CASE(test_semaphore_1) {$/;"	f
SEASTAR_TEST_CASE	tests/semaphore_test.cc	/^SEASTAR_TEST_CASE(test_semaphore_2) {$/;"	f
SEASTAR_TEST_CASE	tests/semaphore_test.cc	/^SEASTAR_TEST_CASE(test_semaphore_timeout_1) {$/;"	f
SEASTAR_TEST_CASE	tests/semaphore_test.cc	/^SEASTAR_TEST_CASE(test_semaphore_timeout_2) {$/;"	f
A	tests/shared_ptr_test.cc	/^    A() {$/;"	f	struct:A
A	tests/shared_ptr_test.cc	/^struct A {$/;"	s	file:
B	tests/shared_ptr_test.cc	/^struct B {$/;"	s	file:
BOOST_AUTO_TEST_CASE	tests/shared_ptr_test.cc	/^BOOST_AUTO_TEST_CASE(explot_dynamic_cast_use_after_free_problem) {$/;"	f
BOOST_AUTO_TEST_CASE	tests/shared_ptr_test.cc	/^BOOST_AUTO_TEST_CASE(test_const_ptr) {$/;"	f
BOOST_AUTO_TEST_CASE	tests/shared_ptr_test.cc	/^BOOST_AUTO_TEST_CASE(test_lw_const_ptr_1) {$/;"	f
BOOST_AUTO_TEST_CASE	tests/shared_ptr_test.cc	/^BOOST_AUTO_TEST_CASE(test_lw_const_ptr_2) {$/;"	f
BOOST_TEST_DYN_LINK	tests/shared_ptr_test.cc	23;"	d	file:
BOOST_TEST_MODULE	tests/shared_ptr_test.cc	24;"	d	file:
C	tests/shared_ptr_test.cc	/^class C : public enable_shared_from_this<C> {$/;"	c	file:
D	tests/shared_ptr_test.cc	/^struct D {};$/;"	s	file:
E	tests/shared_ptr_test.cc	/^struct E : enable_lw_shared_from_this<E> {};$/;"	s	file:
destroyed	tests/shared_ptr_test.cc	/^    static bool destroyed;$/;"	m	struct:A	file:
destroyed	tests/shared_ptr_test.cc	/^bool A::destroyed = false;$/;"	m	class:A	file:
dup	tests/shared_ptr_test.cc	/^    shared_ptr<C> dup() { return shared_from_this(); }$/;"	f	class:C
get	tests/shared_ptr_test.cc	/^    shared_ptr<const C> get() const { return shared_from_this(); }$/;"	f	class:C
x	tests/shared_ptr_test.cc	/^    virtual void x() {}$/;"	f	struct:B
~A	tests/shared_ptr_test.cc	/^    virtual ~A() {$/;"	f	struct:A
_cache_link	tests/slab_test.cc	/^    bi::list_member_hook<> _cache_link;$/;"	m	class:item	file:
_slab_page_index	tests/slab_test.cc	/^    uint32_t _slab_page_index;$/;"	m	class:item	file:
free_vector	tests/slab_test.cc	/^static void free_vector(slab_allocator<Item>& slab, std::vector<item *>& items) {$/;"	f	file:
get_slab_page_index	tests/slab_test.cc	/^    const uint32_t get_slab_page_index() {$/;"	f	class:item
is_unlocked	tests/slab_test.cc	/^    const bool is_unlocked() {$/;"	f	class:item
item	tests/slab_test.cc	/^    item(uint32_t slab_page_index) : _slab_page_index(slab_page_index) {}$/;"	f	class:item
item	tests/slab_test.cc	/^class item : public slab_item_base {$/;"	c	file:
main	tests/slab_test.cc	/^int main(int ac, char** av) {$/;"	f
max_object_size	tests/slab_test.cc	/^static constexpr size_t max_object_size = 1024*1024;$/;"	v	file:
test_allocation_1	tests/slab_test.cc	/^static void test_allocation_1(const double growth_factor, const unsigned slab_limit_size) {$/;"	f	file:
test_allocation_2	tests/slab_test.cc	/^static void test_allocation_2(const double growth_factor, const unsigned slab_limit_size) {$/;"	f	file:
test_allocation_with_lru	tests/slab_test.cc	/^static void test_allocation_with_lru(const double growth_factor, const unsigned slab_limit_size) {$/;"	f	file:
fails	tests/smp_test.cc	/^int tests, fails;$/;"	v
main	tests/smp_test.cc	/^int main(int ac, char** av) {$/;"	f
nasty_exception	tests/smp_test.cc	/^struct nasty_exception {};$/;"	s	file:
report	tests/smp_test.cc	/^report(sstring msg, future<bool>&& result) {$/;"	f
test_smp_call	tests/smp_test.cc	/^future<bool> test_smp_call() {$/;"	f
test_smp_exception	tests/smp_test.cc	/^future<bool> test_smp_exception() {$/;"	f
tests	tests/smp_test.cc	/^int tests, fails;$/;"	v
BOOST_AUTO_TEST_CASE	tests/sstring_test.cc	/^BOOST_AUTO_TEST_CASE(test_add_literal_to_sstring) {$/;"	f
BOOST_AUTO_TEST_CASE	tests/sstring_test.cc	/^BOOST_AUTO_TEST_CASE(test_append) {$/;"	f
BOOST_AUTO_TEST_CASE	tests/sstring_test.cc	/^BOOST_AUTO_TEST_CASE(test_at_sstring) {$/;"	f
BOOST_AUTO_TEST_CASE	tests/sstring_test.cc	/^BOOST_AUTO_TEST_CASE(test_ctor_iterator) {$/;"	f
BOOST_AUTO_TEST_CASE	tests/sstring_test.cc	/^BOOST_AUTO_TEST_CASE(test_equality) {$/;"	f
BOOST_AUTO_TEST_CASE	tests/sstring_test.cc	/^BOOST_AUTO_TEST_CASE(test_erase) {$/;"	f
BOOST_AUTO_TEST_CASE	tests/sstring_test.cc	/^BOOST_AUTO_TEST_CASE(test_find_last_sstring) {$/;"	f
BOOST_AUTO_TEST_CASE	tests/sstring_test.cc	/^BOOST_AUTO_TEST_CASE(test_find_sstring) {$/;"	f
BOOST_AUTO_TEST_CASE	tests/sstring_test.cc	/^BOOST_AUTO_TEST_CASE(test_insert) {$/;"	f
BOOST_AUTO_TEST_CASE	tests/sstring_test.cc	/^BOOST_AUTO_TEST_CASE(test_not_find_sstring) {$/;"	f
BOOST_AUTO_TEST_CASE	tests/sstring_test.cc	/^BOOST_AUTO_TEST_CASE(test_replace) {$/;"	f
BOOST_AUTO_TEST_CASE	tests/sstring_test.cc	/^BOOST_AUTO_TEST_CASE(test_str_find_sstring) {$/;"	f
BOOST_AUTO_TEST_CASE	tests/sstring_test.cc	/^BOOST_AUTO_TEST_CASE(test_str_not_find_sstring) {$/;"	f
BOOST_AUTO_TEST_CASE	tests/sstring_test.cc	/^BOOST_AUTO_TEST_CASE(test_substr_eor_sstring) {$/;"	f
BOOST_AUTO_TEST_CASE	tests/sstring_test.cc	/^BOOST_AUTO_TEST_CASE(test_substr_sstring) {$/;"	f
BOOST_AUTO_TEST_CASE	tests/sstring_test.cc	/^BOOST_AUTO_TEST_CASE(test_to_sstring) {$/;"	f
BOOST_TEST_DYN_LINK	tests/sstring_test.cc	22;"	d	file:
BOOST_TEST_MODULE	tests/sstring_test.cc	23;"	d	file:
_bytes_read	tests/tcp_client.cc	/^        size_t _bytes_read = 0;$/;"	m	class:client::connection	file:
_bytes_write	tests/tcp_client.cc	/^        size_t _bytes_write = 0;$/;"	m	class:client::connection	file:
_concurrent_connections	tests/tcp_client.cc	/^    unsigned _concurrent_connections;$/;"	m	class:client	file:
_earliest_started	tests/tcp_client.cc	/^    lowres_clock::time_point _earliest_started;$/;"	m	class:client	file:
_fd	tests/tcp_client.cc	/^        connected_socket _fd;$/;"	m	class:client::connection	file:
_latest_finished	tests/tcp_client.cc	/^    lowres_clock::time_point _latest_finished;$/;"	m	class:client	file:
_num_reported	tests/tcp_client.cc	/^    unsigned _num_reported;$/;"	m	class:client	file:
_pings_per_connection	tests/tcp_client.cc	/^    static constexpr unsigned _pings_per_connection = 1000;$/;"	m	class:client	file:
_processed_bytes	tests/tcp_client.cc	/^    size_t _processed_bytes;$/;"	m	class:client	file:
_read_buf	tests/tcp_client.cc	/^        input_stream<char> _read_buf;$/;"	m	class:client::connection	file:
_server_addr	tests/tcp_client.cc	/^    ipv4_addr _server_addr;$/;"	m	class:client	file:
_test	tests/tcp_client.cc	/^    std::string _test;$/;"	m	class:client	file:
_total_pings	tests/tcp_client.cc	/^    unsigned _total_pings;$/;"	m	class:client	file:
_write_buf	tests/tcp_client.cc	/^        output_stream<char> _write_buf;$/;"	m	class:client::connection	file:
client	tests/tcp_client.cc	/^class client {$/;"	c	file:
clients	tests/tcp_client.cc	/^distributed<client> clients;$/;"	v
connection	tests/tcp_client.cc	/^        connection(connected_socket&& fd)$/;"	f	class:client::connection
connection	tests/tcp_client.cc	/^    class connection {$/;"	c	class:client	file:
do_read	tests/tcp_client.cc	/^        future<> do_read() {$/;"	f	class:client::connection
do_write	tests/tcp_client.cc	/^        future<> do_write(int end) {$/;"	f	class:client::connection
main	tests/tcp_client.cc	/^int main(int ac, char ** av) {$/;"	f
ping	tests/tcp_client.cc	/^        future<> ping(int times) {            $/;"	f	class:client::connection
ping_report	tests/tcp_client.cc	/^    void ping_report(lowres_clock::time_point started, lowres_clock::time_point finished) {$/;"	f	class:client
ping_test	tests/tcp_client.cc	/^    future<> ping_test(connection *conn) {$/;"	f	class:client
rx_msg_size	tests/tcp_client.cc	/^static int rx_msg_size = 4 * 1024;$/;"	v	file:
rxrx	tests/tcp_client.cc	/^        future<size_t> rxrx() {$/;"	f	class:client::connection
rxrx_test	tests/tcp_client.cc	/^    future<> rxrx_test(connection *conn) {$/;"	f	class:client
rxtx_report	tests/tcp_client.cc	/^    void rxtx_report(lowres_clock::time_point started, lowres_clock::time_point finished, size_t bytes) {$/;"	f	class:client
start	tests/tcp_client.cc	/^    future<> start(ipv4_addr server_addr, std::string test, unsigned ncon) {$/;"	f	class:client
stop	tests/tcp_client.cc	/^    future<> stop() {$/;"	f	class:client
test_fn	tests/tcp_client.cc	/^    typedef future<> (client::*test_fn)(connection *conn);$/;"	t	class:client	file:
tests	tests/tcp_client.cc	/^    static const std::map<std::string, test_fn> tests;$/;"	m	class:client	file:
tests	tests/tcp_client.cc	/^const std::map<std::string, client::test_fn> client::tests = {$/;"	m	class:client	file:
tx_msg_nr	tests/tcp_client.cc	/^static int tx_msg_nr = tx_msg_total_size \/ tx_msg_size;$/;"	v	file:
tx_msg_size	tests/tcp_client.cc	/^static int tx_msg_size = 4 * 1024;$/;"	v	file:
tx_msg_total_size	tests/tcp_client.cc	/^static int tx_msg_total_size = 100 * 1024 * 1024;$/;"	v	file:
txtx	tests/tcp_client.cc	/^        future<size_t> txtx() {$/;"	f	class:client::connection
txtx_test	tests/tcp_client.cc	/^    future<> txtx_test(connection *conn) {$/;"	f	class:client
_fd	tests/tcp_server.cc	/^        connected_socket _fd;$/;"	m	class:tcp_server::connection	file:
_listeners	tests/tcp_server.cc	/^    std::vector<server_socket> _listeners;$/;"	m	class:tcp_server	file:
_read_buf	tests/tcp_server.cc	/^        input_stream<char> _read_buf;$/;"	m	class:tcp_server::connection	file:
_write_buf	tests/tcp_server.cc	/^        output_stream<char> _write_buf;$/;"	m	class:tcp_server::connection	file:
connection	tests/tcp_server.cc	/^        connection(tcp_server& server, connected_socket&& fd, socket_address addr)$/;"	f	class:tcp_server::connection
connection	tests/tcp_server.cc	/^    class connection {$/;"	c	class:tcp_server	file:
do_accepts	tests/tcp_server.cc	/^    void do_accepts(int which) {$/;"	f	class:tcp_server
do_read	tests/tcp_server.cc	/^        future<> do_read() {$/;"	f	class:tcp_server::connection
do_write	tests/tcp_server.cc	/^        future<> do_write(int end) {$/;"	f	class:tcp_server::connection
listen	tests/tcp_server.cc	/^    future<> listen(ipv4_addr addr) {$/;"	f	class:tcp_server
main	tests/tcp_server.cc	/^int main(int ac, char** av) {$/;"	f
process	tests/tcp_server.cc	/^        future<> process() {$/;"	f	class:tcp_server::connection
read	tests/tcp_server.cc	/^        future<> read() {$/;"	f	class:tcp_server::connection
rx_msg_size	tests/tcp_server.cc	/^static int rx_msg_size = 4 * 1024;$/;"	v	file:
rx_test	tests/tcp_server.cc	/^        future<> rx_test() {$/;"	f	class:tcp_server::connection
tcp_server	tests/tcp_server.cc	/^class tcp_server {$/;"	c	file:
tx_msg_nr	tests/tcp_server.cc	/^static int tx_msg_nr = tx_msg_total_size \/ tx_msg_size;$/;"	v	file:
tx_msg_size	tests/tcp_server.cc	/^static int tx_msg_size = 4 * 1024;$/;"	v	file:
tx_msg_total_size	tests/tcp_server.cc	/^static int tx_msg_total_size = 100 * 1024 * 1024;$/;"	v	file:
tx_test	tests/tcp_server.cc	/^        future<> tx_test() {$/;"	f	class:tcp_server::connection
connection	tests/tcp_test.cc	/^        explicit connection(tcp::connection tc) : tcp_conn(std::move(tc)) {}$/;"	f	struct:tcp_test::connection
connection	tests/tcp_test.cc	/^    struct connection {$/;"	s	struct:tcp_test	file:
inet	tests/tcp_test.cc	/^    ipv4& inet;$/;"	m	struct:tcp_test	file:
main	tests/tcp_test.cc	/^int main(int ac, char** av) {$/;"	f
run	tests/tcp_test.cc	/^        void run() {$/;"	f	struct:tcp_test::connection
run	tests/tcp_test.cc	/^    void run() {$/;"	f	struct:tcp_test
tcp_conn	tests/tcp_test.cc	/^        tcp::connection tcp_conn;$/;"	m	struct:tcp_test::connection	file:
tcp_test	tests/tcp_test.cc	/^    tcp_test(ipv4& inet) : inet(inet), _listener(inet.get_tcp().listen(10000)) {}$/;"	f	struct:tcp_test
tcp_test	tests/tcp_test.cc	/^struct tcp_test {$/;"	s	file:
buffer	tests/test-reactor.cc	/^        char buffer[8192];$/;"	m	struct:test::connection	file:
connection	tests/test-reactor.cc	/^        connection(pollable_fd fd) : fd(std::move(fd)) {}$/;"	f	struct:test::connection
connection	tests/test-reactor.cc	/^    struct connection {$/;"	s	struct:test	file:
copy_data	tests/test-reactor.cc	/^        void copy_data() {$/;"	f	struct:test::connection
fd	tests/test-reactor.cc	/^        pollable_fd fd;$/;"	m	struct:test::connection	file:
listener	tests/test-reactor.cc	/^    pollable_fd listener;$/;"	m	struct:test	file:
main	tests/test-reactor.cc	/^int main(int ac, char** av)$/;"	f
new_connection	tests/test-reactor.cc	/^    void new_connection(pollable_fd fd, socket_address sa) {$/;"	f	struct:test
start_accept	tests/test-reactor.cc	/^    void start_accept() {$/;"	f	struct:test
test	tests/test-reactor.cc	/^    test(pollable_fd l) : listener(std::move(l)) {}$/;"	f	struct:test
test	tests/test-reactor.cc	/^struct test {$/;"	s	file:
init_unit_test_suite	tests/test-utils.cc	/^bool init_unit_test_suite() {$/;"	f
main	tests/test-utils.cc	/^int main(int ac, char** av) {$/;"	f
run	tests/test-utils.cc	/^void seastar_test::run() {$/;"	f	class:seastar_test
seastar_test	tests/test-utils.cc	/^seastar_test::seastar_test() {$/;"	f	class:seastar_test
tests	tests/test-utils.cc	/^static std::vector<seastar_test*>* tests;$/;"	v	file:
BOOST_TEST_DYN_LINK	tests/test-utils.hh	25;"	d
SEASTAR_TEST_CASE	tests/test-utils.hh	42;"	d
seastar_test	tests/test-utils.hh	/^class seastar_test {$/;"	c
~seastar_test	tests/test-utils.hh	/^    virtual ~seastar_test() {}$/;"	f	class:seastar_test
global_test_runner	tests/test_runner.cc	/^test_runner& global_test_runner() {$/;"	f
instance	tests/test_runner.cc	/^static test_runner instance;$/;"	v	file:
run_sync	tests/test_runner.cc	/^test_runner::run_sync(std::function<future<>()> task) {$/;"	f	class:test_runner
start	tests/test_runner.cc	/^test_runner::start(int ac, char** av) {$/;"	f	class:test_runner
stop_execution	tests/test_runner.cc	/^struct stop_execution : public std::exception {};$/;"	s	file:
~test_runner	tests/test_runner.cc	/^test_runner::~test_runner() {$/;"	f	class:test_runner
_done	tests/test_runner.hh	/^    bool _done = false;$/;"	m	class:test_runner
_task	tests/test_runner.hh	/^    exchanger<std::function<future<>()>> _task;$/;"	m	class:test_runner
_thread	tests/test_runner.hh	/^    std::unique_ptr<posix_thread> _thread;$/;"	m	class:test_runner
test_runner	tests/test_runner.hh	/^class test_runner {$/;"	c
begin_measurement	tests/thread_context_switch.cc	/^    void begin_measurement() {$/;"	f	class:context_switch_tester
context_switch_tester	tests/thread_context_switch.cc	/^class context_switch_tester {$/;"	c	file:
main	tests/thread_context_switch.cc	/^int main(int ac, char** av) {$/;"	f
main1	tests/thread_context_switch.cc	/^    void main1() {$/;"	f	class:context_switch_tester	file:
main2	tests/thread_context_switch.cc	/^    void main2() {$/;"	f	class:context_switch_tester	file:
measure	tests/thread_context_switch.cc	/^    future<uint64_t> measure() {$/;"	f	class:context_switch_tester
stop	tests/thread_context_switch.cc	/^    future<> stop() {$/;"	f	class:context_switch_tester
SEASTAR_TEST_CASE	tests/thread_test.cc	/^SEASTAR_TEST_CASE(test_thread_1) {$/;"	f
SEASTAR_TEST_CASE	tests/thread_test.cc	/^SEASTAR_TEST_CASE(test_thread_2) {$/;"	f
BUG	tests/timertest.cc	29;"	d	file:
OK	tests/timertest.cc	34;"	d	file:
main	tests/timertest.cc	/^int main(int ac, char** av) {$/;"	f
pr1	tests/timertest.cc	/^    promise<> pr1;$/;"	m	struct:timer_test	file:
pr2	tests/timertest.cc	/^    promise<> pr2;$/;"	m	struct:timer_test	file:
run	tests/timertest.cc	/^    future<> run() {$/;"	f	struct:timer_test
t1	tests/timertest.cc	/^    timer<Clock> t1;$/;"	m	struct:timer_test	file:
t2	tests/timertest.cc	/^    timer<Clock> t2;$/;"	m	struct:timer_test	file:
t3	tests/timertest.cc	/^    timer<Clock> t3;$/;"	m	struct:timer_test	file:
t4	tests/timertest.cc	/^    timer<Clock> t4;$/;"	m	struct:timer_test	file:
t5	tests/timertest.cc	/^    timer<Clock> t5;$/;"	m	struct:timer_test	file:
test_timer_cancelling	tests/timertest.cc	/^    future<> test_timer_cancelling() {$/;"	f	struct:timer_test
timer_test	tests/timertest.cc	/^struct timer_test {$/;"	s	file:
_chan	tests/udp_client.cc	/^    udp_channel _chan;$/;"	m	class:client	file:
_stats_timer	tests/udp_client.cc	/^    timer<> _stats_timer;$/;"	m	class:client	file:
client	tests/udp_client.cc	/^class client {$/;"	c	file:
main	tests/udp_client.cc	/^int main(int ac, char ** av) {$/;"	f
start	tests/udp_client.cc	/^    void start(ipv4_addr server_addr) {$/;"	f	class:client
_chan	tests/udp_server.cc	/^    udp_channel _chan;$/;"	m	class:udp_server	file:
_stats_timer	tests/udp_server.cc	/^    timer<> _stats_timer;$/;"	m	class:udp_server	file:
do_accepts	tests/udp_server.cc	/^    kj::Promise<void> do_accepts() {$/;"	f	class:udp_server
done	tests/udp_server.cc	/^    bool done;$/;"	m	class:udp_server	file:
kj_keep_doing	tests/udp_server.cc	/^    kj::Promise<void> kj_keep_doing(AsyncAction&& action) {$/;"	f	class:udp_server
main	tests/udp_server.cc	/^int main(int ac, char ** av) {$/;"	f
start	tests/udp_server.cc	/^    void start(uint16_t port) {$/;"	f	class:udp_server
udp_server	tests/udp_server.cc	/^    udp_server(): waitScope(engine()), done(false) {};$/;"	f	class:udp_server
udp_server	tests/udp_server.cc	/^class udp_server {$/;"	c	file:
waitScope	tests/udp_server.cc	/^    kj::WaitScope waitScope;$/;"	m	class:udp_server	file:
_chan	tests/udp_zero_copy.cc	/^    udp_channel _chan;$/;"	m	class:server	file:
_chunk_distribution	tests/udp_zero_copy.cc	/^    std::uniform_int_distribution<size_t> _chunk_distribution;$/;"	m	class:server	file:
_chunk_size	tests/udp_zero_copy.cc	/^    size_t _chunk_size;$/;"	m	class:server	file:
_copy	tests/udp_zero_copy.cc	/^    bool _copy;$/;"	m	class:server	file:
_key	tests/udp_zero_copy.cc	/^    sstring _key;$/;"	m	class:server	file:
_last	tests/udp_zero_copy.cc	/^    clock_type::time_point _last;$/;"	m	class:server	file:
_mem	tests/udp_zero_copy.cc	/^    char* _mem;$/;"	m	class:server	file:
_mem_size	tests/udp_zero_copy.cc	/^    size_t _mem_size;$/;"	m	class:server	file:
_out	tests/udp_zero_copy.cc	/^    std::unique_ptr<output_stream<char>> _out;$/;"	m	class:server	file:
_packet_size	tests/udp_zero_copy.cc	/^    size_t _packet_size = 8*KB;$/;"	m	class:server	file:
_packets	tests/udp_zero_copy.cc	/^    std::vector<packet> _packets;$/;"	m	class:server	file:
_randem_dev	tests/udp_zero_copy.cc	/^    std::random_device _randem_dev;$/;"	m	class:server	file:
_rnd	tests/udp_zero_copy.cc	/^    std::mt19937 _rnd;$/;"	m	class:server	file:
_stats_timer	tests/udp_zero_copy.cc	/^    timer<> _stats_timer;$/;"	m	class:server	file:
main	tests/udp_zero_copy.cc	/^int main(int ac, char ** av) {$/;"	f
next_chunk	tests/udp_zero_copy.cc	/^    char* next_chunk() {$/;"	f	class:server	file:
send	tests/udp_zero_copy.cc	/^    future<> send(ipv4_addr dst, packet p) {$/;"	f	class:server
server	tests/udp_zero_copy.cc	/^    server()$/;"	f	class:server
server	tests/udp_zero_copy.cc	/^class server {$/;"	c	file:
start	tests/udp_zero_copy.cc	/^    void start(int chunk_size, bool copy, size_t mem_size) {$/;"	f	class:server
to_seconds	tests/udp_zero_copy.cc	/^typename Duration::rep to_seconds(Duration d) {$/;"	f
CONVERSIONS_CC_	util/conversions.cc	23;"	d	file:
parse_memory_size	util/conversions.cc	/^size_t parse_memory_size(std::string s) {$/;"	f
CONVERSIONS_HH_	util/conversions.hh	23;"	d
string2vector	util/conversions.hh	/^static inline std::vector<char> string2vector(std::string str) {$/;"	f
UTIL_DEFER_HH_	util/defer.hh	23;"	d
_cancelled	util/defer.hh	/^    bool _cancelled = false;$/;"	m	class:deferred_action
_func	util/defer.hh	/^    Func _func;$/;"	m	class:deferred_action
cancel	util/defer.hh	/^    void cancel() { _cancelled = true; }$/;"	f	class:deferred_action
defer	util/defer.hh	/^defer(Func&& func) {$/;"	f
deferred_action	util/defer.hh	/^    deferred_action(Func&& func) : _func(std::move(func)) {}$/;"	f	class:deferred_action
deferred_action	util/defer.hh	/^class deferred_action {$/;"	c
~deferred_action	util/defer.hh	/^    ~deferred_action() { _func(); }$/;"	f	class:deferred_action
ECLIPSE_HH_	util/eclipse.hh	24;"	d
alignof	util/eclipse.hh	35;"	d
UTIL_FUNCTION_INPUT_ITERATOR_HH_	util/function_input_iterator.hh	23;"	d
_func	util/function_input_iterator.hh	/^    Function _func;$/;"	m	struct:function_input_iterator
_state	util/function_input_iterator.hh	/^    State _state;$/;"	m	struct:function_input_iterator
function_input_iterator	util/function_input_iterator.hh	/^    function_input_iterator(Function func, State state)$/;"	f	struct:function_input_iterator
function_input_iterator	util/function_input_iterator.hh	/^struct function_input_iterator {$/;"	s
make_function_input_iterator	util/function_input_iterator.hh	/^make_function_input_iterator(Function func, State state) {$/;"	f
make_function_input_iterator	util/function_input_iterator.hh	/^make_function_input_iterator(Function&& func) {$/;"	f
operator !=	util/function_input_iterator.hh	/^    bool operator!=(const function_input_iterator& x) const {$/;"	f	struct:function_input_iterator
operator *	util/function_input_iterator.hh	/^    auto operator*() const {$/;"	f	struct:function_input_iterator
operator ++	util/function_input_iterator.hh	/^    function_input_iterator operator++(int) {$/;"	f	struct:function_input_iterator
operator ++	util/function_input_iterator.hh	/^    function_input_iterator& operator++() {$/;"	f	struct:function_input_iterator
operator ==	util/function_input_iterator.hh	/^    bool operator==(const function_input_iterator& x) const {$/;"	f	struct:function_input_iterator
UTIL_TRANSFORM_ITERATOR_HH_	util/transform_iterator.hh	23;"	d
_f	util/transform_iterator.hh	/^    Func _f;$/;"	m	class:transform_iterator
_i	util/transform_iterator.hh	/^    Iterator _i;$/;"	m	class:transform_iterator
make_transform_iterator	util/transform_iterator.hh	/^make_transform_iterator(Iterator i, Func f) {$/;"	f
operator !=	util/transform_iterator.hh	/^    bool operator!=(const transform_iterator& x) const {$/;"	f	class:transform_iterator
operator *	util/transform_iterator.hh	/^    auto operator*() { return _f(*_i); }$/;"	f	class:transform_iterator
operator ++	util/transform_iterator.hh	/^    transform_iterator operator++(int) {$/;"	f	class:transform_iterator
operator ++	util/transform_iterator.hh	/^    transform_iterator& operator++() {$/;"	f	class:transform_iterator
operator ==	util/transform_iterator.hh	/^    bool operator==(const transform_iterator& x) const {$/;"	f	class:transform_iterator
transform_iterator	util/transform_iterator.hh	/^    transform_iterator(Iterator i, Func f) : _i(i), _f(f) {}$/;"	f	class:transform_iterator
transform_iterator	util/transform_iterator.hh	/^class transform_iterator {$/;"	c
